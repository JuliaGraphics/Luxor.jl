<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function reference · Luxor</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/luxor-docs.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Luxor logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Luxor</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction to Luxor</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorial/quickstart/">Quick and short</a></li><li><a class="tocitem" href="../../tutorial/basictutorial/">A more in-depth tutorial</a></li><li><a class="tocitem" href="../../tutorial/simple-animation/">Simple animation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../example/examples/">Simple examples</a></li><li><a class="tocitem" href="../../example/moreexamples/">More examples</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">How to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../howto/createdrawings/">Create drawings</a></li><li><a class="tocitem" href="../../howto/simplegraphics/">Draw simple shapes</a></li><li><a class="tocitem" href="../../howto/geometrytools/">Use geometry tools</a></li><li><a class="tocitem" href="../../howto/tables-grids/">Work with tables and grids</a></li><li><a class="tocitem" href="../../howto/colors-styles/">Use colors and styles</a></li><li><a class="tocitem" href="../../howto/polygons/">Work with polygons</a></li><li><a class="tocitem" href="../../howto/text/">Add text</a></li><li><a class="tocitem" href="../../howto/clipping/">Clip graphics</a></li><li><a class="tocitem" href="../../howto/images/">Placing images</a></li><li><a class="tocitem" href="../../howto/turtle/">Turtle graphics</a></li><li><a class="tocitem" href="../../howto/animation/">Make animations</a></li><li><a class="tocitem" href="../../howto/livegraphics/">Live graphics and snapshots</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Explanations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../explanation/basics/">Basic concepts</a></li><li><a class="tocitem" href="../../explanation/pathspolygons/">Paths vs Polygon</a></li><li><a class="tocitem" href="../../explanation/perfectpixels/">Perfect pixels and antialising</a></li><li><a class="tocitem" href="../../explanation/transforms/">Transforms and matrices</a></li><li><a class="tocitem" href="../../explanation/imagematrix/">Image matrix</a></li><li><a class="tocitem" href="../../explanation/luxorcairo/">Luxor and Cairo</a></li><li><a class="tocitem" href="../../explanation/contributing/">Contributing</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../functionindex/">Alphabetical function list</a></li><li class="is-active"><a class="tocitem" href>Function reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Function reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGraphics/Luxor.jl/blob/master/docs/src/reference/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><article class="docstring"><header><a class="docstring-binding" id="Luxor.@draw" href="#Luxor.@draw"><code>Luxor.@draw</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@draw drawing-instructions [width] [height]</code></pre><p>Preview an PNG drawing, optionally specifying width and height (the default is 600 by 600). The drawing is stored in memory, not in a file on disk.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@draw circle(O, 20, :fill)

@draw circle(O, 20, :fill) 400

@draw circle(O, 20, :fill) 400 1200


@draw begin
         setline(10)
         sethue(&quot;purple&quot;)
         circle(O, 20, :fill)
      end


@draw begin
         setline(10)
         sethue(&quot;purple&quot;)
         circle(O, 20, :fill)
      end 1200 1200</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/drawings.jl#L747-L776">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@drawsvg" href="#Luxor.@drawsvg"><code>Luxor.@drawsvg</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@drawsvg begin
    body
end w h</code></pre><p>Create and preview an SVG drawing. Like <code>@draw</code> but using SVG format.</p><p>Unlike <code>@draw</code> (PNG), there is no background, by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/drawings.jl#L1131-L1139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@eps" href="#Luxor.@eps"><code>Luxor.@eps</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@eps drawing-instructions [width] [height] [filename]</code></pre><p>Create and preview an EPS drawing, optionally specifying width and height (the default is 600 by 600). The file is saved in the current working directory as <code>filename</code> if supplied, or <code>luxor-drawing(timestamp).eps</code>.</p><p>On some platforms, EPS files are converted automatically to PDF when previewed.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@eps circle(O, 20, :fill)

@eps circle(O, 20, :fill) 400

@eps circle(O, 20, :fill) 400 1200

@eps circle(O, 20, :fill) 400 1200 &quot;/tmp/A0-version&quot;

@eps circle(O, 20, :fill) 400 1200 &quot;/tmp/A0-version.eps&quot;

@eps begin
        setline(10)
        sethue(&quot;purple&quot;)
        circle(O, 20, :fill)
     end

@eps begin
        setline(10)
        sethue(&quot;purple&quot;)
        circle(O, 20, :fill)
     end 1200 1200</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/drawings.jl#L699-L733">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@imagematrix" href="#Luxor.@imagematrix"><code>Luxor.@imagematrix</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@imagematrix drawing-instructions [width=256] [height=256]</code></pre><p>Create a drawing and return a matrix of the image.</p><p>This macro returns a matrix of pixels that represent the drawing produced by the vector graphics instructions. It uses the <code>image_as_matrix()</code> function.</p><p>The default drawing is 256 by 256 points.</p><p>You don&#39;t need <code>finish()</code> (the macro calls it), and it&#39;s not previewed by <code>preview()</code>.</p><pre><code class="nohighlight hljs">m = @imagematrix begin
        sethue(&quot;red&quot;)
        box(O, 20, 20, :fill)
    end 60 60

julia&gt;  m[1220:1224] |&gt; show
    ARGB32[ARGB32(0.0N0f8,0.0N0f8,0.0N0f8,0.0N0f8),
           ARGB32(1.0N0f8,0.0N0f8,0.0N0f8,1.0N0f8),
           ARGB32(1.0N0f8,0.0N0f8,0.0N0f8,1.0N0f8),
           ARGB32(1.0N0f8,0.0N0f8,0.0N0f8,1.0N0f8),
           ARGB32(1.0N0f8,0.0N0f8,0.0N0f8,1.0N0f8)]
</code></pre><p>If, for some strange reason you want to draw the matrix as another Luxor drawing again, use code such as this:</p><pre><code class="nohighlight hljs">m = @imagematrix begin
        sethue(&quot;red&quot;)
        box(O, 20, 20, :fill)
        sethue(&quot;blue&quot;)
        box(O, 10, 40, :fill)
    end 60 60

function convertmatrixtocolors(m)
    return convert.(Colors.RGBA, m)
end

function drawimagematrix(m)
    d = Drawing(500, 500, &quot;/tmp/temp.png&quot;)
    origin()
    w, h = size(m)
    t = Tiler(500, 500, w, h)
    mi = convertmatrixtocolors(m)
    @show mi[30, 30]
    for (pos, n) in t
        c = mi[t.currentrow, t.currentcol]
        setcolor(c)
        box(pos, t.tilewidth -1, t.tileheight - 1, :fill)
    end
    finish()
    return d
end

drawimagematrix(m)</code></pre><p>Transparency</p><p>The default value for the cells in an image matrix is transparent black. (Luxor&#39;s default color is opaque black.)</p><pre><code class="nohighlight hljs">julia&gt; @imagematrix begin
       end 2 2
2×2 reinterpret(ARGB32, ::Array{UInt32,2}):
 ARGB32(0.0,0.0,0.0,0.0)  ARGB32(0.0,0.0,0.0,0.0)
 ARGB32(0.0,0.0,0.0,0.0)  ARGB32(0.0,0.0,0.0,0.0)</code></pre><p>Setting the background to a partially or completely transparent value may give unexpected results:</p><pre><code class="nohighlight hljs">julia&gt; @imagematrix begin
       background(1, 0.5, 0.0, 0.5) # semi-transparent orange
       end 2 2
2×2 reinterpret(ARGB32, ::Array{UInt32,2}):
 ARGB32(0.502,0.251,0.0,0.502)  ARGB32(0.502,0.251,0.0,0.502)
 ARGB32(0.502,0.251,0.0,0.502)  ARGB32(0.502,0.251,0.0,0.502)</code></pre><p>here the semi-transparent orange color has been partially applied to the transparent background.</p><pre><code class="nohighlight hljs">julia&gt; @imagematrix begin
           sethue(1., 0.5, 0.0)
       paint()
       end 2 2
2×2 reinterpret(ARGB32, ::Array{UInt32,2}):
 ARGB32(1.0,0.502,0.0,1.0)  ARGB32(1.0,0.502,0.0,1.0)
 ARGB32(1.0,0.502,0.0,1.0)  ARGB32(1.0,0.502,0.0,1.0)</code></pre><p>picks up the default alpha of 1.0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/drawings.jl#L891-L991">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@imagematrix!" href="#Luxor.@imagematrix!"><code>Luxor.@imagematrix!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@imagematrix! buffer drawing-instructions [width=256] [height=256]</code></pre><p>Like <code>@imagematrix</code>, but use an existing UInt32 buffer.</p><pre><code class="nohighlight hljs">w = 200
h  = 150
buffer = zeros(UInt32, w, h)
m = @imagematrix! buffer juliacircles(40) 200 150;
Images.RGB.(m)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/drawings.jl#L1039-L1051">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@layer-Tuple{Any}" href="#Luxor.@layer-Tuple{Any}"><code>Luxor.@layer</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">The `layer` macro is a shortcut for `gsave()` ... `grestore()`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L520-L522">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@pdf" href="#Luxor.@pdf"><code>Luxor.@pdf</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@pdf drawing-instructions [width] [height] [filename]</code></pre><p>Create and preview an PDF drawing, optionally specifying width and height (the default is 600 by 600). The file is saved in the current working directory as <code>filename</code> if supplied, or <code>luxor-drawing(timestamp).pdf</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@pdf circle(O, 20, :fill)

@pdf circle(O, 20, :fill) 400

@pdf circle(O, 20, :fill) 400 1200

@pdf circle(O, 20, :fill) 400 1200 &quot;/tmp/A0-version&quot;

@pdf circle(O, 20, :fill) 400 1200 &quot;/tmp/A0-version.pdf&quot;

@pdf begin
        setline(10)
        sethue(&quot;purple&quot;)
        circle(O, 20, :fill)
     end

@pdf begin
        setline(10)
        sethue(&quot;purple&quot;)
        circle(O, 20, :fill)
     end 1200 1200</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/drawings.jl#L652-L685">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@png" href="#Luxor.@png"><code>Luxor.@png</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@png drawing-instructions [width] [height] [filename]</code></pre><p>Create and preview an PNG drawing, optionally specifying width and height (the default is 600 by 600). The file is saved in the current working directory as <code>filename</code>, if supplied, or <code>luxor-drawing(timestamp).png</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@png circle(O, 20, :fill)

@png circle(O, 20, :fill) 400

@png circle(O, 20, :fill) 400 1200

@png circle(O, 20, :fill) 400 1200 &quot;/tmp/round&quot;

@png circle(O, 20, :fill) 400 1200 &quot;/tmp/round.png&quot;

@png begin
        setline(10)
        sethue(&quot;purple&quot;)
        circle(O, 20, :fill)
     end


@png begin
        setline(10)
        sethue(&quot;purple&quot;)
        circle(O, 20, :fill)
     end 1200 1200</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/drawings.jl#L605-L638">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@polar-Tuple{Any}" href="#Luxor.@polar-Tuple{Any}"><code>Luxor.@polar</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@polar (p)</code></pre><p>Convert a tuple of two numbers to a Point of x, y Cartesian coordinates.</p><pre><code class="nohighlight hljs">@polar (10, pi/4)
@polar [10, pi/4]</code></pre><p>produces</p><pre><code class="nohighlight hljs">Luxor.Point(7.0710678118654755, 7.071067811865475)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L375-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@savesvg" href="#Luxor.@savesvg"><code>Luxor.@savesvg</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@savesvg begin
    body
end w h</code></pre><p>Like <code>@drawsvg</code> but returns the raw SVG code of the drawing in a string. Uses <code>svgstring</code>.</p><p>Unlike <code>@draw</code> (PNG), there is no background, by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/drawings.jl#L1151-L1161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@setcolor_str-Tuple{Any}" href="#Luxor.@setcolor_str-Tuple{Any}"><code>Luxor.@setcolor_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Set the current color to a string using a macro.</p><p>For example:</p><pre><code class="nohighlight hljs">setcolor&quot;red&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/colors_styles.jl#L77-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@svg" href="#Luxor.@svg"><code>Luxor.@svg</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@svg drawing-instructions [width] [height] [filename]</code></pre><p>Create and preview an SVG drawing, optionally specifying width and height (the default is 600 by 600). The file is saved in the current working directory as <code>filename</code> if supplied, or <code>luxor-drawing-(timestamp).svg</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@svg circle(O, 20, :fill)

@svg circle(O, 20, :fill) 400

@svg circle(O, 20, :fill) 400 1200

@svg circle(O, 20, :fill) 400 1200 &quot;/tmp/test&quot;

@svg circle(O, 20, :fill) 400 1200 &quot;/tmp/test.svg&quot;

@svg begin
        setline(10)
        sethue(&quot;purple&quot;)
        circle(O, 20, :fill)
     end

@svg begin
        setline(10)
        sethue(&quot;purple&quot;)
        circle(O, 20, :fill)
     end 1200 1200</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/drawings.jl#L559-L591">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{Vector{Point}}, BoundingBox}" href="#Base.convert-Tuple{Type{Vector{Point}}, BoundingBox}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(Point, bbox::BoundingBox)</code></pre><p>Convert a BoundingBox to a four-point clockwise polygon.</p><pre><code class="nohighlight hljs">convert(Vector{Point}, BoundingBox())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L256-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.hcat-Tuple{Vararg{Drawing}}" href="#Base.hcat-Tuple{Vararg{Drawing}}"><code>Base.hcat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hcat(D::Drawing...; valign=:top, hpad=0, clip=true)</code></pre><p>Creates a new SVG drawing by horizontal concatenation of SVG drawings. If drawings have different height, the <code>valign</code> option can be used in order to define how to align. The <code>hpad</code> argument can be used to add padding between concatenated images.</p><p>The <code>clip</code> argument is a boolean for whether the concatenated images should be clipped before concatenation. Note that drawings sometimes have elements that go beyond it&#39;s margins, and they only show when the image is drawn in a larger canvas. The <code>clip</code> argument ensures that these elements are not drawn in the concatenated drawing.</p><p>Example:</p><pre><code class="language-julia hljs">d1 = Drawing(200,100,:svg)
origin()
circle(O,60,:fill)
finish()

d2 = Drawing(200,200,:svg)
rect(O,200,200,:fill)
finish()
hcat(d1,d2; hpad=10, valign=:top, clip = true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L660-L687">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.in-Tuple{Point, BoundingBox}" href="#Base.in-Tuple{Point, BoundingBox}"><code>Base.in</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">in(pt, bbox::BoundingBox)</code></pre><p>Test whether <code>pt</code> is inside <code>bbox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L582-L586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand-Tuple{BoundingBox}" href="#Base.rand-Tuple{BoundingBox}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand(bbox::BoundingBox)</code></pre><p>Return a random <code>Point</code> that lies inside <code>bbox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L573-L577">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.vcat-Tuple{Vararg{Drawing}}" href="#Base.vcat-Tuple{Vararg{Drawing}}"><code>Base.vcat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vcat(D::Drawing...; halign=:left, vpad=0, clip=true)</code></pre><p>Creates a new SVG drawing by vertical concatenation of SVG drawings. If drawings have different widths, the <code>halign</code> option can be used in order to define how to align. The <code>vpad</code> argument can be used to add padding between concatenated images.</p><p>The <code>clip</code> argument is a boolean for whether the concatenated images should be clipped before concatenation. Note that drawings sometimes have elements that go beyond it&#39;s margins, and they only show when the image is drawn in a larger canvas. The <code>clip</code> argument ensures that these elements are not drawn in the concatenated drawing.</p><p>Example:</p><pre><code class="language-julia hljs">d1 = Drawing(200,100,:svg)
origin()
circle(O,60,:fill)
finish()

d2 = Drawing(200,200,:svg)
rect(O,200,200,:fill)
finish()
vcat(d1,d2; vpad=10, halign=:left, clip = true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L721-L748">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Circle" href="#Luxor.Circle"><code>Luxor.Circle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Circle(t::Turtle, radius=1.0)</code></pre><p>Draw a filled circle centered at the current position with the given radius.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Turtle.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Forward" href="#Luxor.Forward"><code>Luxor.Forward</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Forward(t::Turtle, d=1)</code></pre><p>Move the turtle forward by <code>d</code> units. The stored position is updated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Turtle.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.HueShift" href="#Luxor.HueShift"><code>Luxor.HueShift</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HueShift(t::Turtle, inc=1.0)</code></pre><p>Shift the Hue of the turtle&#39;s pen forward by <code>inc</code>. Hue values range between 0 and 360. (Don&#39;t start with black, otherwise the saturation and brightness values will be black.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Turtle.jl#L189-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Message-Tuple{Turtle, Any}" href="#Luxor.Message-Tuple{Turtle, Any}"><code>Luxor.Message</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Message(t::Turtle, txt)</code></pre><p>Write some text at the current position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Turtle.jl#L177-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Orientation" href="#Luxor.Orientation"><code>Luxor.Orientation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Orientation(t::Turtle, r=0.0)</code></pre><p>Set the turtle&#39;s orientation to <code>r</code> degrees. See also <code>Turn</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Turtle.jl#L85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Pen_opacity_random-Tuple{Turtle}" href="#Luxor.Pen_opacity_random-Tuple{Turtle}"><code>Luxor.Pen_opacity_random</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Pen_opacity_random(t::Turtle)</code></pre><p>Change the opacity of the pen to some value at random.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Turtle.jl#L261-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Pencolor-Tuple{Turtle, Any, Any, Any}" href="#Luxor.Pencolor-Tuple{Turtle, Any, Any, Any}"><code>Luxor.Pencolor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Pencolor(t::Turtle, r, g, b)</code></pre><p>Set the Red, Green, and Blue colors of the turtle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Turtle.jl#L219-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Pendown-Tuple{Turtle}" href="#Luxor.Pendown-Tuple{Turtle}"><code>Luxor.Pendown</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Pendown(t::Turtle)</code></pre><p>Put that pen down and start drawing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Turtle.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Penup-Tuple{Turtle}" href="#Luxor.Penup-Tuple{Turtle}"><code>Luxor.Penup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Penup(t::Turtle)</code></pre><p>Pick that pen up and stop drawing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Turtle.jl#L117-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Penwidth-Tuple{Turtle, Any}" href="#Luxor.Penwidth-Tuple{Turtle, Any}"><code>Luxor.Penwidth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Penwidth(t::Turtle, w)</code></pre><p>Set the width of the line drawn.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Turtle.jl#L254-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Pop-Tuple{Turtle}" href="#Luxor.Pop-Tuple{Turtle}"><code>Luxor.Pop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Pop(t::Turtle)</code></pre><p>Lift the turtle&#39;s position and orientation off a stack.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Turtle.jl#L161-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Push-Tuple{Turtle}" href="#Luxor.Push-Tuple{Turtle}"><code>Luxor.Push</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Push(t::Turtle)</code></pre><p>Save the turtle&#39;s position and orientation on a stack.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Turtle.jl#L150-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Randomize_saturation-Tuple{Turtle}" href="#Luxor.Randomize_saturation-Tuple{Turtle}"><code>Luxor.Randomize_saturation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Randomize_saturation(t::Turtle)</code></pre><p>Randomize the saturation of the turtle&#39;s pen color.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Turtle.jl#L205-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Rectangle" href="#Luxor.Rectangle"><code>Luxor.Rectangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Rectangle(t::Turtle, width=10.0, height=10.0)</code></pre><p>Draw a filled rectangle centered at the current position with the given radius.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Turtle.jl#L138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Reposition-Tuple{Turtle, Any, Any}" href="#Luxor.Reposition-Tuple{Turtle, Any, Any}"><code>Luxor.Reposition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Reposition(t::Turtle, pos::Point)
Reposition(t::Turtle, x, y)</code></pre><p>Reposition: pick the turtle up and place it at another position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Turtle.jl#L241-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Towards-Tuple{Turtle, Point}" href="#Luxor.Towards-Tuple{Turtle, Point}"><code>Luxor.Towards</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Towards(t::Turtle, pos::Point)</code></pre><p>Rotate the turtle to face towards a given point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Turtle.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Turn" href="#Luxor.Turn"><code>Luxor.Turn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Turn(t::Turtle, r=5.0)</code></pre><p>Increase the turtle&#39;s rotation by <code>r</code> degrees. See also <code>Orientation</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Turtle.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor._argb32_to_rgba-Tuple{Any}" href="#Luxor._argb32_to_rgba-Tuple{Any}"><code>Luxor._argb32_to_rgba</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_argb32_to_rgba(i)</code></pre><p>Convert a 32bit ARGB Int to a four value array:</p><pre><code class="nohighlight hljs">_argb32_to_rgba(0xFF800000)

4-element Array{Float64,1}:
 1.0
 0.5019607843137255
 0.0
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/drawings.jl#L789-L804">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor._betweenpoly-Tuple{Any, Any, Any}" href="#Luxor._betweenpoly-Tuple{Any, Any, Any}"><code>Luxor._betweenpoly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_betweenpoly(loop1, loop2, k;
    samples = 100,
    easingfunction = easingflat)</code></pre><p>Find a simple polygon between the two simple polygons <code>loop1</code> and <code>loop2</code> corresponding to <code>k</code>, where <code>0.0 &lt; k &lt; 1.0</code>.</p><p>By default, <code>easingfunction = easingflat</code>, so the intermediate steps are linearly spaced. If you use another easing function, intermediate steps are determined by the value of the easing function at <code>k</code>.</p><p>Used by <code>polymorph()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L1609-L1624">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor._empty_neighbourhood-Tuple{Point, Any, Any, Any, Any, Vector{Point}, Any}" href="#Luxor._empty_neighbourhood-Tuple{Point, Any, Any, Any, Any, Vector{Point}, Any}"><code>Luxor._empty_neighbourhood</code></a> — <span class="docstring-category">Method</span></header><section><div><p><em>empty</em>neighbourhood(sample, w, h, cellsize, d, points, grid)</p><p>Uses entries in <code>grid</code> to check whether the <code>sample</code> point is more than <code>d</code> units away from any other point in <code>points</code>.</p><p>The region we&#39;re analyzing lies between the origin and <code>Point(w, h)</code>`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/randompoints.jl#L54-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.add_mesh_patch" href="#Luxor.add_mesh_patch"><code>Luxor.add_mesh_patch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_mesh_patch(pattern::Mesh, plist::Array{Point}, colors=Array{Colors.Colorant, 1})</code></pre><p>Add a new patch to the mesh pattern in <code>pattern</code>.</p><p>The first three or four sides of the supplied <code>points</code> polygon define the three or four sides of the mesh shape.</p><p>The <code>colors</code> array define the color of each corner point. Colors are reused if necessary. At least one color should be supplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/mesh.jl#L45-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.add_mesh_patch" href="#Luxor.add_mesh_patch"><code>Luxor.add_mesh_patch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_mesh_patch(pattern::Mesh, bezierpath::BezierPath,
	colors=Array{Colors.Colorant, 1})</code></pre><p>Add a new patch to the mesh pattern in <code>pattern</code>.</p><p>The first three or four elements of the supplied <code>bezierpath</code> define the three or four sides of the mesh shape.</p><p>The <code>colors</code> array define the color of each corner point. Colors are reused if necessary. At least one color should be supplied.</p><p>Use <code>setmesh()</code> to select the mesh, which will be used to fill shapes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/mesh.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.addstop-Tuple{Cairo.CairoPattern, Any, ColorTypes.Colorant}" href="#Luxor.addstop-Tuple{Cairo.CairoPattern, Any, ColorTypes.Colorant}"><code>Luxor.addstop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addstop(b::Blend, offset, col)
addstop(b::Blend, offset, (r, g, b, a))
addstop(b::Blend, offset, string)</code></pre><p>Add a color stop to a blend. The offset specifies the location along the blend&#39;s &#39;control vector&#39;, which varies between 0 (beginning of the blend) and 1 (end of the blend). For linear blends, the control vector is from the start point to the end point. For radial blends, the control vector is from any point on the start circle, to the corresponding point on the end circle.</p><p>Examples:</p><pre><code class="nohighlight hljs">blendredblue = blend(Point(0, 0), 0, Point(0, 0), 1)
addstop(blendredblue, 0, setcolor(sethue(&quot;red&quot;)..., .2))
addstop(blendredblue, 1, setcolor(sethue(&quot;blue&quot;)..., .2))
addstop(blendredblue, 0.5, sethue(randomhue()...))
addstop(blendredblue, 0.5, setcolor(randomcolor()...))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/blends.jl#L71-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.anglethreepoints-Tuple{Point, Point, Point}" href="#Luxor.anglethreepoints-Tuple{Point, Point, Point}"><code>Luxor.anglethreepoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">anglethreepoints(p1::Point, p2::Point, p3::Point)</code></pre><p>Find the angle formed by two lines defined by three points.</p><p>If the angle is less than π, the line heads to the left.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L562-L568">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.animate-Tuple{Movie, Scene}" href="#Luxor.animate-Tuple{Movie, Scene}"><code>Luxor.animate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">animate(movie::Movie, scene::Scene; creategif=false, framerate=30)</code></pre><p>Create the movie defined in <code>movie</code> by rendering the frames define in <code>scene</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L252-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.animate-Tuple{Movie, Vector{Scene}}" href="#Luxor.animate-Tuple{Movie, Vector{Scene}}"><code>Luxor.animate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">animate(movie::Movie, scenelist::Array{Scene, 1};
    creategif=false,
    framerate=30,
    pathname=&quot;&quot;,
    tempdirectory=&quot;&quot;,
    usenewffmpeg=true)</code></pre><p>Create the movie defined in <code>movie</code> by rendering the frames define in the array of scenes in <code>scenelist</code>.</p><p>If <code>creategif</code> is <code>true</code>, the function attempts to call the <code>ffmpeg</code> utility on the resulting frames to build a GIF animation. This will be stored in <code>pathname</code> (an existing file will be overwritten; use a &quot;.gif&quot; suffix), or in <code>(movietitle).gif</code> in a temporary directory. <code>ffmpeg</code> should be installed and available, of course, if this is to work.</p><p>In suitable environments, the resulting animation is displayed in the Plots window.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">animate(bang, [
    Scene(bang, backdrop, 0:200),
    Scene(bang, frame1, 0:200, easingfunction=easeinsine)],
    creategif=true,
    pathname=&quot;/tmp/animationtest.gif&quot;)</code></pre><p>The <code>usenewffmpeg</code> option, <code>true</code> by default, uses single-pass palette generation and more complex filtering provided by recent versions of the <code>ffmpeg</code> utility, mainly to cope with transparent backgrounds. If set to <code>false</code>, the behavior is the same as in previous versions of Luxor.</p><p>If you prefer to use the FFMPEG package, use code such as this:</p><pre><code class="language-julia hljs">using FFMPEG

...

tempdirectory = &quot;/tmp/temp/&quot;

animate(movie, [
        Scene(movie, frame, 1:50)
    ], creategif=false, tempdirectory=tempdirectory)

FFMPEG.ffmpeg_exe(`-r 30 -f image2 -i $(tempdirectory)/%10d.png -c:v libx264 -r 30 -pix_fmt yuv420p -y /tmp/animation.mp4`)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L122-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.arc-Tuple{Point, Any, Any, Any}" href="#Luxor.arc-Tuple{Point, Any, Any, Any}"><code>Luxor.arc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">arc(centerpoint::Point, radius, angle1, angle2; action=:none)
arc(centerpoint::Point, radius, angle1, angle2, action)</code></pre><p>Add an arc to the current path from <code>angle1</code> to <code>angle2</code> going clockwise, centered at <code>centerpoint</code>.</p><p>Angles are defined relative to the x-axis, positive clockwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L184-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.arc2r-Tuple{Point, Point, Point}" href="#Luxor.arc2r-Tuple{Point, Point, Point}"><code>Luxor.arc2r</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">  arc2r(c1::Point, p2::Point, p3::Point; action=:none)
  arc2r(c1::Point, p2::Point, p3::Point, action)</code></pre><p>Add a circular arc centered at <code>c1</code> that starts at <code>p2</code> and ends at <code>p3</code>, going clockwise, to the current path.</p><p><code>c1</code>-<code>p2</code> really determines the radius. If <code>p3</code> doesn&#39;t lie on the circular path,  it will be used only as an indication of the arc&#39;s length, rather than its position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L224-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.arc2sagitta-Tuple{Point, Point, Real}" href="#Luxor.arc2sagitta-Tuple{Point, Point, Real}"><code>Luxor.arc2sagitta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">arc2sagitta(p1::Point, p2::Point, s;
    action=:none)</code></pre><p>Make a clockwise arc starting at <code>p1</code> and ending at <code>p2</code> that reaches a height of <code>s</code>, the sagitta, at the middle, and add it to the current path.</p><p>Return tuple of the center point and the radius of the arc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L1018-L1027">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.arrow" href="#Luxor.arrow"><code>Luxor.arrow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">arrow(start::Point, finish::Point, height::Vector, action=:stroke;
    keyword arguments...)</code></pre><p>Draw a Bézier arrow between <code>start</code> and <code>finish</code>, with control points defined to fit in an imaginary box defined by the two supplied <code>height</code> values (see <code>bezierfrompoints()</code>). If the height values are different signs, the arrow will change direction on its way.</p><p>Keyword arguments are the same as <a href="#Luxor.arrow"><code>arrow(pt1, pt2, pt3, pt4)</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">arrow(pts[1], pts[end], [15, 15],
    decoration = 0.5,
    decorate = () -&gt; text(string(pts[1])))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/arrows.jl#L421-L438">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.arrow" href="#Luxor.arrow"><code>Luxor.arrow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">arrow(start::Point, C1::Point, C2::Point, finish::Point, action=:stroke;
    linewidth       = 1.0,
    arrowheadlength = 10,
    arrowheadangle  = pi/8,
    startarrow      = false,
    finisharrow     = true,
    decoration      = 0.5,
    decorate        = nothing
    arrowheadfunction = nothing)</code></pre><p>Draw a Bezier curved arrow, from <code>start</code> to <code>finish</code>, with control points <code>C1</code> and <code>C2</code>. Arrow heads can be added/hidden by changing <code>startarrow</code> and <code>finisharrow</code> options.</p><p>The <code>decorate</code> keyword argument accepts a function that can execute code at one or more locations on the arrow&#39;s shaft. The inherited graphic environment is centered at each point on the shaft given by scalar or vector <code>decoration</code>, and the x-axis is aligned with the direction of the curve at that point.</p><p><strong>Example</strong></p><p>This code draws an arrow head that&#39;s filled with orange and outlined in green.</p><pre><code class="nohighlight hljs">function myarrowheadfunction(originalendpoint, newendpoint, shaftangle)
    @layer begin
        setline(5)
        translate(newendpoint)
        rotate(shaftangle)
        sethue(&quot;orange&quot;)
        ngon(O, 20, 3, 0, :fill)
        sethue(&quot;green&quot;)
        ngon(O, 20, 3, 0, :stroke)
    end
end

@drawsvg begin
    background(&quot;white&quot;)
    arrow(O, 220, 0, π,
        linewidth=10,
        arrowheadlength=30,
        arrowheadangle=π/7,
        clockwise=true,
        arrowheadfunction = myarrowheadfunction)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/arrows.jl#L284-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.arrow-Tuple{Point, Any, Any, Any}" href="#Luxor.arrow-Tuple{Point, Any, Any, Any}"><code>Luxor.arrow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">arrow(centerpos::Point, radius, startangle, endangle;
    linewidth          = 1.0,
    arrowheadlength    = 10,
    arrowheadangle     = π/8,
    decoration         = 0.5,
    decorate           = nothing,
    arrowheadfunction  = nothing,
    clockwise          = true)</code></pre><p>Draw a curved arrow, an arc centered at <code>centerpos</code> starting at <code>startangle</code> and ending at <code>endangle</code> with an arrowhead at the end. Angles are measured clockwise from the positive x-axis.</p><p>Arrows don&#39;t use the current linewidth setting (<code>setline()</code>); you can specify the linewidth.</p><p>The <code>decorate</code> keyword argument accepts a zero-argument function that can execute code at one or more locations on the arrow&#39;s shaft. The inherited graphic environment is centered at points on the shaft between 0 and 1 given by scalar or vector <code>decoration</code>, and the x-axis is aligned with the direction of the curve at that point.</p><p>A triangular arrowhead is drawn by default. But you can pass a function to the <code>arrowheadfunction</code> keyword argument that accepts three arguments: the shaft end, the arrow head end, and the shaft angle. Thsi allows you to draw any shape arrowhead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/arrows.jl#L163-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.arrow-Tuple{Point, Point}" href="#Luxor.arrow-Tuple{Point, Point}"><code>Luxor.arrow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">arrow(startpoint::Point, endpoint::Point;
    linewidth         = 1.0,
    arrowheadlength   = 10,
    arrowheadangle    = pi/8,
    decoration        = 0.5 or range(),
    decorate          = nothing,
    arrowheadfunction = nothing)</code></pre><p>Draw a line between two points and add an arrowhead at the end. The arrowhead length will be the length of the side of the arrow&#39;s head, and the arrowhead angle is the angle between the sloping side of the arrowhead and the arrow&#39;s shaft.</p><p>Arrows don&#39;t use the current linewidth setting (<code>setline()</code>), and defaults to 1, but you can specify another value. It doesn&#39;t need stroking/filling, the shaft is stroked and the head filled with the current color.</p><p><strong>Decoration</strong></p><p>The <code>decorate</code> keyword argument accepts a function with zero arguments that can execute code at one or more locations on the arrow&#39;s shaft. The inherited graphic environment is centered at each point on the shaft between 0 and 1 given by scalar or vector <code>decoration</code>, and the x-axis is aligned with the direction of the curve at that point.</p><p><strong>Arrowheads</strong></p><p>A triangular arrowhead is drawn by default. But you can pass a function to the <code>arrowheadfunction</code> keyword argument that accepts three arguments: the shaft end, the arrow head end, and the shaft angle. Thsi allows you to draw any shape arrowhead.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">function redbluearrow(shaftendpoint, endpoint, shaftangle)
    @layer begin
        sethue(&quot;red&quot;)
        sidept1 = shaftendpoint  + polar(10, shaftangle + π/2 )
        sidept2 = shaftendpoint  - polar(10, shaftangle + π/2)
        poly([sidept1, endpoint, sidept2], :fill)
        sethue(&quot;blue&quot;)
        poly([sidept1, endpoint, sidept2], :stroke, close=false)
    end
end

@drawsvg begin
    background(&quot;white&quot;)
    arrow(O, O + (120, 120),
        linewidth=4,
        arrowheadlength=40,
        arrowheadangle=π/7,
        arrowheadfunction = redbluearrow)

    arrow(O, 100, 3π/2, π,
        linewidth=4,
        arrowheadlength=20,
        clockwise=false,arrowheadfunction=redbluearrow)
end 800 250</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/arrows.jl#L28-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.arrowhead" href="#Luxor.arrowhead"><code>Luxor.arrowhead</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">arrowhead(target[, action=:fill];
    shaftangle=0,
    headlength=10,
    headangle=pi/8)</code></pre><p>Draw an arrow head. The arrowhead length will be the length of the side of the arrow&#39;s head, and the arrowhead angle is the angle between the sloping side of the arrowhead and the arrow&#39;s shaft.</p><p>This doesn&#39;t use the current linewidth setting (<code>setline()</code>), and defaults to 1, but you can specify another value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/arrows.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.background-Tuple{ColorTypes.Colorant}" href="#Luxor.background-Tuple{ColorTypes.Colorant}"><code>Luxor.background</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">background(color)</code></pre><p>Fill the canvas with a single color. Returns the (red, green, blue, alpha) values.</p><p>Examples:</p><pre><code class="nohighlight hljs">background(&quot;antiquewhite&quot;)
background(1, 0.0, 1.0)
background(1, 0.0, 1.0, .5)</code></pre><p>If Colors.jl is installed:</p><pre><code class="nohighlight hljs">background(RGB(0, 1, 0))
background(RGBA(0, 1, 0))
background(RGBA(0, 1, 0, .5))
background(Luv(20, -20, 30))</code></pre><p>If you don&#39;t specify a background color for a PNG drawing, the background will be transparent. You can set a partly or completely transparent background for PNG files by passing a color with an alpha value, such as this &#39;transparent black&#39;:</p><pre><code class="nohighlight hljs">background(RGBA(0, 0, 0, 0))</code></pre><p>or</p><pre><code class="nohighlight hljs">background(0, 0, 0, 0)</code></pre><p>Returns a tuple <code>(r, g, b, a)</code> of the color that was used to paint the background.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L69-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.barchart-Tuple{Any}" href="#Luxor.barchart-Tuple{Any}"><code>Luxor.barchart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">barchart(values;
        boundingbox = BoundingBox(O + (-250, -120), O + (250, 120)),
        bargap=10,
        margin = 5,
        border=false,
        labels=false,
        labelfunction = (values, i, lowpos, highpos, barwidth, scaledvalue) -&gt; begin
                label(string(values[i]), :n, highpos, offset=10)
          end,
        barfunction =  (values, i, lowpos, highpos, barwidth, scaledvalue) -&gt; begin
            @layer begin
                setline(barwidth)
                line(lowpos, highpos, :stroke)
            end
          end)</code></pre><p>Draw a barchart where each bar is the height of a value in the <code>values</code> array. The bars will be scaled to fit in a bounding box.</p><p>Text labels are drawn if the keyword <code>labels=true</code>.</p><p><strong>Extended help</strong></p><p>The function returns a vector of points; each is the bottom center of a bar.</p><p>Draw a Fibonacci sequence as a barchart:</p><pre><code class="nohighlight hljs">fib(n) = n &gt; 2 ? fib(n - 1) + fib(n - 2) : 1
fibs = fib.(1:15)
@draw begin
    fontsize(12)
    barchart(fibs, labels=true)
end</code></pre><p>To control the drawing of the text and bars, define functions that process the end points:</p><p><code>mybarfunction(values, i, lowpos, highpos, barwidth, scaledvalue)</code></p><p><code>mylabelfunction(values, i, lowpos, highpos, barwidth, scaledvalue)</code></p><p>and pass them like this:</p><pre><code class="language-julia hljs">barchart(vals, barfunction=mybarfunction)
barchart(vals, labelfunction=mylabelfunction)</code></pre><pre><code class="nohighlight hljs">function myprologfunction(values, basepoint, minbarrange, maxbarrange, barchartheight)
    @layer begin
        setline(0.2)
        for i in 0:10:maximum(values)
            rule(boxbottomcenter(basepoint) + (0, -(rescale(i, minbarrange, maxbarrange) * barchartheight)))
        end
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/bars.jl#L1-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.between" href="#Luxor.between"><code>Luxor.between</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">between(bb::BoundingBox, x)</code></pre><p>Find a point between the two corners of a BoundingBox corresponding to <code>x</code>, where <code>x</code> is typically between 0 and 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L390-L395">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.between-Tuple{Point, Point, Any}" href="#Luxor.between-Tuple{Point, Point, Any}"><code>Luxor.between</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">between(p1::Point, p2::Point, x)
between((p1::Point, p2::Point), x)</code></pre><p>Find the point between point <code>p1</code> and point <code>p2</code> for <code>x</code>, where <code>x</code> is typically between 0 and 1. <code>between(p1, p2, 0.5)</code> is equivalent to <code>midpoint(p1, p2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L169-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.bezier-Tuple{Any, Point, Point, Point, Point}" href="#Luxor.bezier-Tuple{Any, Point, Point, Point, Point}"><code>Luxor.bezier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bezier(t, A::Point, A1::Point, B1::Point, B::Point)</code></pre><p>Return the result of evaluating the Bézier cubic curve function, <code>t</code> going from 0 to 1, starting at A, finishing at B, control points A1 (controlling A), and B1 (controlling B).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/bezierpath.jl#L66-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.beziercurvature-Tuple{Any, Point, Point, Point, Point}" href="#Luxor.beziercurvature-Tuple{Any, Point, Point, Point, Point}"><code>Luxor.beziercurvature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">beziercurvature(t, A::Point, A1::Point, B1::Point, B::Point)</code></pre><p>Return the curvature of the Bézier curve at <code>t</code> ([0-1]), given start and end points A and B, and control points A1 and B1. The value (kappa) will typically be a value between -0.001 and 0.001 for points with coordinates in the 100-500 range.</p><p>κ(t) is the curvature of the curve at point t, which for a parametric planar curve is:</p><p class="math-container">\[\begin{equation}
\kappa = \frac{\mid \dot{x}\ddot{y}-\dot{y}\ddot{x}\mid}
    {(\dot{x}^2 + \dot{y}^2)^{\frac{3}{2}}}
\end{equation}\]</p><p>The radius of curvature, or the radius of an osculating circle at a point, is 1/κ(t). Values of 1/κ will typically be in the range -1000 to 1000 for points with coordinates in the 100-500 range.</p><p>TODO Fix overshoot...</p><p>...The value of kappa can sometimes collapse near 0, returning NaN (and Inf for radius of curvature).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/bezierpath.jl#L102-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.bezierfrompoints-NTuple{4, Point}" href="#Luxor.bezierfrompoints-NTuple{4, Point}"><code>Luxor.bezierfrompoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bezierfrompoints(startpoint::Point,
    pointonline1::Point,
    pointonline2::Point,
    endpoint::Point)</code></pre><p>Given four points, return the Bézier curve that passes through all four points, starting at <code>startpoint</code> and ending at <code>endpoint</code>. The two middle points of the returned BezierPathSegment are the two control points that make the curve pass through the two middle points supplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/bezierpath.jl#L441-L451">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.bezierfrompoints-Tuple{Vector{Point}}" href="#Luxor.bezierfrompoints-Tuple{Vector{Point}}"><code>Luxor.bezierfrompoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bezierfrompoints(ptslist::Array{Point, 1})</code></pre><p>Given four points, return the Bézier curve that passes through all four points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/bezierpath.jl#L468-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.bezierpathtopath-Tuple{BezierPath}" href="#Luxor.bezierpathtopath-Tuple{BezierPath}"><code>Luxor.bezierpathtopath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bezierpathtopath(bp::BezierPath)</code></pre><p>Convert a Bezier path to a Path object.</p><pre><code class="language-julia hljs">@draw drawpath(polytopath(ngon(O, 145, 5, vertices=true)), action=:fill)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Path.jl#L177-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.bezierpathtopoly-Tuple{BezierPath}" href="#Luxor.bezierpathtopoly-Tuple{BezierPath}"><code>Luxor.bezierpathtopoly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bezierpathtopoly(bezierpath::BezierPath;
    steps=10)</code></pre><p>Convert a Bézier path (an array of BezierPathSegments, where each is a tuple of four points: anchor1, control1, control2, anchor2), to a polygon.</p><p>To make a Bézier path, use <code>makebezierpath()</code> on a polygon.</p><p>The <code>steps</code> optional keyword determines how many straight line sections are used for each path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/bezierpath.jl#L306-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.beziersegmentangles-Tuple{Any, Any}" href="#Luxor.beziersegmentangles-Tuple{Any, Any}"><code>Luxor.beziersegmentangles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">beziersegmentangles(pt1, pt2;
    out = deg2rad(45),
    in  = deg2rad(135),
    l   = 100)</code></pre><p>Return a BezierPathSegment joining <code>pt1</code> and <code>pt2</code> making the angles <code>out</code> at the start and <code>in</code> at the end.</p><p>It&#39;s similar to the tikZ <code>(a) to [out=135, in=45] (b)</code> drawing instruction (but in radians obviously).</p><p><code>out</code> is the angle that a line from <code>pt1</code> to the outgoing Bézier handle makes with the horizontal. <code>in</code> is the angle that a line joining <code>pt2</code> from the preceding Bézier handle makes with the horizontal.</p><p>The function finds the interesction point of two lines with the two angles and constructs a BezierPathSegment that fits.</p><p>See also the <code>bezierfrompoints()</code> function that makes a BezierPathSegment that passes through four points.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">drawbezierpath(beziersegmentangles(O, O + (100, 0),
    out = deg2rad(45),
    in  = 2π - deg2rad(45)),
    :stroke)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/bezierpath.jl#L671-L703">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.bezierstroke" href="#Luxor.bezierstroke"><code>Luxor.bezierstroke</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bezierstroke(point1, point2, width=0.0)</code></pre><p>Return a BezierPath, a stroked version of a straight line between two points.</p><p>It wil have 2 or 6 Bezier path segments that define a brush or pen shape. If width is 0, the brush shape starts and ends at a point. Otherwise the brush shape starts and ends with the thick end.</p><p>To draw it, use eg <code>drawbezierpath(..., :fill)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/bezierpath.jl#L475-L485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.beziertopoly-Tuple{BezierPathSegment}" href="#Luxor.beziertopoly-Tuple{BezierPathSegment}"><code>Luxor.beziertopoly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">beziertopoly(bpseg::BezierPathSegment;
    steps=10)</code></pre><p>Convert a BezierPathsegment to a polygon (an array of points).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/bezierpath.jl#L252-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.bezier′-NTuple{5, Any}" href="#Luxor.bezier′-NTuple{5, Any}"><code>Luxor.bezier′</code></a> — <span class="docstring-category">Method</span></header><section><div><p>bezier′(t, A::Point, A1::Point, B1::Point, B::Point)</p><p>Return the first derivative of the Bézier function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/bezierpath.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.bezier′′-NTuple{5, Any}" href="#Luxor.bezier′′-NTuple{5, Any}"><code>Luxor.bezier′′</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bezier′′(t, A::Point, A1::Point, B1::Point, B::Point)</code></pre><p>Return the second derivative of Bézier function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/bezierpath.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.blend-Tuple{Point, Any, Point, Any, Any, Any}" href="#Luxor.blend-Tuple{Point, Any, Point, Any, Any, Any}"><code>Luxor.blend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">blend(centerpos1, rad1, centerpos2, rad2, color1, color2)</code></pre><p>Create a radial blend.</p><p>Example:</p><pre><code class="nohighlight hljs">redblue = blend(
    pos, 0,                   # first circle center and radius
    pos, tiles.tilewidth/2,   # second circle center and radius
    &quot;red&quot;,
    &quot;blue&quot;
    )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/blends.jl#L19-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.blend-Tuple{Point, Any, Point, Any}" href="#Luxor.blend-Tuple{Point, Any, Point, Any}"><code>Luxor.blend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">blend(from::Point, startradius, to::Point, endradius)</code></pre><p>Create an empty radial blend.</p><p>Radial blends are defined by two circles that define the start and stop locations. The first point is the center of the start circle, the first radius is the radius of the first circle.</p><p>A new blend is empty. To add colors, use <code>addstop()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/blends.jl#L56-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.blend-Tuple{Point, Point, Any, Any}" href="#Luxor.blend-Tuple{Point, Point, Any, Any}"><code>Luxor.blend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">blend(pt1::Point, pt2::Point, color1, color2)</code></pre><p>Create a linear blend.</p><p>Example:</p><pre><code class="nohighlight hljs">redblue = blend(pos, pos, &quot;red&quot;, &quot;blue&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/blends.jl#L40-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.blend-Tuple{Point, Point}" href="#Luxor.blend-Tuple{Point, Point}"><code>Luxor.blend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">blend(from::Point, to::Point)</code></pre><p>Create an empty linear blend.</p><p>A blend is a specification of how one color changes into another. Linear blends are defined by two points: parallel lines through these points define the start and stop locations of the blend. The blend is defined relative to the current axes origin. This means that you should be aware of the current axes when you define blends, and when you use them.</p><p>To add colors, use <code>addstop()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/blends.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.blendadjust" href="#Luxor.blendadjust"><code>Luxor.blendadjust</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">blendadjust(ablend, center::Point, xscale, yscale, rot=0)</code></pre><p>Modify an existing blend by scaling, translating, and rotating it so that it will fill a shape properly even if the position of the shape is nowhere near the original location of the blend&#39;s definition.</p><p>For example, if your blend definition was this (notice the <code>1</code>)</p><pre><code class="nohighlight hljs">blendgoldmagenta = blend(
        Point(0, 0), 0,                   # first circle center and radius
        Point(0, 0), 1,                   # second circle center and radius
        &quot;gold&quot;,
        &quot;magenta&quot;
        )</code></pre><p>you can use it in a shape that&#39;s 100 units across and centered at <code>pos</code>, by calling this:</p><pre><code class="nohighlight hljs">blendadjust(blendgoldmagenta, Point(pos.x, pos.y), 100, 100)</code></pre><p>then use <code>setblend()</code>:</p><pre><code class="nohighlight hljs">setblend(blendgoldmagenta)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/blends.jl#L121-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.blendmatrix-Tuple{Cairo.CairoPattern, Any}" href="#Luxor.blendmatrix-Tuple{Cairo.CairoPattern, Any}"><code>Luxor.blendmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">blendmatrix(b::Blend, m)</code></pre><p>Set the matrix of a blend.</p><p>To apply a sequence of matrix transforms to a blend:</p><pre><code class="nohighlight hljs">A = [1 0 0 1 0 0]
Aj = cairotojuliamatrix(A)
Sj = scalingmatrix(2, .2) * Aj
Tj = translationmatrix(10, 0) * Sj
A1 = juliatocairomatrix(Tj)
blendmatrix(b, As)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/blends.jl#L154-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boundingboxesintersect-NTuple{4, Point}" href="#Luxor.boundingboxesintersect-NTuple{4, Point}"><code>Luxor.boundingboxesintersect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundingboxesintersect(bbox1::BoundingBox, bbox2::BoundingBox)
boundingboxesintersect(acorner1::Point, acorner2::Point, bcorner1::Point, bcorner2::Point)</code></pre><p>Return true if the two bounding boxes intersect.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L325-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.box-Tuple{Array, Symbol}" href="#Luxor.box-Tuple{Array, Symbol}"><code>Luxor.box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">box(points::Array; action=:none,
    reversepath=reversepath,
    vertices=vertices)
box(points::Array; action=:none,
    reversepath=reversepath,
    vertices=vertices)</code></pre><p>Create a box/rectangle using the first two points of an array of Points to defined opposite corners, and add it to the current path. Then apply <code>action</code>.</p><p>Use <code>vertices=true</code> to return an array of the four corner points: bottom left, top left, top right, bottom right rather than execute action.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/shapes.jl#L133-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.box-Tuple{BoundingBox}" href="#Luxor.box-Tuple{BoundingBox}"><code>Luxor.box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">box(bbox::BoundingBox;
    action   = :none,
    vertices = false)
box(bbox::BoundingBox, action::Symbol;
    vertices=false)</code></pre><p>Define a box using the bounds in <code>bbox</code>.</p><p>Use <code>vertices = true</code> to return an array of the four corner points: bottom left, top left, top right, bottom right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L271-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.box-Tuple{BoxmapTile, Symbol}" href="#Luxor.box-Tuple{BoxmapTile, Symbol}"><code>Luxor.box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">box(tile::BoxmapTile, action::Symbol=:none; vertices=false)
box(tile::BoxmapTile, action=:none, vertices=false)</code></pre><p>Use a Boxmaptile to make or draw a rectangular box. Use <code>vertices=true</code> to obtain the coordinates.</p><p>Create boxmaps using <code>boxmap()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Boxmaptile.jl#L150-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.box-Tuple{Point, Any, Any, Array}" href="#Luxor.box-Tuple{Point, Any, Any, Array}"><code>Luxor.box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">box(pt, width, height, cornerradii::Array; action=:none)
box(pt, width, height, cornerradii::Array, action=:none)</code></pre><p>Draw a box/rectangle centered at point <code>pt</code> with <code>width</code> and <code>height</code> and round each corner by the corresponding value in the array <code>cornerradii</code>.</p><p>The constructed path consists of arcs and straight lines.</p><p>The first corner is the one at the bottom left, the second at the top left, and so on.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">@draw begin
    box(O, 120, 120, [0, 20, 40, 60], :fill)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/shapes.jl#L217-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.box-Tuple{Point, Any, Any, Real, Symbol}" href="#Luxor.box-Tuple{Point, Any, Any, Real, Symbol}"><code>Luxor.box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">box(pt, width, height, cornerradius, action=:none)
box(pt, width, height, cornerradius; action=:none)</code></pre><p>Draw a box/rectangle centered at point <code>pt</code> with <code>width</code> and <code>height</code> and round each corner by <code>cornerradius</code>.</p><p>The constructed path consists of arcs and straight lines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/shapes.jl#L202-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.box-Tuple{Point, Any, Any}" href="#Luxor.box-Tuple{Point, Any, Any}"><code>Luxor.box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">box(pt::Point, width, height; action=:none, vertices=false)
box(pt::Point, width, height, action=:none; vertices=false)</code></pre><p>Create a box/rectangle centered at point <code>pt</code> with width and height. Use <code>vertices=true</code> to return an array of the four corner points rather than apply the action.</p><p><code>reversepath</code> reverses the direction of the path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/shapes.jl#L155-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.box-Tuple{Point, Point}" href="#Luxor.box-Tuple{Point, Point}"><code>Luxor.box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">box(cornerpoint1, cornerpoint2; action=:none, vertices=false, reversepath=false)
box(cornerpoint1, cornerpoint2, action; vertices=false, reversepath=false)</code></pre><p>Create a box (rectangle) between two points and add it to the current path. Then apply <code>action</code>.</p><p>Use <code>vertices=true</code> to return an array of the four corner points: bottom left, top left, top right, bottom right rather than execute action.</p><p><code>reversepath</code> reverses the direction of the path (and returns points in the order: bottom left, bottom right, top right, top left).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/shapes.jl#L79-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.box-Tuple{Table, Int64, Symbol}" href="#Luxor.box-Tuple{Table, Int64, Symbol}"><code>Luxor.box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">box(t::Table, cellnumber::Int, action::Symbol=:none; vertices=false)
box(t::Table, cellnumber::Int; action=:none, vertices=false)</code></pre><p>Make box around cell <code>cellnumber</code> in table <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Table.jl#L269-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.box-Tuple{Table, Integer, Integer, Symbol}" href="#Luxor.box-Tuple{Table, Integer, Integer, Symbol}"><code>Luxor.box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">box(t::Table, r::Integer, c::Integer, action::Symbol)
box(t::Table, r::Integer, c::Integer; action=:none)</code></pre><p>Draw a box in table <code>t</code> at row <code>r</code> and column <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Table.jl#L255-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.box-Tuple{Tiler, Integer}" href="#Luxor.box-Tuple{Tiler, Integer}"><code>Luxor.box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">box(tiles::Tiler, n::Integer; action=:none, vertices=false, reversepath=false)
box(tiles::Tiler, n::Integer, action::Symbol=:none; vertices=false, reversepath=false)</code></pre><p>Draw a box in tile <code>n</code> of tiles <code>tiles</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/tiles-grids.jl#L350-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxaspectratio" href="#Luxor.boxaspectratio"><code>Luxor.boxaspectratio</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boxaspectratio(bb::BoundingBox=BoundingBox())</code></pre><p>Return the aspect ratio (the height divided by the width) of bounding box <code>bb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L248-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxbottomcenter" href="#Luxor.boxbottomcenter"><code>Luxor.boxbottomcenter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boxbottomcenter(bb::BoundingBox=BoundingBox())</code></pre><p>Return the point at the bottom center of the BoundingBox <code>bb</code>, defaulting to the drawing extent.</p><pre><code class="nohighlight hljs">⋅ ⋅ ⋅
⋅ ⋅ ⋅
⋅ ■ ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L499-L509">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxbottomleft" href="#Luxor.boxbottomleft"><code>Luxor.boxbottomleft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boxbottomleft(bb::BoundingBox=BoundingBox())</code></pre><p>Return the point at the bottom left of the BoundingBox <code>bb</code>, defaulting to the drawing extent.</p><pre><code class="nohighlight hljs">⋅ ⋅ ⋅
⋅ ⋅ ⋅
■ ⋅ ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L485-L495">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxbottomright" href="#Luxor.boxbottomright"><code>Luxor.boxbottomright</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boxbottomright(bb::BoundingBox=BoundingBox())</code></pre><p>Return the point at the bottom right of the BoundingBox <code>bb</code>, defaulting to the drawing extent.</p><pre><code class="nohighlight hljs">⋅ ⋅ ⋅
⋅ ⋅ ⋅
⋅ ⋅ ■</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L514-L524">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxdiagonal" href="#Luxor.boxdiagonal"><code>Luxor.boxdiagonal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boxdiagonal(bb::BoundingBox=BoundingBox())</code></pre><p>Return the length of the diagonal of bounding box <code>bb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L240-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxheight" href="#Luxor.boxheight"><code>Luxor.boxheight</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boxheight(bb::BoundingBox=BoundingBox())</code></pre><p>Return the height of bounding box <code>bb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L232-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxmap-Tuple{Array, Point, Any, Any}" href="#Luxor.boxmap-Tuple{Array, Point, Any, Any}"><code>Luxor.boxmap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boxmap(A::Array, pt, w, h)</code></pre><p>Build a box map of the values in <code>A</code> with one corner at <code>pt</code> and width <code>w</code> and height <code>h</code>. There are <code>length(A)</code> boxes. The areas of the boxes are proportional to the original values, scaled as necessary.</p><p>The return value is an array of BoxmapTiles. For example:</p><pre><code class="nohighlight hljs">[BoxmapTile(0.0, 0.0, 10.0, 20.0)
 BoxmapTile(10.0, 0.0, 10.0, 13.3333)
 BoxmapTile(10.0, 13.3333, 10.0, 6.66667)]</code></pre><p>with each tile containing <code>(x, y, w, h)</code>. <code>box()</code> and <code>BoundingBox()</code> can work with BoxmapTiles as well.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">using Luxor
@svg begin
    fontsize(16)
    fontface(&quot;HelveticaBold&quot;)
    pt = Point(-200, -200)
    a = rand(10:200, 15)
    tiles = boxmap(a, Point(-200, -200), 400, 400)
    for (n, t) in enumerate(tiles)
        randomhue()
        bb = BoundingBox(t)
        box(bb - 2, :stroke)
        box(bb - 5, :fill)
        sethue(&quot;white&quot;)
        text(string(n), midpoint(bb[1], bb[2]), halign=:center)
    end
end 400 400 &quot;boxmap.svg&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Boxmaptile.jl#L100-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxmiddlecenter" href="#Luxor.boxmiddlecenter"><code>Luxor.boxmiddlecenter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boxmiddlecenter(bb::BoundingBox=BoundingBox())</code></pre><p>Return the point at the center of the BoundingBox <code>bb</code>, defaulting to the drawing extent.</p><pre><code class="nohighlight hljs">⋅ ⋅ ⋅
⋅ ■ ⋅
⋅ ⋅ ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L457-L467">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxmiddleleft" href="#Luxor.boxmiddleleft"><code>Luxor.boxmiddleleft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boxmiddleleft(bb::BoundingBox=BoundingBox())</code></pre><p>Return the point at the middle left of the BoundingBox <code>bb</code>, defaulting to the drawing extent.</p><pre><code class="nohighlight hljs">⋅ ⋅ ⋅
■ ⋅ ⋅
⋅ ⋅ ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L442-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxmiddleright" href="#Luxor.boxmiddleright"><code>Luxor.boxmiddleright</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boxmiddleright(bb::BoundingBox=BoundingBox())</code></pre><p>Return the point at the midde right of the BoundingBox <code>bb</code>, defaulting to the drawing extent.</p><pre><code class="nohighlight hljs">⋅ ⋅ ⋅
⋅ ⋅ ■
⋅ ⋅ ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L471-L481">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxtopcenter" href="#Luxor.boxtopcenter"><code>Luxor.boxtopcenter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boxtopcenter(bb::BoundingBox=BoundingBox())</code></pre><p>Return the point at the top center of the BoundingBox <code>bb</code>, defaulting to the drawing extent.</p><pre><code class="nohighlight hljs">⋅ ■ ⋅
⋅ ⋅ ⋅
⋅ ⋅ ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L412-L423">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxtopleft" href="#Luxor.boxtopleft"><code>Luxor.boxtopleft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boxtopleft(bb::BoundingBox=BoundingBox())</code></pre><p>Return the point at the top left of the BoundingBox <code>bb</code>, defaulting to the drawing extent.</p><pre><code class="nohighlight hljs">■ ⋅ ⋅
⋅ ⋅ ⋅
⋅ ⋅ ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L398-L409">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxtopright" href="#Luxor.boxtopright"><code>Luxor.boxtopright</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boxtopright(bb::BoundingBox=BoundingBox())</code></pre><p>Return the point at the top right of the BoundingBox <code>bb</code>, defaulting to the drawing extent.</p><pre><code class="nohighlight hljs">⋅ ⋅ ■
⋅ ⋅ ⋅
⋅ ⋅ ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L427-L438">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxwidth" href="#Luxor.boxwidth"><code>Luxor.boxwidth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boxwidth(bb::BoundingBox=BoundingBox())</code></pre><p>Return the width of bounding box <code>bb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L224-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.brush" href="#Luxor.brush"><code>Luxor.brush</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">brush(pt1, pt2, width=10;
    strokes=10,
    minwidth=0.01,
    maxwidth=0.03,
    twist = -1,
    lowhandle  = 0.3,
    highhandle = 0.7,
    randomopacity = true,
    tidystart = false,
    action = :fill,
    strokefunction = (nbpb) -&gt; nbpb))</code></pre><p>Draw a composite brush stroke made up of some randomized individual filled Bezier paths.</p><p><code>strokefunction</code> allows a function to process a BezierPathSegment or do other things before it&#39;s drawn.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>There is a lot of randomness in this function. Results are unpredictable.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/bezierpath.jl#L608-L629">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.buildcolumn-NTuple{5, Any}" href="#Luxor.buildcolumn-NTuple{5, Any}"><code>Luxor.buildcolumn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">buildcolumn(A, x, y, w, h)</code></pre><p>Make a column of tiles from A.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Boxmaptile.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.buildrow-NTuple{5, Any}" href="#Luxor.buildrow-NTuple{5, Any}"><code>Luxor.buildrow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">buildrow(A, x, y, w, h)</code></pre><p>Make a row of tiles from A.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Boxmaptile.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.cairotojuliamatrix-Tuple{Array}" href="#Luxor.cairotojuliamatrix-Tuple{Array}"><code>Luxor.cairotojuliamatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cairotojuliamatrix(c)</code></pre><p>Return a 3x3 Julia matrix that&#39;s the equivalent of the six-element matrix in <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/matrix.jl#L154-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.carc-Tuple{Point, Any, Any, Any}" href="#Luxor.carc-Tuple{Point, Any, Any, Any}"><code>Luxor.carc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">carc(centerpoint::Point, radius, angle1, angle2; action=:none)
carc(centerpoint::Point, radius, angle1, angle2, action)</code></pre><p>Add an arc centered at <code>centerpoint</code> to the current path from <code>angle1</code> to <code>angle2</code>, going counterclockwise.</p><p>Angles are defined relative to the x-axis, positive clockwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L206-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.carc2r-Tuple{Point, Point, Point}" href="#Luxor.carc2r-Tuple{Point, Point, Point}"><code>Luxor.carc2r</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">carc2r(c1::Point, p2::Point, p3::Point; action=:none)</code></pre><p>Add a circular arc centered at <code>c1</code> that starts at <code>p2</code> and ends at <code>p3</code>, going counterclockwise, to the current path.</p><p><code>c1</code>-<code>p2</code> really determines the radius. If <code>p3</code> doesn&#39;t lie on the circular path, it will be used only as an indication of the arc&#39;s length, rather than its position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L247-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.carc2sagitta-Tuple{Point, Point, Real}" href="#Luxor.carc2sagitta-Tuple{Point, Point, Real}"><code>Luxor.carc2sagitta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">carc2sagitta(p1::Point, p2::Point, s;
    action=:none)</code></pre><p>Make a counterclockwise arc starting at <code>p1</code> and ending at <code>p2</code> that reaches a height of <code>s</code>, the sagitta, at the middle, and add it to the current path.</p><p>Return tuple of center point and radius of arc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L1052-L1061">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.center3pts-Tuple{Point, Point, Point}" href="#Luxor.center3pts-Tuple{Point, Point, Point}"><code>Luxor.center3pts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">center3pts(a::Point, b::Point, c::Point)</code></pre><p>Find the radius and center point for three points lying on a circle.</p><p>returns <code>(centerpoint, radius)</code> of a circle.</p><p>If there&#39;s no such circle, the function returns <code>(Point(0, 0), 0)</code>.</p><p>If two of the points are the same, use <code>circle(pt1, pt2)</code> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L63-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.circle-Tuple{Point, Point, Point}" href="#Luxor.circle-Tuple{Point, Point, Point}"><code>Luxor.circle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">circle(pt1::Point, pt2::Point, pt3::Point; action=:none)
circle(pt1::Point, pt2::Point, pt3::Point, action)</code></pre><p>Make a circle that passes through three points, and add it to the current path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.circle-Tuple{Point, Point}" href="#Luxor.circle-Tuple{Point, Point}"><code>Luxor.circle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">circle(pt1::Point, pt2::Point; action=:none)
circle(pt1::Point, pt2::Point, action)</code></pre><p>Make a circle that passes through two points that define the diameter, and add it to the current path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.circle-Tuple{Point, Real}" href="#Luxor.circle-Tuple{Point, Real}"><code>Luxor.circle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">circle(centerpoint::Point, r; action=:none)
circle(centerpoint::Point, r, action)</code></pre><p>Make a circle of radius <code>r</code> centered at &#39;centerpoint&#39;, and add it to the current path.</p><p><code>action</code> is one of the actions applied by <code>do_action</code>, defaulting to <code>:none</code>.</p><p>Returns a tuple of two points, the corners of a bounding box that encloses the circle.</p><p>You can also use <code>ellipse()</code> to draw circles and place them by their centerpoint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L13-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.circlecircleinnertangents-Tuple{Point, Any, Point, Any}" href="#Luxor.circlecircleinnertangents-Tuple{Point, Any, Point, Any}"><code>Luxor.circlecircleinnertangents</code></a> — <span class="docstring-category">Method</span></header><section><div><p>circlecircleinnertangents(circle1center::Point, circle1radius, circle2center::Point, circle2radius)</p><p>Find the inner tangents of two circles. These are tangent lines that cross as they skim past one circle and touch the other.</p><p>Returns the four points: tangentpoint1 on circle 1, tangentpoint1 on circle2, tangentpoint2 on circle 1, tangentpoint2 on circle2.</p><p>Returns <code>(O, O, O, O)</code> if inner tangents can&#39;t be found (eg when the circles overlap).</p><p>Use <code>circlecircleoutertangents()</code> to find the outer tangents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L1155-L1168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.circlecircleoutertangents-Tuple{Point, Any, Point, Any}" href="#Luxor.circlecircleoutertangents-Tuple{Point, Any, Point, Any}"><code>Luxor.circlecircleoutertangents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">circlecircleoutertangents(cpt1::Point, r1, cpt2::Point, r2)</code></pre><p>Return four points, <code>p1</code>, <code>p2,</code>p3<code>,</code>p4<code>, where a line through</code>p1<code>and</code>p2<code>, and a line through</code>p3<code>and</code>p4<code>, form the outer tangents to the circles defined by</code>cpt1/r1<code>and</code>cpt2/r2`.</p><p>Returns four identical points (<code>O</code>) if one of the circles lies inside the other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L1086-L1094">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.circlepath-Tuple{Point, Any}" href="#Luxor.circlepath-Tuple{Point, Any}"><code>Luxor.circlepath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">circlepath(center::Point, radius;
    action=:none,
    reversepath=false,
    kappa = 0.5522847498307936)
circlepath(center::Point, radius, action;
    reversepath=false,
    kappa = 0.5522847498307936)</code></pre><p>Make a circle using Bézier curves, and add it to the current path.</p><p>One benefit of using this rather than <code>circle()</code> is that you can use the <code>reversepath</code> option to draw the circle clockwise rather than <code>circle</code>&#39;s counterclockwise.</p><p>The magic value, <code>kappa</code>, is <code>4.0 * (sqrt(2.0) - 1.0) / 3.0</code>.</p><p>Return two points, the corners of a bounding box.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L485-L504">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.circlepointtangent-Tuple{Point, Any, Point, Any}" href="#Luxor.circlepointtangent-Tuple{Point, Any, Point, Any}"><code>Luxor.circlepointtangent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">circlepointtangent(through::Point, radius, targetcenter::Point, targetradius)</code></pre><p>Find the centers of up to two circles of radius <code>radius</code> that pass through point <code>through</code> and are tangential to a circle that has radius <code>targetradius</code> and center <code>targetcenter</code>.</p><p>This function returns a tuple:</p><ul><li><p>(0, O, O)      - no circles exist</p></li><li><p>(1, pt1, O)    - 1 circle exists, centered at pt1</p></li><li><p>(2, pt1, pt2)  - 2 circles exist, with centers at pt1 and pt2</p></li></ul><p>(The O are just dummy points so that three values are always returned.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L946-L962">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.circletangent2circles-Tuple{Any, Point, Any, Point, Any}" href="#Luxor.circletangent2circles-Tuple{Any, Point, Any, Point, Any}"><code>Luxor.circletangent2circles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">circletangent2circles(radius, circle1center::Point, circle1radius, circle2center::Point, circle2radius)</code></pre><p>Find the centers of up to two circles of radius <code>radius</code> that are tangent to the two circles defined by <code>circle1...</code> and <code>circle2...</code>. These two circles can overlap, but one can&#39;t be inside the other.</p><ul><li><p>(0, O, O)      - no such circles exist</p></li><li><p>(1, pt1, O)    - 1 circle exists, centered at pt1</p></li><li><p>(2, pt1, pt2)  - 2 circles exist, with centers at pt1 and pt2</p></li></ul><p>(The O are just dummy points so that three values are always returned.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L997-L1011">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.clip-Tuple{}" href="#Luxor.clip-Tuple{}"><code>Luxor.clip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clip()</code></pre><p>Establish a new clipping region by intersecting the current clipping region with the current path and then clearing the current path.</p><p>An existing clipping region is enforced through and after a <code>gsave()</code>-<code>grestore()</code> block, but a clipping region set inside a <code>gsave()</code>-<code>grestore()</code> block is lost after <code>grestore()</code>. [?]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L230-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.clippreserve-Tuple{}" href="#Luxor.clippreserve-Tuple{}"><code>Luxor.clippreserve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clippreserve()</code></pre><p>Establish a new clipping region by intersecting the current clipping region with the current path, but keep the current path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L241-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.clipreset-Tuple{}" href="#Luxor.clipreset-Tuple{}"><code>Luxor.clipreset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clipreset()</code></pre><p>Reset the clipping region to the current drawing&#39;s extent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L249-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.closepath-Tuple{}" href="#Luxor.closepath-Tuple{}"><code>Luxor.closepath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">closepath()</code></pre><p>Close the current path. This is Cairo&#39;s <code>close_path()</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L150-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.crescent-Tuple{Point, Real, Point, Real}" href="#Luxor.crescent-Tuple{Point, Real, Point, Real}"><code>Luxor.crescent</code></a> — <span class="docstring-category">Method</span></header><section><div><p>crescent(cp1, r1, cp2, r2;             action=nothing,             vertices=false,             reversepath=false)</p><p>Create a crescent-shaped polygon, aligned with the current x-axis, by finding the intersection of two circles, and add it to the current path. The two center positions should be different.</p><p>See also <code>crescent(point, innerradius, outeradius...)</code>.</p><p><strong>Examples</strong></p><p>Create a filled crescent shape from two circles.</p><pre><code class="nohighlight hljs">crescent(O, 100, O + (60, 0), 150, :fill) # or
crescent(O, 100, O + (60, 0), 150, action=:fill)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L1344-L1365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.crescent-Tuple{Point, Real, Real}" href="#Luxor.crescent-Tuple{Point, Real, Real}"><code>Luxor.crescent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">crescent(pos, innerradius, outeradius;
    action=nothing,
    vertices=false,
    reversepath=false,
    steps = 30)</code></pre><p>Create a crescent-shaped polygon, aligned with the current x-axis, and add it to the current path. If the inner radius is 0, you&#39;ll get a semicircle.</p><p>See also <code>crescent(pos1, innerradius, pos2, outeradius...)</code>.</p><p><strong>Examples</strong></p><p>Create a filled crescent shape with outer radius of 200, inner radius of 130.</p><pre><code class="nohighlight hljs">crescent(O, 130, 200, :fill) # or
crescent(O, 130, 200, action=:fill)</code></pre><p>Create a stroked crescent shape - the inner radius of 0 produces a semicircle - and add it to the current path.</p><pre><code class="nohighlight hljs">crescent(O, 0, 200, :stroke) # or
crescent(O, 0, 200, action=:stroke)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L1283-L1311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.cropmarks-Tuple{Any, Any, Any}" href="#Luxor.cropmarks-Tuple{Any, Any, Any}"><code>Luxor.cropmarks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cropmarks(center, width, height)</code></pre><p>Draw cropmarks (also known as trim marks). Use current color.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/shapes.jl#L470-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.crossproduct-Tuple{Point, Point}" href="#Luxor.crossproduct-Tuple{Point, Point}"><code>Luxor.crossproduct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">crossproduct(p1::Point, p2::Point)</code></pre><p>This is the <em>perp dot product</em>, really, not the crossproduct proper (which is 3D):</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L242-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.currentdrawing-Tuple{}" href="#Luxor.currentdrawing-Tuple{}"><code>Luxor.currentdrawing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">currentdrawing()</code></pre><p>Return the current Luxor drawing, if there currently is one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/drawings.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.currentpoint-Tuple{}" href="#Luxor.currentpoint-Tuple{}"><code>Luxor.currentpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">currentpoint()</code></pre><p>Return the current point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L516-L520">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.curve-NTuple{6, Any}" href="#Luxor.curve-NTuple{6, Any}"><code>Luxor.curve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">curve(x1, y1, x2, y2, x3, y3)
curve(p1, p2, p3)</code></pre><p>Add a Bézier curve to the current path..</p><p>The spline starts at the current position, finishing at <code>x3/y3</code> (<code>p3</code>), following two control points <code>x1/y1</code> (<code>p1</code>) and <code>x2/y2</code> (<code>p2</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L473-L481">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.determinant3-Tuple{Point, Point, Point}" href="#Luxor.determinant3-Tuple{Point, Point, Point}"><code>Luxor.determinant3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">determinant3(p1::Point, p2::Point, p3::Point)</code></pre><p>Find the determinant of the 3×3 matrix:</p><p class="math-container">\[\begin{bmatrix}
p1.x &amp; p1.y &amp; 1 \\
p2.x &amp; p2.y &amp; 1 \\
p3.x &amp; p3.y &amp; 1  \\
\end{bmatrix}\]</p><p>If the value is 0.0, the points are collinear.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L68-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.dimension-Tuple{Point, Point}" href="#Luxor.dimension-Tuple{Point, Point}"><code>Luxor.dimension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dimension(p1::Point, p2::Point;
    format::Function   = (d) -&gt; string(d), # process the measured value into a string
    offset             = 0.0,              # left/right, parallel with x axis
    fromextension      = (10.0, 10.0),     # length of extensions lines left and right
    toextension        = (10.0, 10.0),     #
    textverticaloffset = 0.0,              # range 1.0 (top) to -1.0 (bottom)
    texthorizontaloffset = 0.0,            # range 1.0 (top) to -1.0 (bottom)
    textgap            = 5,                # gap between start of each arrow (≈ fontsize?)
    textrotation       = 0.0,
    arrowlinewidth     = 1.0,
    arrowheadlength    = 10,
    arrowheadangle     = π/8)</code></pre><p>Calculate and draw dimensioning graphics for the distance between <code>p1</code> and <code>p2</code>. The value can be formatted with function <code>format</code>.</p><p><code>p1</code> is the lower on the page (ie probably the higher y value) point, <code>p2</code> is the higher on the page (ie probably lower y) point.</p><p><code>offset</code> is to the left (-x) when negative.</p><p>Dimension graphics will be rotated to align with a line between <code>p1</code> and <code>p2</code>.</p><p>In <code>textverticaloffset</code>, &quot;vertical&quot; and &quot;horizontal&quot; are best understood by &quot;looking&quot; along the line from the first point to the second. <code>textverticaloffset</code> ranges from -1 to 1, <code>texthorizontaloffset</code> in default units.</p><pre><code class="nohighlight hljs">        toextension
        [5  ,  5]
       &lt;---&gt; &lt;---&gt;
                             to
       -----------            +
            ^
            |

           -50

            |
            v
       ----------            +
                            from
       &lt;---&gt; &lt;---&gt;
         [5 , 5]
       fromextension

            &lt;----------------&gt;
                  offset</code></pre><p>Returns the measured distance and the text.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/arrows.jl#L477-L528">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.distance-Tuple{Point, Point}" href="#Luxor.distance-Tuple{Point, Point}"><code>Luxor.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distance(p1::Point, p2::Point)</code></pre><p>Find the distance between two points (two argument form).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.do_action-Tuple{Any}" href="#Luxor.do_action-Tuple{Any}"><code>Luxor.do_action</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">do_action(action)</code></pre><p>This is usually called by other graphics functions. Actions for graphics commands include <code>:fill</code>, <code>:stroke</code>, <code>:clip</code>, <code>:fillstroke</code>, <code>:fillpreserve</code>, and <code>:strokepreserve</code>.</p><p>The <code>:path</code> action adds the graphics to the current path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L204-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.dotproduct-Tuple{Point, Point}" href="#Luxor.dotproduct-Tuple{Point, Point}"><code>Luxor.dotproduct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dotproduct(a::Point, b::Point)</code></pre><p>Return the scalar dot product of the two points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.douglas_peucker-Tuple{Vector{Point}, Any, Any, Any}" href="#Luxor.douglas_peucker-Tuple{Vector{Point}, Any, Any, Any}"><code>Luxor.douglas_peucker</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Use a non-recursive Douglas-Peucker algorithm to simplify a polygon. Used by <code>simplify()</code>.</p><pre><code class="nohighlight hljs">douglas_peucker(pointlist::Array, start_index, last_index, epsilon)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L132-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.drawbezierpath" href="#Luxor.drawbezierpath"><code>Luxor.drawbezierpath</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">drawbezierpath(bps::BezierPathSegment, action=:none;
    close=false)</code></pre><p>Draw the Bézier path segment, and apply the action, such as <code>:none</code>, <code>:stroke</code>, <code>:fill</code>, etc. By default the path is open.</p><p>TODO Return something more useful than a Boolean.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/bezierpath.jl#L230-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.drawbezierpath-Tuple{BezierPath, Any}" href="#Luxor.drawbezierpath-Tuple{BezierPath, Any}"><code>Luxor.drawbezierpath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">drawbezierpath(bezierpath::BezierPath, action=:none;
    close=true)
drawbezierpath(bezierpath::BezierPath;
    action=:none,
    close=true)</code></pre><p>Draw the Bézier path, and apply the action, such as <code>:none</code>, <code>:stroke</code>, <code>:fill</code>, etc. By default the path is closed.</p><p>TODO Return something more useful than a Boolean.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/bezierpath.jl#L201-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.drawpath-Tuple{Path, Real}" href="#Luxor.drawpath-Tuple{Path, Real}"><code>Luxor.drawpath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">drawpath(path::Path, k::Real;
    steps=10, # used when approximating Bezier curve segments
    action=:none,
    startnewpath=true,
    pathlength = 0.0)</code></pre><p>Draw the path in <code>path</code> starting at the beginning and stopping at <code>k</code> between 0 and 1. So if <code>k</code> is 0.5, half the path is drawn.</p><p>Returns the last point processed.</p><p>The function calculates the length of the entire path before drawing it. If you want to draw a large path more than once, it might be more efficient to calculate the length of the path first, and provide it to the <code>pathlength</code> keyword.</p><p>The <code>steps</code> parameter is used when approximating the length of any curve (Bezier) sections.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Path.jl#L299-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.drawpath-Tuple{Path}" href="#Luxor.drawpath-Tuple{Path}"><code>Luxor.drawpath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">drawpath(cp::Path; action=:none, startnewpath=true)
drawpath(cp::Path, action; startnewpath=true)</code></pre><p>Make the Luxor path stored in <code>cp</code> and apply the <code>action</code>.</p><p>To make paths, follow some path construction functions such as <code>move()</code>, <code>line()</code>, and <code>curve()</code> with the <code>storepath()</code> function.</p><p>By default, <code>startnewpath=true</code>, which starts a new path, discarding any existing path contents.</p><p>TODO Return something more useful than a Boolean!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Path.jl#L134-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeincirc-NTuple{4, Any}" href="#Luxor.easeincirc-NTuple{4, Any}"><code>Luxor.easeincirc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">easeincirc(t, b, c, d)</code></pre><p>circular easing in - accelerating from zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L507-L511">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeincubic-NTuple{4, Any}" href="#Luxor.easeincubic-NTuple{4, Any}"><code>Luxor.easeincubic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">easeincubic(t, b, c, d)</code></pre><p>cubic easing in - accelerating from zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L339-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinexpo-NTuple{4, Any}" href="#Luxor.easeinexpo-NTuple{4, Any}"><code>Luxor.easeinexpo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">easeinexpo(t, b, c, d)</code></pre><p>exponential easing in - accelerating from zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L471-L475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinoutbezier" href="#Luxor.easeinoutbezier"><code>Luxor.easeinoutbezier</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">easeinoutbezier(t, b, c, d, cpt1, cpt2)</code></pre><p>This easing function takes six arguments, the usual <code>t</code>, <code>b</code>, <code>c</code>, and <code>d</code>, but also two points. These are the normalized control points of a Bezier curve drawn between <code>Point(0, 0)</code> to <code>Point(1.0, 1.0)</code>. The <code>y</code> value of the Bezier is the eased value for <code>t</code>.</p><p>In your <code>frame()</code> generating function, if a Scene specifies the <code>easeinoutbezier</code> easing function, you can use this:</p><pre><code class="nohighlight hljs">...
lineareasing = rescale(framenumber, 1, scene.framerange.stop)
beziereasing = scene.easingfunction(lineareasing, 0, 1, 1,
    Point(0.25, 0.25), Point(0.75, 0.75))
...</code></pre><p>These two control points lie on the line between <code>0/0</code> and <code>1/1</code>, so it&#39;s equivalent to a linear easing (<code>lineartween()</code> or <code>easingflat</code>).</p><p>However, in the next example, the two control points define a wave-like curve that changes direction before changing back. When animating with this easing function, an object will &#39;go retrograde&#39; for a while.</p><pre><code class="nohighlight hljs">lineareasing = rescale(framenumber, 1, scene.framerange.stop)
beziereasing = scene.easingfunction(lineareasing, 0, 1, 1,
    Point(0.01, 1.99), Point(0.99, -1.5))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L556-L586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinoutcirc-NTuple{4, Any}" href="#Luxor.easeinoutcirc-NTuple{4, Any}"><code>Luxor.easeinoutcirc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">easeinoutcirc(t, b, c, d)</code></pre><p>circular easing in/out - acceleration until halfway, then deceleration</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L528-L532">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinoutcubic-NTuple{4, Any}" href="#Luxor.easeinoutcubic-NTuple{4, Any}"><code>Luxor.easeinoutcubic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">easeinoutcubic(t, b, c, d)</code></pre><p>cubic easing in/out - acceleration until halfway, then deceleration</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L360-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinoutexpo-NTuple{4, Any}" href="#Luxor.easeinoutexpo-NTuple{4, Any}"><code>Luxor.easeinoutexpo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">easeinoutexpo(t, b, c, d)</code></pre><p>exponential easing in/out - accelerating until halfway, then decelerating</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L493-L497">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinoutinversequad-NTuple{4, Any}" href="#Luxor.easeinoutinversequad-NTuple{4, Any}"><code>Luxor.easeinoutinversequad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">easeinoutinversequad(t, b, c, d)</code></pre><p>ease in, then slow down, then speed up, and ease out</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L542-L546">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinoutquad-NTuple{4, Any}" href="#Luxor.easeinoutquad-NTuple{4, Any}"><code>Luxor.easeinoutquad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">easeinoutquad(t, b, c, d)</code></pre><p>quadratic easing in/out - acceleration until halfway, then deceleration</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L325-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinoutquart-NTuple{4, Any}" href="#Luxor.easeinoutquart-NTuple{4, Any}"><code>Luxor.easeinoutquart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">easeinoutquart(t, b, c, d)</code></pre><p>quartic easing in/out - acceleration until halfway, then deceleration</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L395-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinoutquint-NTuple{4, Any}" href="#Luxor.easeinoutquint-NTuple{4, Any}"><code>Luxor.easeinoutquint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">easeinoutquint(t, b, c, d)</code></pre><p>quintic easing in/out - acceleration until halfway, then deceleration</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L430-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinoutsine-NTuple{4, Any}" href="#Luxor.easeinoutsine-NTuple{4, Any}"><code>Luxor.easeinoutsine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">easeinoutsine(t, b, c, d)</code></pre><p>sinusoidal easing in/out - accelerating until halfway, then decelerating</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L462-L466">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinquad-NTuple{4, Any}" href="#Luxor.easeinquad-NTuple{4, Any}"><code>Luxor.easeinquad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">easeinquad(t, b, c, d)</code></pre><p>quadratic easing in - accelerating from zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L305-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinquart-NTuple{4, Any}" href="#Luxor.easeinquart-NTuple{4, Any}"><code>Luxor.easeinquart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">easeinquart(t, b, c, d)</code></pre><p>quartic easing in - accelerating from zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L374-L378">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinquint-NTuple{4, Any}" href="#Luxor.easeinquint-NTuple{4, Any}"><code>Luxor.easeinquint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">easeinquint(t, b, c, d)</code></pre><p>quintic easing in - accelerating from zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L409-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinsine-NTuple{4, Any}" href="#Luxor.easeinsine-NTuple{4, Any}"><code>Luxor.easeinsine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">easeinsine(t, b, c, d)</code></pre><p>sinusoidal easing in - accelerating from zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L444-L448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeoutcirc-NTuple{4, Any}" href="#Luxor.easeoutcirc-NTuple{4, Any}"><code>Luxor.easeoutcirc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">easeoutcirc(t, b, c, d)</code></pre><p>circular easing out - decelerating to zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L517-L521">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeoutcubic-NTuple{4, Any}" href="#Luxor.easeoutcubic-NTuple{4, Any}"><code>Luxor.easeoutcubic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">easeoutcubic(t, b, c, d)</code></pre><p>cubic easing out - decelerating to zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L349-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeoutexpo-NTuple{4, Any}" href="#Luxor.easeoutexpo-NTuple{4, Any}"><code>Luxor.easeoutexpo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">easeoutexpo(t, b, c, d)</code></pre><p>exponential easing out - decelerating to zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L484-L488">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeoutquad-NTuple{4, Any}" href="#Luxor.easeoutquad-NTuple{4, Any}"><code>Luxor.easeoutquad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">easeoutquad(t, b, c, d)</code></pre><p>quadratic easing out - decelerating to zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L315-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeoutquart-NTuple{4, Any}" href="#Luxor.easeoutquart-NTuple{4, Any}"><code>Luxor.easeoutquart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">easeoutquart(t, b, c, d)</code></pre><p>quartic easing out - decelerating to zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L384-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeoutquint-NTuple{4, Any}" href="#Luxor.easeoutquint-NTuple{4, Any}"><code>Luxor.easeoutquint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">easeoutquint(t, b, c, d)</code></pre><p>quintic easing out - decelerating to zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L419-L423">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeoutsine-NTuple{4, Any}" href="#Luxor.easeoutsine-NTuple{4, Any}"><code>Luxor.easeoutsine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">easeoutsine(t, b, c, d)</code></pre><p>sinusoidal easing out - decelerating to zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L453-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easingflat-NTuple{4, Any}" href="#Luxor.easingflat-NTuple{4, Any}"><code>Luxor.easingflat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">easingflat(t, b, c, d)</code></pre><p>A flat easing function, same as <code>lineartween()</code>.</p><p>For all easing functions, the four parameters are:</p><ul><li><code>t</code> time, ie the current framenumber</li><li><code>b</code> beginning position or bottom value of the range</li><li><code>c</code> total change in position or top value of the range</li><li><code>d</code> duration, ie a framecount</li></ul><ol><li><code>t/d</code> or <code>t/=d</code> normalizes <code>t</code> to between 0 and 1</li><li><code>... * c</code> scales up to the required range value</li><li><code>... + b</code> adds the initial offset</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L284-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.ellipse-Tuple{Point, Point, Any}" href="#Luxor.ellipse-Tuple{Point, Point, Any}"><code>Luxor.ellipse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ellipse(focus1::Point, focus2::Point, k;
        action=:none,
        stepvalue=pi/100,
        vertices=false,
        reversepath=false)</code></pre><p>Build a polygon approximation to an ellipse, given two points and a distance, <code>k</code>, which is the sum of the distances to the focii of any points on the ellipse (or the shortest length of string required to go from one focus to the perimeter and on to the other focus), and add it to the current path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L570-L583">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.ellipse-Tuple{Point, Point, Point}" href="#Luxor.ellipse-Tuple{Point, Point, Point}"><code>Luxor.ellipse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ellipse(focus1::Point, focus2::Point, pt::Point;
    action=:none,
    stepvalue=pi/100,
    vertices=false,
    reversepath=false)</code></pre><p>Build a polygon approximation to an ellipse, given two points and a point somewhere on the ellipse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L614-L623">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.ellipse-Tuple{Point, Real, Real}" href="#Luxor.ellipse-Tuple{Point, Real, Real}"><code>Luxor.ellipse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ellipse(centerpoint::Point, w, h; action=:none)
ellipse(centerpoint::Point, w, h; action)</code></pre><p>Make an ellipse, centered at <code>centerpoint</code>, with width <code>w</code>, and height <code>h</code>, and add it to the current path.</p><p>Returns a tuple of two points, the corners of a bounding box that encloses the ellipse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L115-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.ellipseinquad-Tuple{Any}" href="#Luxor.ellipseinquad-Tuple{Any}"><code>Luxor.ellipseinquad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ellipseinquad(qgon; action=:none)
ellipseinquad(qgon, action)</code></pre><p>Calculate a Bézier-based ellipse that fits inside the quadrilateral <code>qgon</code>, an array with at least four Points that form a convex polygon, and add it to the current path.</p><p>It returns <code>ellipsecenter, ellipsesemimajor, ellipsesemiminor, ellipseangle</code>:</p><ul><li><p><code>ellipsecenter</code> the ellipse center</p></li><li><p><code>ellipsesemimajor</code> ellipse semimajor axis</p></li><li><p><code>ellipsesemiminor</code> ellipse semiminor axis</p></li><li><p><code>ellipseangle</code> ellipse rotation</p></li></ul><p>The function returns <code>O, 0, 0, 0</code> if a suitable ellipse can&#39;t be found. (The qgon is probably not a convex polygon.)</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">ellipseinquad(box(O, 130, 130); action=:stroke)

ellipseinquad(box(O, 140, 230), :stroke)</code></pre><p><strong>References</strong></p><p>http://faculty.mae.carleton.ca/John_Hayes/Papers/InscribingEllipse.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L1185-L1218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.epitrochoid-Tuple{Any, Any, Any}" href="#Luxor.epitrochoid-Tuple{Any, Any, Any}"><code>Luxor.epitrochoid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">epitrochoid(R, r, d;
    action=:none,
    stepby=0.01,
    period=0,
    vertices=false)
epitrochoid(R, r, d, action;
    stepby=0.01,
    period=0,
    vertices=false)</code></pre><p>Make a epitrochoid with short line segments, and add it to the current path. (Like a Spirograph.) The curve is traced by a point attached to a circle of radius <code>r</code> rolling around the outside of a fixed circle of radius <code>R</code>, where the point is a distance <code>d</code> from the center of the circle. Things get interesting if you supply non-integral values.</p><p><code>stepby</code>, the angular step value, controls the amount of detail, ie the smoothness of the polygon.</p><p>If <code>period</code> is not supplied, or 0, the lowest period is calculated for you.</p><p>The function can return a polygon (a list of points), or draw the points directly using the supplied <code>action</code>. If the points are drawn, the function returns a tuple showing how many points were drawn and what the period was (as a multiple of <code>pi</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L712-L741">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.fillpath-Tuple{}" href="#Luxor.fillpath-Tuple{}"><code>Luxor.fillpath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fillpath()</code></pre><p>Fill the current path according to the current settings. The current path is then cleared.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L165-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.fillpreserve-Tuple{}" href="#Luxor.fillpreserve-Tuple{}"><code>Luxor.fillpreserve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fillpreserve()</code></pre><p>Fill the current path with current settings, but then keep the path current.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L187-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.fillstroke-Tuple{}" href="#Luxor.fillstroke-Tuple{}"><code>Luxor.fillstroke</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fillstroke()</code></pre><p>Fill and stroke the current path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L194-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.findbeziercontrolpoints-NTuple{4, Point}" href="#Luxor.findbeziercontrolpoints-NTuple{4, Point}"><code>Luxor.findbeziercontrolpoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findbeziercontrolpoints(
    previouspt::Point,
    pt1::Point,
    pt2::Point,
    nextpt::Point;
        smoothing = 0.5)</code></pre><p>Find the Bézier control points for the line between <code>pt1</code> and <code>pt2</code>, where the point before <code>pt1</code> is <code>previouspt</code> and the next point after <code>pt2</code> is <code>nextpt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/bezierpath.jl#L140-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.finish-Tuple{}" href="#Luxor.finish-Tuple{}"><code>Luxor.finish</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">finish()</code></pre><p>Finish the drawing, and close the file. You may be able to open it in an external viewer application with <code>preview()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/drawings.jl#L359-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.fontface-Tuple{Any}" href="#Luxor.fontface-Tuple{Any}"><code>Luxor.fontface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fontface(fontname)</code></pre><p>Select a font to use. (Toy API)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/text.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.fontsize-Tuple{Any}" href="#Luxor.fontsize-Tuple{Any}"><code>Luxor.fontsize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fontsize(n)</code></pre><p>Set the font size to <code>n</code> units. The default size is 10 units. (Toy API)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/text.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.get_bezier_length-Tuple{BezierPathSegment}" href="#Luxor.get_bezier_length-Tuple{BezierPathSegment}"><code>Luxor.get_bezier_length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_bezier_length(bps::BezierPathSegment;
    steps=10)</code></pre><p>Return the length of a BezierPathSegment, using <code>steps</code> to determine the accuracy, by stepping  through the curve and finding all the points,  and then measuring between them.</p><p>This is obviously just an approximation; the maths to do it properly is too difficult for me. :(</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Path.jl#L247-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.get_bezier_points-Tuple{BezierPathSegment}" href="#Luxor.get_bezier_points-Tuple{BezierPathSegment}"><code>Luxor.get_bezier_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_bezier_points(bps::BezierPathSegment;
    steps=10)</code></pre><p>The flattening: return a list of all the points on the Bezier curve, including start and end, using <code>steps</code> to determine the accuracy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Path.jl#L234-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.get_current_color-Tuple{}" href="#Luxor.get_current_color-Tuple{}"><code>Luxor.get_current_color</code></a> — <span class="docstring-category">Method</span></header><section><div><p>get<em>current</em>color()</p><p>As set by eg <code>setcolor()</code>. Return an RGBA colorant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/colors_styles.jl#L343-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.get_current_hue-Tuple{}" href="#Luxor.get_current_hue-Tuple{}"><code>Luxor.get_current_hue</code></a> — <span class="docstring-category">Method</span></header><section><div><p>get<em>current</em>hue()</p><p>As set by eg <code>sethue()</code>. Return an RGB colorant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/colors_styles.jl#L332-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.get_fontsize-Tuple{}" href="#Luxor.get_fontsize-Tuple{}"><code>Luxor.get_fontsize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_fontsize()</code></pre><p>Return the font size set by <code>fontsize</code> or. more precisely. the y-scale of the Cairo font matrix if <code>Cairo.set_font_matrix</code> is used directly. (Toy API)</p><blockquote><p>This only works if Cairo is at least at v1.0.5.</p></blockquote></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/text.jl#L112-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.getmatrix-Tuple{}" href="#Luxor.getmatrix-Tuple{}"><code>Luxor.getmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getmatrix()</code></pre><p>Get the current matrix. Returns an array of six float64 numbers:</p><ul><li><p>xx component of the affine transformation</p></li><li><p>yx component of the affine transformation</p></li><li><p>xy component of the affine transformation</p></li><li><p>yy component of the affine transformation</p></li><li><p>x0 translation component of the affine transformation</p></li><li><p>y0 translation component of the affine transformation</p></li></ul><p>Some basic matrix transforms:</p><ul><li>translate</li></ul><p><code>transform([1, 0, 0, 1, dx, dy])</code> shifts by <code>dx</code>, <code>dy</code></p><ul><li>scale</li></ul><p><code>transform([fx 0 0 fy 0 0])</code> scales by <code>fx</code> and <code>fy</code></p><ul><li>rotate</li></ul><p><code>transform([cos(a), -sin(a), sin(a), cos(a), 0, 0])</code> rotates around to <code>a</code> radians</p><p>rotate around O: [c -s s c 0 0]</p><ul><li>shear</li></ul><p><code>transform([1 0 a 1 0 0])</code> shears in x direction by <code>a</code></p><p>shear in y direction by <code>a</code>: [1 a 0 1 0 0]</p><ul><li>x-skew</li></ul><p><code>transform([1, 0, tan(a), 1, 0, 0])</code> skews in x by <code>a</code></p><ul><li>y-skew</li></ul><p><code>transform([1, tan(a), 0, 1, 0, 0])</code> skews in y by <code>a</code></p><ul><li>flip</li></ul><p><code>transform([fx, 0, 0, fy, centerx * (1 - fx), centery * (fy-1)])</code> flips with center at <code>centerx</code>/<code>centery</code></p><ul><li>reflect</li></ul><p><code>transform([1 0 0 -1 0 0])</code> reflects in xaxis</p><p><code>transform([-1 0 0 1 0 0])</code> reflects in yaxis</p><p>When a drawing is first created, the matrix looks like this:</p><pre><code class="nohighlight hljs">getmatrix() = [1.0, 0.0, 0.0, 1.0, 0.0, 0.0]</code></pre><p>When the origin is moved to 400/400, it looks like this:</p><pre><code class="nohighlight hljs">getmatrix() = [1.0, 0.0, 0.0, 1.0, 400.0, 400.0]</code></pre><p>To reset the matrix to the original:</p><pre><code class="nohighlight hljs">setmatrix([1.0, 0.0, 0.0, 1.0, 0.0, 0.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/matrix.jl#L3-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.getmode-Tuple{}" href="#Luxor.getmode-Tuple{}"><code>Luxor.getmode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getmode()</code></pre><p>Return the current compositing/blending mode as a string.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/colors_styles.jl#L269-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.getnearestpointonline-Tuple{Point, Point, Point}" href="#Luxor.getnearestpointonline-Tuple{Point, Point, Point}"><code>Luxor.getnearestpointonline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getnearestpointonline(pt1::Point, pt2::Point, startpt::Point)</code></pre><p>Given a line from <code>pt1</code> to <code>pt2</code>, and <code>startpt</code> is the start of a perpendicular heading to meet the line, at what point does it hit the line?</p><p>See <code>perpendicular()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L143-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.getpath-Tuple{}" href="#Luxor.getpath-Tuple{}"><code>Luxor.getpath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getpath()</code></pre><p>Get the current path and return a CairoPath object, which is an array of <code>element_type</code> and <code>points</code> objects. With the results you can step through and examine each entry:</p><pre><code class="nohighlight hljs">o = getpath()
x, y = currentpoint()
for e in o
      if e.element_type == Cairo.CAIRO_PATH_MOVE_TO
          (x, y) = e.points
          move(x, y)
      elseif e.element_type == Cairo.CAIRO_PATH_LINE_TO
          (x, y) = e.points
          # straight lines
          line(x, y)
          strokepath()
          circle(x, y, 1, :stroke)
      elseif e.element_type == Cairo.CAIRO_PATH_CURVE_TO
          (x1, y1, x2, y2, x3, y3) = e.points
          # Bezier control lines
          circle(x1, y1, 1, :stroke)
          circle(x2, y2, 1, :stroke)
          circle(x3, y3, 1, :stroke)
          move(x, y)
          curve(x1, y1, x2, y2, x3, y3)
          strokepath()
          (x, y) = (x3, y3) # update current point
      elseif e.element_type == Cairo.CAIRO_PATH_CLOSE_PATH
          closepath()
      else
          error(&quot;unknown CairoPathEntry &quot; * repr(e.element_type))
          error(&quot;unknown CairoPathEntry &quot; * repr(e.points))
      end
  end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L568-L605">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.getpathflat-Tuple{}" href="#Luxor.getpathflat-Tuple{}"><code>Luxor.getpathflat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getpathflat()</code></pre><p>Get the current path, like <code>getpath()</code> but flattened so that there are no Bèzier curves.</p><p>Returns a CairoPath which is an array of <code>element_type</code> and <code>points</code> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L608-L614">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.getrotation-Tuple{Matrix}" href="#Luxor.getrotation-Tuple{Matrix}"><code>Luxor.getrotation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getrotation(R::Matrix)
getrotation()</code></pre><p>Get the rotation of a Julia 3x3 matrix, or the current Luxor rotation.</p><p class="math-container">\[\begin{bmatrix}
a &amp; b &amp; tx \\
c &amp; d &amp; ty \\
0 &amp; 0 &amp; 1  \\
\end{bmatrix}\]</p><p>The rotation angle is <code>atan(-b, a)</code> or <code>atan(c, d)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/matrix.jl#L172-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.getscale-Tuple{Matrix}" href="#Luxor.getscale-Tuple{Matrix}"><code>Luxor.getscale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getscale(R::Matrix)
getscale()</code></pre><p>Get the current scale of a Julia 3x3 matrix, or the current Luxor scale.</p><p>Returns a tuple of x and y values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/matrix.jl#L198-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.gettranslation-Tuple{Matrix}" href="#Luxor.gettranslation-Tuple{Matrix}"><code>Luxor.gettranslation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gettranslation(R::Matrix)
gettranslation()</code></pre><p>Get the current translation of a Julia 3x3 matrix, or the current Luxor translation.</p><p>Returns a tuple of x and y values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/matrix.jl#L216-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.getworldposition" href="#Luxor.getworldposition"><code>Luxor.getworldposition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getworldposition(pt::Point = O;
    centered=true)</code></pre><p>Return the world coordinates of <code>pt</code>.</p><p>The default coordinate system for Luxor/Cairo is that the top left corner is 0/0. If you use <code>origin()</code>, everything moves to the center of the drawing, and this function with the default <code>centered</code> option assumes an <code>origin()</code> function. If you choose <code>centered=false</code>, the returned coordinates will be relative to the top left corner of the drawing.</p><pre><code class="nohighlight hljs">origin()
translate(120, 120)
@show currentpoint()      # =&gt; Point(0.0, 0.0)
@show getworldposition()  # =&gt; Point(120.0, 120.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L536-L554">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.grestore-Tuple{}" href="#Luxor.grestore-Tuple{}"><code>Luxor.grestore</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grestore()</code></pre><p>Replace the current graphics state with the one on top of the stack.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L502-L506">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.gsave-Tuple{}" href="#Luxor.gsave-Tuple{}"><code>Luxor.gsave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gsave()</code></pre><p>Save the current color settings on the stack.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L486-L490">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.hascurrentpoint-Tuple{}" href="#Luxor.hascurrentpoint-Tuple{}"><code>Luxor.hascurrentpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hascurrentpoint()</code></pre><p>Return true if there is a current point. Obtain the current point with <code>currentpoint()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L526-L531">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.highestaspectratio-NTuple{5, Any}" href="#Luxor.highestaspectratio-NTuple{5, Any}"><code>Luxor.highestaspectratio</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">highestaspectratio()</code></pre><p>Find the highest aspect ratio of a list of rectangles, given the length of the side along which they are to be laid out.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Boxmaptile.jl#L78-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.highlightcells" href="#Luxor.highlightcells"><code>Luxor.highlightcells</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">highlightcells(t::Table, cellnumbers, action::Symbol=:stroke;
        color::Colorant=colorant&quot;red&quot;,
        offset = 0)</code></pre><p>Highlight (draw or fill) one or more cells of table <code>t</code>. <code>cellnumbers</code> is a range, array, or an array of row/column tuples.</p><pre><code class="nohighlight hljs">highlightcells(t, 1:10, :fill, color=colorant&quot;blue&quot;)
highlightcells(t, vcat(1:5, 150), :stroke, color=colorant&quot;magenta&quot;)
highlightcells(t, [(4, 5), (3, 6)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Table.jl#L285-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.hypotrochoid-Tuple{Any, Any, Any}" href="#Luxor.hypotrochoid-Tuple{Any, Any, Any}"><code>Luxor.hypotrochoid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hypotrochoid(R, r, d;
    action=:none,
    stepby=0.01,
    period=0.0,
    vertices=false)
hypotrochoid(R, r, d, action;
    stepby=0.01,
    period=0.0,
    vertices=false)</code></pre><p>Make a hypotrochoid with short line segments, and add it to the current path. (Like a Spirograph.) The curve is traced by a point attached to a circle of radius <code>r</code> rolling around the inside  of a fixed circle of radius <code>R</code>, where the point is a distance <code>d</code> from  the center of the interior circle. Things get interesting if you supply non-integral values.</p><p>Special cases include the hypocycloid, if <code>d</code> = <code>r</code>, and an ellipse, if <code>R</code> = <code>2r</code>.</p><p><code>stepby</code>, the angular step value, controls the amount of detail, ie the smoothness of the polygon,</p><p>If <code>period</code> is not supplied, or 0, the lowest period is calculated for you.</p><p>The function can return a polygon (a list of points), or draw the points directly using the supplied <code>action</code>. If the points are drawn, the function returns a tuple showing how many points were drawn and what the period was (as a multiple of <code>pi</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L643-L675">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.image_as_matrix!-Tuple{Any}" href="#Luxor.image_as_matrix!-Tuple{Any}"><code>Luxor.image_as_matrix!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">image_as_matrix!(buffer)</code></pre><p>Like <code>image_as_matrix()</code>, but use an existing UInt32 buffer.</p><p><code>buffer</code> is a buffer of UInt32.</p><pre><code class="nohighlight hljs">w = 200
h = 150
buffer = zeros(UInt32, w, h)
Drawing(w, h, :image)
origin()
juliacircles(50)
m = image_as_matrix!(buffer)
finish()
# collect(m)) is Array{ARGB32,2}
Images.RGB.(m)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/drawings.jl#L1003-L1022">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.image_as_matrix-Tuple{}" href="#Luxor.image_as_matrix-Tuple{}"><code>Luxor.image_as_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">image_as_matrix()</code></pre><p>Return an Array of the current state of the picture as an array of ARGB32.</p><p>A matrix 50 wide and 30 high =&gt; a table 30 rows by 50 cols</p><pre><code class="nohighlight hljs">using Luxor, Images

Drawing(50, 50, :png)
origin()
background(randomhue()...)
sethue(&quot;white&quot;)
fontsize(40)
fontface(&quot;Georgia&quot;)
text(&quot;42&quot;, halign=:center, valign=:middle)
mat = image_as_matrix()
finish()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/drawings.jl#L850-L871">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.initnoise-Tuple{Any}" href="#Luxor.initnoise-Tuple{Any}"><code>Luxor.initnoise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initnoise(seed::Int)
initnoise()</code></pre><p>Initialize the noise generation code.</p><pre><code class="nohighlight hljs">julia&gt; initnoise(); noise(1)
0.7453148982810598

julia&gt; initnoise(); noise(1)
0.7027617067916981</code></pre><p>If you provide an integer seed, it will be used to seed <code>Random.seed!()</code>` when the noise code is initialized:</p><pre><code class="nohighlight hljs">julia&gt; initnoise(41); noise(1) # yesterday
0.7134000046640385

julia&gt; initnoise(41); noise(1) # today
0.7134000046640385</code></pre><p>If you need to control which type of random number generator is used, you can provide your own and it will be used instead of the default Julia implementation.</p><pre><code class="nohighlight hljs">julia&gt; rng = MersenneTwister(1234) # any AbstractRNG
julia&gt; initnoise(rng)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/noise.jl#L179-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.insertvertices!-Tuple{Any}" href="#Luxor.insertvertices!-Tuple{Any}"><code>Luxor.insertvertices!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">insertvertices!(pgon;
    ratio=0.5)</code></pre><p>Insert a new vertex into each edge of a polygon <code>pgon</code>. The default <code>ratio</code> of 0.5 divides the original edge of the polygon into half.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L1321-L1327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.intersectboundingboxes-Tuple{BoundingBox, BoundingBox}" href="#Luxor.intersectboundingboxes-Tuple{BoundingBox, BoundingBox}"><code>Luxor.intersectboundingboxes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersectboundingboxes(bb1::BoundingBox, bb2::BoundingBox)</code></pre><p>Return a BoundingBox that&#39;s an intersection of the two bounding boxes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L356-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.intersection2circles-NTuple{4, Any}" href="#Luxor.intersection2circles-NTuple{4, Any}"><code>Luxor.intersection2circles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersection2circles(pt1, r1, pt2, r2)</code></pre><p>Find the area of intersection between two circles, the first centered at <code>pt1</code> with radius <code>r1</code>, the second centered at <code>pt2</code> with radius <code>r2</code>.</p><p>If one circle is entirely within another, that circle&#39;s area is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L861-L868">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.intersectioncirclecircle-NTuple{4, Any}" href="#Luxor.intersectioncirclecircle-NTuple{4, Any}"><code>Luxor.intersectioncirclecircle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersectioncirclecircle(cp1, r1, cp2, r2)</code></pre><p>Find the two points where two circles intersect, if they do. The first circle is centered at <code>cp1</code> with radius <code>r1</code>, and the second is centered at <code>cp1</code> with radius <code>r1</code>.</p><p>Returns</p><pre><code class="nohighlight hljs">(flag, ip1, ip2)</code></pre><p>where <code>flag</code> is a Boolean <code>true</code> if the circles intersect at the points <code>ip1</code> and <code>ip2</code>. If the circles don&#39;t intersect at all, or one is completely inside the other, <code>flag</code> is <code>false</code> and the points are both Point(0, 0).</p><p>Use <code>intersection2circles()</code> to find the area of two overlapping circles.</p><p>In the pure world of maths, it must be possible that two circles &#39;kissing&#39; only have a single intersection point. At present, this unromantic function reports that two kissing circles have no intersection points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L901-L920">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.intersectionlinecircle-Tuple{Point, Point, Point, Any}" href="#Luxor.intersectionlinecircle-Tuple{Point, Point, Point, Any}"><code>Luxor.intersectionlinecircle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersectionlinecircle(p1::Point, p2::Point, cpoint::Point, r)</code></pre><p>Find the intersection points of a line (extended through points <code>p1</code> and <code>p2</code>) and a circle.</p><p>Return a tuple of <code>(n, pt1, pt2)</code></p><p>where</p><ul><li><code>n</code> is the number of intersections, <code>0</code>, <code>1</code>, or <code>2</code></li><li><code>pt1</code> is first intersection point, or <code>Point(0, 0)</code> if none</li><li><code>pt2</code> is the second intersection point, or <code>Point(0, 0)</code> if none</li></ul><p>The calculated intersection points won&#39;t necessarily lie on the line segment between <code>p1</code> and <code>p2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L357-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.intersectionlines-NTuple{4, Point}" href="#Luxor.intersectionlines-NTuple{4, Point}"><code>Luxor.intersectionlines</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersectionlines(p0, p1, p2, p3;
    crossingonly=false)</code></pre><p>Find point where two lines intersect.</p><p>If <code>crossingonly == true</code> the point of intersection must lie on both lines.</p><p>If <code>crossingonly == false</code> the point of intersection can be where the lines meet if extended almost to &#39;infinity&#39;.</p><p>Accordng to this function, collinear, overlapping, and parallel lines never intersect. Ie, the line segments might be collinear but have no points in common, or the lines segments might be collinear and have many points in common, or the line segments might be collinear and one is entirely contained within the other.</p><p>If the lines are collinear and share a point in common, that is the intersection point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L406-L425">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.intersectlinepoly-Tuple{Point, Point, Vector{Point}}" href="#Luxor.intersectlinepoly-Tuple{Point, Point, Vector{Point}}"><code>Luxor.intersectlinepoly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersectlinepoly(pt1::Point, pt2::Point, C)</code></pre><p>Return an array of the points where a line between pt1 and pt2 crosses polygon C.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L1123-L1127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.isarcclockwise-Tuple{Point, Point, Point}" href="#Luxor.isarcclockwise-Tuple{Point, Point, Point}"><code>Luxor.isarcclockwise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isarcclockwise(c::Point, A::Point, B::Point)</code></pre><p>Return <code>true</code> if an arc centered at <code>c</code> going from <code>A</code> to <code>B</code> is clockwise.</p><p>If <code>c</code>, <code>A</code>, and <code>B</code> are collinear, then a hemispherical arc could be either clockwise or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L269-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.isinside-Tuple{Point, BoundingBox}" href="#Luxor.isinside-Tuple{Point, BoundingBox}"><code>Luxor.isinside</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isinside(p::Point, bb:BoundingBox)</code></pre><p>Returns <code>true</code> if <code>pt</code> is inside bounding box <code>bb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L373-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.isinside-Tuple{Point, Vector{Point}}" href="#Luxor.isinside-Tuple{Point, Vector{Point}}"><code>Luxor.isinside</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isinside(p, pol; allowonedge=false)</code></pre><p>Is a point <code>p</code> inside a polygon <code>pol</code>? Returns true if it does, or false.</p><p>This is an implementation of the Hormann-Agathos (2001) Point in Polygon algorithm.</p><p>The classification of points lying on the edges of the target polygon, or coincident with its vertices is not clearly defined, due to rounding errors or arithmetical inadequacy. By default these will generate errors, but you can suppress these by setting <code>allowonedge</code> to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L178-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.ispointonline-Tuple{Point, Point, Point}" href="#Luxor.ispointonline-Tuple{Point, Point, Point}"><code>Luxor.ispointonline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ispointonline(pt::Point, pt1::Point, pt2::Point;
    extended = false,
    atol = 10E-5)</code></pre><p>Return <code>true</code> if the point <code>pt</code> lies on a straight line between <code>pt1</code> and <code>pt2</code>.</p><p>If <code>extended</code> is false (the default) the point must lie on the line segment between <code>pt1</code> and <code>pt2</code>. If <code>extended</code> is true, the point lies on the line if extended in either direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L251-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.ispointonpoly-Tuple{Point, Vector{Point}}" href="#Luxor.ispointonpoly-Tuple{Point, Vector{Point}}"><code>Luxor.ispointonpoly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ispointonpoly(pt::Point, pgon;
    atol=10E-5)</code></pre><p>Return <code>true</code> if <code>pt</code> lies on the polygon <code>pgon.</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L288-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.ispolyclockwise-Tuple{Vector{Point}}" href="#Luxor.ispolyclockwise-Tuple{Vector{Point}}"><code>Luxor.ispolyclockwise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ispolyclockwise(pgon)</code></pre><p>Returns true if polygon is clockwise. WHEN VIEWED IN A LUXOR DRAWING...?</p><p>TODO This code is still experimental...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L1185-L1191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.ispolyconvex-Tuple{Any}" href="#Luxor.ispolyconvex-Tuple{Any}"><code>Luxor.ispolyconvex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ispolyconvex(pts)</code></pre><p>Return true if polygon is convex. This tests that every interior angle is less than or equal to 180°.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L594-L599">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.juliacircles" href="#Luxor.juliacircles"><code>Luxor.juliacircles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">juliacircles(radius=100;
    outercircleratio=0.75,
    innercircleratio=0.65,
    action=:fill)</code></pre><p>Draw the three Julia circles (&quot;dots&quot;) in color centered at the origin.</p><p>The distance of the centers of each circle from the origin is <code>radius</code>.</p><p>The optional keyword argument <code>outercircleratio</code> (default 0.75) determines the radius of each circle relative to the main radius. So the default is to draw circles of radius 75 points around a larger circle of radius 100.</p><p>Return the three centerpoints.</p><p>The <code>innercircleratio</code> (default 0.65) no longer does anything useful (it used to draw the smaller circles) and will be deprecated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/juliagraphics.jl#L274-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.julialogo-Tuple{}" href="#Luxor.julialogo-Tuple{}"><code>Luxor.julialogo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">julialogo(;
    action=:fill,
    color=true,
    bodycolor=colorant&quot;black&quot;,
    centered=false)</code></pre><p>Draw the Julia logo. The default action is to fill the logo and use the colors:</p><pre><code class="nohighlight hljs">julialogo()</code></pre><p>If <code>color</code> is <code>false</code>, the <code>bodycolor</code> color is used for the logo.</p><p>The function uses the current drawing state (position, scale, etc).</p><p>The <code>centered</code> keyword lets you center the logo at its mathematical center, but the optical center might lie somewhere else - it&#39;s difficult to position well due to its asymmetric design.</p><p>To use the logo as a clipping mask:</p><pre><code class="nohighlight hljs">julialogo(action=:clip)</code></pre><p>(In this case the <code>color</code> setting is automatically ignored.)</p><p>To obtain a stroked (outlined) version:</p><pre><code class="nohighlight hljs">julialogo(action=:path)
sethue(&quot;red&quot;)
strokepath()</code></pre><p>TODO Return something more useful than a Boolean.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/juliagraphics.jl#L24-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.juliatocairomatrix-Tuple{Matrix}" href="#Luxor.juliatocairomatrix-Tuple{Matrix}"><code>Luxor.juliatocairomatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">juliatocairomatrix(c)</code></pre><p>Return a six-element matrix that&#39;s the equivalent of the 3x3 Julia matrix in <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/matrix.jl#L163-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.label" href="#Luxor.label"><code>Luxor.label</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">label(txt::AbstractString, rotation::Float64, pos::Point=O;
    offset=5,
    leader=false,
    leaderoffsets=[0.0, 1.0])</code></pre><p>Add a text label at a point, positioned relative to that point, for example, <code>0.0</code> is East, <code>pi</code> is West.</p><pre><code class="nohighlight hljs">label(&quot;text&quot;, pi)          # positions text to the left of the origin</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/text.jl#L519-L529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.label" href="#Luxor.label"><code>Luxor.label</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">label(txt::AbstractString, alignment::Symbol=:N, pos::Point=O;
    offset=5,
    leader=false,
    leaderoffsets=[0.0, 1.0])</code></pre><p>Add a text label at a point, positioned relative to that point, for example, <code>:N</code> signifies North and places the text directly above that point.</p><p>Use one of <code>:N</code>, <code>:S</code>, <code>:E</code>, <code>:W</code>, <code>:NE</code>, <code>:SE</code>, <code>:SW</code>, <code>:NW</code> to position the label relative to that point.</p><pre><code class="nohighlight hljs">label(&quot;text&quot;)          # positions text at North (above), relative to the origin
label(&quot;text&quot;, :S)      # positions text at South (below), relative to the origin
label(&quot;text&quot;, :S, pt)  # positions text South of pt
label(&quot;text&quot;, :N, pt, offset=20)  # positions text North of pt, offset by 20</code></pre><p>The default offset is 5 units.</p><p>If <code>leader</code> is true, draw a line as well.</p><p><code>leaderoffsts</code> uses normalized fractions (see <code>between()</code>) to specify the gap between the designated points and the start and end of the lines.</p><p>TODO: Negative offsets don&#39;t give good results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/text.jl#L457-L483">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.layout-NTuple{5, Any}" href="#Luxor.layout-NTuple{5, Any}"><code>Luxor.layout</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">layout(A, x, y, w, h)</code></pre><p>From A, make a row of tiles (if wider than tall) or a column of tiles (if taller than wide).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Boxmaptile.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.layout_spring-Tuple{Matrix}" href="#Luxor.layout_spring-Tuple{Matrix}"><code>Luxor.layout_spring</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">layout_spring(adjmatrix::Array{T,2} where T;
    densityconstant = 2.0,
    maxiterations = 100,
    initialtemperature = 2.0,
    boundingbox=BoundingBox(O - (250, 250), O + (250, 250)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/graphlayout.jl#L99-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.layout_tree-Tuple{AbstractVector}" href="#Luxor.layout_tree-Tuple{AbstractVector}"><code>Luxor.layout_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><p>layout_tree(adjlist)</p><p><code>adj_list</code> must not be cyclic, otherwise welcome to stack overflow...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/graphlayout.jl#L172-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.layoutgraph-Tuple{Matrix}" href="#Luxor.layoutgraph-Tuple{Matrix}"><code>Luxor.layoutgraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">layoutgraph(adj_matrix::Array{T,2}; kwargs...)       &lt;--
layoutgraph(adj_list::AbstractVector; kwargs...)     not yet implemented</code></pre><p>Run one of two graph layout algorithms.</p><p>1: Layout the graph in adjacency matrix <code>adj_matrix</code>, using a spring-based method. Returns a tuple of <code>([xcoords], [ycoords])</code>, which are scaled according to the supplied BoundingBox.</p><p><strong>Keyword arguments</strong></p><p>Lay out the graph in <code>adjmatrix</code> using the spring/repulsion model of Fruchterman and Reingold (1991). Returns a tuple of <code>([xcoords], [ycoords])</code>.</p><p><strong>Arguments</strong></p><p><code>am</code> An adjacency matrix of some type. Non-zero of the eltype of the matrix is used to determine if a link exists, but currently no sense of magnitude</p><p><code>densityconstant</code> Constant to adjust the density of resulting layout. The default value is 2.0.</p><p><code>maxiterations</code> how many iterations for applying the forces</p><p><code>initialtemperature</code> the initial temperature controls movement per iteration. The default value is 2.0. Each iteration uses a lower temperature (TEMP = initialtemperature / iter). The idea is that the displacements of vertices are limited to some maximum temperature value, and this decreases over time. As the layout becomes better, the amount of adjustment becomes smaller.</p><p><code>locs_x</code> the starting x values, between -1 and 1. The default values are randomly selected.</p><p><code>locs_y</code> the starting y values, between -1 and 1. The default values are randomly selected.</p><p><code>boundingbox</code> The Luxor BoundingBox into which the graph&#39;s coordinates will fit. Defaults to 500 × 500.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/graphlayout.jl#L28-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.line-Tuple{Any, Any}" href="#Luxor.line-Tuple{Any, Any}"><code>Luxor.line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">line(pt)</code></pre><p>Draw a line from the current position to the <code>pt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L366-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.line-Tuple{Point, Point}" href="#Luxor.line-Tuple{Point, Point}"><code>Luxor.line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">line(pt1::Point, pt2::Point; action=:path)
line(pt1::Point, pt2::Point, action=:path)</code></pre><p>Make a line between two points, <code>pt1</code> and <code>pt2</code> and do an action.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L374-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.lineartween-NTuple{4, Any}" href="#Luxor.lineartween-NTuple{4, Any}"><code>Luxor.lineartween</code></a> — <span class="docstring-category">Method</span></header><section><div><p>default linear transition - no easing, no acceleration</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.makebezierpath-Tuple{Vector{Point}}" href="#Luxor.makebezierpath-Tuple{Vector{Point}}"><code>Luxor.makebezierpath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">makebezierpath(pgon::Array{Point, 1};
    smoothing=1.0)</code></pre><p>Return a Bézier path (a BezierPath) that represents a polygon (an array of points). The Bézier path is an array of segments (tuples of 4 points); each segment contains the four points that make up a section of the entire Bézier path.</p><p><code>smoothing</code> determines how closely the curve follows the polygon. A value of 0 returns a straight-sided path; as values move above 1 the paths deviate further from the original polygon&#39;s edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/bezierpath.jl#L173-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.mask-Tuple{Point, Point, Any, Any}" href="#Luxor.mask-Tuple{Point, Point, Any, Any}"><code>Luxor.mask</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mask(point::Point, focus::Point, width, height)
    max = 1.0,
    min = 0.0,
    easingfunction = easingflat)</code></pre><p>Calculate a value between 0 and 1 for a <code>point</code> relative to a rectangular area defined by <code>focus</code>, <code>width</code>, and <code>height</code>. The value will approach <code>max</code> (1.0) at the center, and <code>min</code> (0.0) at the edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/colors_styles.jl#L304-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.mask-Tuple{Point, Point, Any}" href="#Luxor.mask-Tuple{Point, Point, Any}"><code>Luxor.mask</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mask(point::Point, focus::Point, radius)
    max = 1.0,
    min = 0.0,
    easingfunction = easingflat)</code></pre><p>Calculate a value between 0 and 1 for a <code>point</code> relative to a circular area defined by <code>focus</code> and <code>radius</code>. The value will approach <code>max</code> (1.0) at the center of the circular area, and <code>min</code> (0.0) at the circumference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/colors_styles.jl#L278-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.mesh" href="#Luxor.mesh"><code>Luxor.mesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mesh(points::Array{Point},
     colors=Array{Colors.Colorant, 1})</code></pre><p>Create a mesh.</p><p>The first three or four sides of the supplied <code>points</code> polygon define the three or four sides of the mesh shape.</p><p>The <code>colors</code> array define the color of each corner point. Colors are reused if necessary. At least one color should be supplied.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">@svg begin
    pl = ngon(O, 250, 3, pi/6, vertices=true)
    mesh1 = mesh(pl, [
        &quot;purple&quot;,
        Colors.RGBA(0.0, 1.0, 0.5, 0.5),
        &quot;yellow&quot;
        ])
    setmesh(mesh1)
    setline(180)
    ngon(O, 250, 3, pi/6, :strokepreserve)
    setline(5)
    sethue(&quot;black&quot;)
    strokepath()
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/mesh.jl#L123-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.mesh" href="#Luxor.mesh"><code>Luxor.mesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mesh(bezierpath::BezierPath,
     colors=Array{Colors.Colorant, 1})</code></pre><p>Create a mesh. The first three or four elements of the supplied <code>bezierpath</code> define the three or four sides of the mesh shape.</p><p>The <code>colors</code> array define the color of each corner point. Colors are reused if necessary. At least one color should be supplied.</p><p>Use <code>setmesh()</code> to select the mesh, which will be used to fill shapes.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">@svg begin
    bp = makebezierpath(ngon(O, 50, 4, 0, vertices=true))
    mesh1 = mesh(bp, [
        &quot;red&quot;,
        Colors.RGB(0, 1, 0),
        Colors.RGB(0, 1, 1),
        Colors.RGB(1, 0, 1)
        ])
    setmesh(mesh1)
    box(O, 500, 500, :fill)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/mesh.jl#L85-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.midpoint" href="#Luxor.midpoint"><code>Luxor.midpoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">midpoint(bb::BoundingBox=BoundingBox())</code></pre><p>Returns the point midway between the two points of the BoundingBox. This should also be the center, unless I&#39;ve been very stupid...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L382-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.midpoint-Tuple{Array}" href="#Luxor.midpoint-Tuple{Array}"><code>Luxor.midpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">midpoint(a)</code></pre><p>Find midpoint between the first two elements of an array of points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L162-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.midpoint-Tuple{Point, Point}" href="#Luxor.midpoint-Tuple{Point, Point}"><code>Luxor.midpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">midpoint(p1, p2)</code></pre><p>Find the midpoint between two points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L155-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.move-Tuple{Any, Any}" href="#Luxor.move-Tuple{Any, Any}"><code>Luxor.move</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">move(pt)</code></pre><p>Move to a point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L350-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.nearestindex-Tuple{Vector{T} where T&lt;:Real, Any}" href="#Luxor.nearestindex-Tuple{Vector{T} where T&lt;:Real, Any}"><code>Luxor.nearestindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nearestindex(polydistancearray, value)</code></pre><p>Return a tuple of the index of the largest value in <code>polydistancearray</code> less than <code>value</code>, and the difference value. Array is assumed to be sorted.</p><p>(Designed for use with <code>polydistances()</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L941-L948">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.newpath-Tuple{}" href="#Luxor.newpath-Tuple{}"><code>Luxor.newpath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">newpath()</code></pre><p>Create a new path, after clearing the current path. After this there&#39;s no path and no current point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L135-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.newsubpath-Tuple{}" href="#Luxor.newsubpath-Tuple{}"><code>Luxor.newsubpath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">newsubpath()</code></pre><p>Start a new subpath, keeping the current path. After this there&#39;s no current point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.nextgridpoint-Tuple{GridHex}" href="#Luxor.nextgridpoint-Tuple{GridHex}"><code>Luxor.nextgridpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nextgridpoint(g::GridHex)</code></pre><p>Returns the next available grid point of a hexagonal grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/tiles-grids.jl#L220-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.nextgridpoint-Tuple{GridRect}" href="#Luxor.nextgridpoint-Tuple{GridRect}"><code>Luxor.nextgridpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nextgridpoint(g::GridRect)</code></pre><p>Returns the next available (or even the first) grid point of a grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/tiles-grids.jl#L192-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.ngon" href="#Luxor.ngon"><code>Luxor.ngon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ngon(centerpos, radius, sides=5, orientation=0;
    action=:none,
    vertices=false,
    reversepath=false)</code></pre><p>Draw a regular polygon centered at point <code>centerpos</code>.</p><p>Find the vertices of a regular n-sided polygon centered at <code>x</code>, <code>y</code> with circumradius <code>radius</code>.</p><p>The polygon is constructed counterclockwise, starting with the first vertex drawn below the positive x-axis.</p><p>If you just want the raw points, use keyword argument <code>vertices=true</code>, which returns the array of points. Compare:</p><pre><code class="language-julia hljs">ngon(0, 0, 4, 4, 0, vertices=true) # returns the polygon&#39;s points:

4-element Array{Luxor.Point, 1}:
Luxor.Point(2.4492935982947064e-16, 4.0)
Luxor.Point(-4.0, 4.898587196589413e-16)
Luxor.Point(-7.347880794884119e-16, -4.0)
Luxor.Point(4.0, -9.797174393178826e-16)</code></pre><p>whereas</p><pre><code class="nohighlight hljs">ngon(0, 0, 4, 4, 0, :close) # draws a polygon</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/shapes.jl#L325-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.ngon" href="#Luxor.ngon"><code>Luxor.ngon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ngon(x, y, radius, sides=5, orientation=0;
    action = :none,
    vertices = false,
    reversepath = false)</code></pre><p>Draw a regular polygon centered at point <code>Point(x,y)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/shapes.jl#L294-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.ngonside" href="#Luxor.ngonside"><code>Luxor.ngonside</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ngonside(centerpoint::Point, sidelength::Real, sides::Int=5, orientation=0;
        action=:none,
        vertices=false,
        reversepath=false)
ngonside(centerpoint::Point, sidelength::Real, sides::Int, orientation, action;
        vertices=false,
        reversepath=false)</code></pre><p>Draw a regular polygon centered at <code>centerpoint</code> with <code>sides</code> sides of length <code>sidelength</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/shapes.jl#L369-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.noise-Union{Tuple{Any}, Tuple{T}} where T&lt;:Integer" href="#Luxor.noise-Union{Tuple{Any}, Tuple{T}} where T&lt;:Integer"><code>Luxor.noise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">noise(x)          ; detail = 1, persistence = 1.0) # 1D
noise(x, y)       ; detail = 1, persistence = 1.0) # 2D
noise(x, y, z)    ; detail = 1, persistence = 1.0) # 3D
noise(x, y, z, w) ; detail = 1, persistence = 1.0) # 4D</code></pre><p>Generate a noise value between 0.0 and 1.0 corresponding to the <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code> values. An <code>x</code> value on its own produces 1D noise, <code>x</code> and <code>y</code> make 2D noise, and so on.</p><p>The <code>detail</code> value is an integer (&gt;= 1) specifying how many octaves of noise you want.</p><p>The <code>persistence</code> value, typically between 0.0 and 1.0, controls how quickly the amplitude diminishes for each successive octave for values of <code>detail</code> greater than 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/noise.jl#L5-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.offsetlinesegment-NTuple{5, Any}" href="#Luxor.offsetlinesegment-NTuple{5, Any}"><code>Luxor.offsetlinesegment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">offsetlinesegment(p1, p2, p3, d1, d2)</code></pre><p>Given three points, find another 3 points that are offset by d1 at the start and d2 at the end.</p><p>Negative d values put the offset on the left.</p><p>Used by <code>offsetpoly()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L575-L584">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.offsetpoly-Tuple{Any, Function}" href="#Luxor.offsetpoly-Tuple{Any, Function}"><code>Luxor.offsetpoly</code></a> — <span class="docstring-category">Method</span></header><section><div><p>offsetpoly(plist, shape::Function)</p><p>Return a closed polygon that is offset from and encloses an polyline.</p><p>The incoming set of points <code>plist</code> is treated as an polyline, and another set of points is created, which form a closed polygon offset from the source poly.</p><p>There must be at least 4 points in the polyline.</p><p>This method for <code>offsetpoly()</code> treats the list of points as <code>n</code> vertices connected with <code>n - 1</code> lines. (The other method <code>offsetpoly(plist, d)</code> treats the list of points as <code>n</code> vertices connected with <code>n</code> lines.)</p><p>The supplied function determines the width of the line. <code>f(0, θ)</code> gives the width at the start (the slope of the curve at that point is supplied in θ), <code>f(1, θ)</code> provides the width at the end, and <code>f(n, θ)</code> is the width of point <code>n/l</code>.</p><p><strong>Examples</strong></p><p>This example draws a tilde, with the ends starting at 20 (10 + 10) units wide, swelling to 50 (10 + 10 + 15 + 15) in the middle, as f(0.5) = 25.</p><pre><code class="nohighlight hljs">f(x, θ) =  10 + 15sin(x * π)
sinecurve = [Point(50x, 50sin(x)) for x in -π:π/24:π]
pgon = offsetpoly(sinecurve, f)
poly(pgon, :fill)</code></pre><p>This example enhances the vertical part of the curve, and thins the horizontal parts.</p><pre><code class="nohighlight hljs">g(x, θ) = rescale(abs(sin(θ)), 0, 1, 0.1, 30)
sinecurve = [Point(50x, 50sin(x)) for x in -π:π/24:π]
pgon = offsetpoly(sinecurve, g)
poly(pgon, :fill)</code></pre><p>TODO - rewrite it!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L717-L764">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.offsetpoly-Tuple{Any}" href="#Luxor.offsetpoly-Tuple{Any}"><code>Luxor.offsetpoly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">offsetpoly(plist;
    startoffset = 10,
    endoffset   = 10,
    easingfunction = lineartween)</code></pre><p>Return a closed polygon that is offset from and encloses an open polygon.</p><p>The incoming set of points <code>plist</code> is treated as an open polygon, and another set of points is created, which form a polygon lying <code>...offset</code> units away from the source poly.</p><p>This method for <code>offsetpoly()</code> treats the list of points as <code>n</code> vertices connected with <code>n - 1</code> lines. It allows you to vary the offset from the start of the line to the end.</p><p>The other method <code>offsetpoly(plist, d)</code> treats the list of points as <code>n</code> vertices connected with <code>n</code> lines.</p><p><strong>Extended help</strong></p><p>This function accepts a keyword argument that allows you to control the offset using a function, using the easing functionality built in to Luxor. By default the function is <code>lineartween()</code>, so the offset changes linearly between the <code>startoffset</code> and the <code>endoffset</code>. The function:</p><pre><code class="nohighlight hljs">f(a, b, c, d) = 2sin((a * π))</code></pre><p>runs from 0 to 2 and back as <code>a</code> runs from 0 to 1. The offsets are scaled by this amount.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L632-L666">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.offsetpoly-Union{Tuple{T}, Tuple{Vector{Point}, T}} where T&lt;:Number" href="#Luxor.offsetpoly-Union{Tuple{T}, Tuple{Vector{Point}, T}} where T&lt;:Number"><code>Luxor.offsetpoly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">offsetpoly(plist::Array{Point, 1}, d) where T&lt;:Number</code></pre><p>Return a polygon that is offset from a polygon by <code>d</code> units.</p><p>The incoming set of points <code>plist</code> is treated as a polygon, and another set of points is created, which form a polygon lying <code>d</code> units away from the source poly.</p><p>Polygon offsetting is a topic on which people have written PhD theses and published academic papers, so this short brain-dead routine will give good results for simple polygons up to a point (!). There are a number of issues to be aware of:</p><ul><li><p>very short lines tend to make the algorithm &#39;flip&#39; and produce larger lines</p></li><li><p>small polygons that are counterclockwise and larger offsets may make the new polygon appear the wrong side of the original</p></li><li><p>very sharp vertices will produce even sharper offsets, as the calculated intersection point veers off to infinity</p></li><li><p>duplicated adjacent points might cause the routine to scratch its head and wonder how to draw a line parallel to them</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L512-L532">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.origin-Tuple{Any}" href="#Luxor.origin-Tuple{Any}"><code>Luxor.origin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">origin(pt:Point)</code></pre><p>Reset the current matrix, then move the <code>0/0</code> position to <code>pt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.origin-Tuple{}" href="#Luxor.origin-Tuple{}"><code>Luxor.origin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">origin()</code></pre><p>Reset the current matrix, and then set the 0/0 origin to the center of the drawing (otherwise it will stay at the top left corner, the default).</p><p>You can refer to the 0/0 point as <code>O</code>. (O = <code>Point(0, 0)</code>),</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.paint-Tuple{}" href="#Luxor.paint-Tuple{}"><code>Luxor.paint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">paint()</code></pre><p>Paint the current clip region with the current settings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L172-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.pathlength-Tuple{Path}" href="#Luxor.pathlength-Tuple{Path}"><code>Luxor.pathlength</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pathlength(path::Path;
    steps=10)</code></pre><p>Return the length of a Path.</p><p>The <code>steps</code> parameter is used when approximating the length of any curve (Bezier) sections.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Path.jl#L268-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.pathsample-Tuple{Path, Any}" href="#Luxor.pathsample-Tuple{Path, Any}"><code>Luxor.pathsample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pathsample(path::Path, spacing;
    steps=10)</code></pre><p>Return a new Path that resamples the <code>path</code> such that each line and curve of the original path is divided into sections that are approximately <code>spacing</code> units long.</p><p>The <code>steps</code> parameter is used when approximating the length of any curve (Bezier) sections. For measurement purposes, each Bezier curve is divided in <code>steps</code> straight lines; the error will be smaller for flatter curves and larger for more curvy ones.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Path.jl#L387-L400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.pathtobezierpaths-Tuple{}" href="#Luxor.pathtobezierpaths-Tuple{}"><code>Luxor.pathtobezierpaths</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pathtobezierpaths(
    ; flat=true)</code></pre><p>Convert the current Cairo path (which may consist of one or more paths) to an array of Bézier paths, each of which is an array of BezierPathSegments. Each path segment is a tuple of four points. A straight line is converted to a Bézier segment in which the control points are set to be the same as the end points.</p><p>If <code>flat</code> is true, use <code>getpathflat()</code> rather than <code>getpath()</code>.</p><p><strong>Example</strong></p><p>This code draws the BezierPathSegments and shows the control points as &quot;handles&quot;, like a vector-editing program might.</p><pre><code class="nohighlight hljs">@svg begin
    fontface(&quot;MyanmarMN-Bold&quot;)
    st = &quot;goo&quot;
    thefontsize = 100
    fontsize(thefontsize)
    sethue(&quot;red&quot;)
    fontsize(thefontsize)
    textpath(st)
    nbps = pathtobezierpaths()
    for nbp in nbps
        setline(.15)
        sethue(&quot;grey50&quot;)
        drawbezierpath(nbp, :stroke)
        for p in nbp
            sethue(&quot;red&quot;)
            circle(p[2], 0.16, :fill)
            circle(p[3], 0.16, :fill)
            line(p[2], p[1], :stroke)
            line(p[3], p[4], :stroke)
            if p[1] != p[4]
                sethue(&quot;black&quot;)
                circle(p[1], 0.26, :fill)
                circle(p[4], 0.26, :fill)
            end
        end
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/bezierpath.jl#L331-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.pathtopoly-Tuple{}" href="#Luxor.pathtopoly-Tuple{}"><code>Luxor.pathtopoly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pathtopoly()</code></pre><p>Convert the current path to an array of polygons.</p><p>Returns an array of polygons, corresponding to the paths and subpaths of the original path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L871-L877">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.perpendicular-Tuple{Point, Point, Any}" href="#Luxor.perpendicular-Tuple{Point, Point, Any}"><code>Luxor.perpendicular</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">perpendicular(p1, p2, k)</code></pre><p>Return a point <code>p3</code> that is <code>k</code> units away from <code>p1</code>, such that a line <code>p1 p3</code> is perpendicular to <code>p1 p2</code>.</p><p>Convention? to the right?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L196-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.perpendicular-Tuple{Point, Point, Point}" href="#Luxor.perpendicular-Tuple{Point, Point, Point}"><code>Luxor.perpendicular</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">perpendicular(p1::Point, p2::Point, p3::Point)</code></pre><p>Return a point on a line passing through <code>p1</code> and <code>p2</code> that is perpendicular to <code>p3</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L185-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.perpendicular-Tuple{Point, Point}" href="#Luxor.perpendicular-Tuple{Point, Point}"><code>Luxor.perpendicular</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">perpendicular(p1, p2)</code></pre><p>Return two points <code>p3</code> and <code>p4</code> such that a line from <code>p3</code> to <code>p4</code> is perpendicular to a line from <code>p1</code> to <code>p2</code>, the same length, and the lines intersect at their midpoints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L217-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.perpendicular-Tuple{Point}" href="#Luxor.perpendicular-Tuple{Point}"><code>Luxor.perpendicular</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">perpendicular(p::Point)</code></pre><p>Returns point <code>Point(p.y, -p.x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L233-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.pie-NTuple{5, Real}" href="#Luxor.pie-NTuple{5, Real}"><code>Luxor.pie</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pie(x, y, radius, startangle, endangle; action=:none)
pie(centerpoint, radius, startangle, endangle; action=:none)</code></pre><p>Make a pie shape centered at <code>x</code>/<code>y</code>. Angles start at the positive x-axis and are measured clockwise, and add it to the current path.</p><p>TODO - return something more useful than a Boolean</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L427-L435">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.pie-Tuple{Point, Real, Real, Real, Symbol}" href="#Luxor.pie-Tuple{Point, Real, Real, Real, Symbol}"><code>Luxor.pie</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pie(centerpoint::Point, radius::Real, startangle::Real, endangle::Real, action::Symbol)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L455-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.pie-Tuple{Real, Real, Real}" href="#Luxor.pie-Tuple{Real, Real, Real}"><code>Luxor.pie</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pie(radius, startangle, endangle;
    action=:none)</code></pre><p>Make a pie shape centered at the origin, and add it to the current path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L461-L466">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.placeimage" href="#Luxor.placeimage"><code>Luxor.placeimage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">placeimage(svgimg, pos=O; centered=false)</code></pre><p>Place an SVG image stored in <code>svgimg</code> on the drawing at <code>pos</code>. Use <code>readsvg()</code> to read an SVG image from file, or from SVG code.</p><p>Use keyword <code>centered=true</code> to place the center of the image at the position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/images.jl#L161-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.placeimage" href="#Luxor.placeimage"><code>Luxor.placeimage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">placeimage(matrix::AbstractMatrix{UInt32}, pos=O;
    alpha=1, centered=false)</code></pre><p>Place an image matrix on the drawing at <code>pos</code> with opacity/transparency <code>alpha</code>.</p><p>Use keyword <code>centered=true</code> to place the center of the image at the position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/images.jl#L181-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.placeimage-Tuple{Cairo.CairoSurface, Any, Any, Any}" href="#Luxor.placeimage-Tuple{Cairo.CairoSurface, Any, Any, Any}"><code>Luxor.placeimage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">placeimage(img, pt::Point=O, alpha; centered=false)
placeimage(pngimg, xpos, ypos, alpha; centered=false)</code></pre><p>Place a PNG image <code>pngimg</code> on the drawing at <code>pt</code> or <code>Point(xpos, ypos)</code> with opacity/transparency <code>alpha</code>. The image has been previously loaded using <code>readpng()</code>.</p><p>Use keyword <code>centered=true</code> to place the center of the image at the position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/images.jl#L50-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.placeimage-Tuple{Cairo.CairoSurface, Any, Any}" href="#Luxor.placeimage-Tuple{Cairo.CairoSurface, Any, Any}"><code>Luxor.placeimage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">placeimage(pngimg, pos=O; centered=false)
placeimage(pngimg, xpos, ypos; centered=false)</code></pre><p>Place the PNG image on the drawing at <code>pos</code>, or (<code>xpos</code>/<code>ypos</code>). The image <code>img</code> has been previously read using <code>readpng()</code>.</p><p>Use keyword <code>centered=true</code> to place the center of the image at the position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/images.jl#L29-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.pointcircletangent-Tuple{Point, Point, Any}" href="#Luxor.pointcircletangent-Tuple{Point, Point, Any}"><code>Luxor.pointcircletangent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pointcircletangent(point::Point, circlecenter::Point, circleradius)</code></pre><p>Find the two points on a circle that lie on tangent lines passing through an external point.</p><p>If both points are O, the external point is inside the circle, and the result is <code>(O, O)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L1127-L1135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.pointcrossesboundingbox-Tuple{Any, BoundingBox}" href="#Luxor.pointcrossesboundingbox-Tuple{Any, BoundingBox}"><code>Luxor.pointcrossesboundingbox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pointcrossesboundingbox(pt, bbox::BoundingBox)</code></pre><p>Find and return the point where a line from the center of bounding box <code>bbox</code> to point <code>pt</code> would, if continued, cross the edges of the box.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L531-L536">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.pointinverse-Tuple{Point, Any, Any}" href="#Luxor.pointinverse-Tuple{Point, Any, Any}"><code>Luxor.pointinverse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pointinverse(A::Point, centerpoint::Point, rad)</code></pre><p>Find <code>A′</code>, the inverse of a point A with respect to a circle <code>centerpoint</code>/<code>rad</code>, such that:</p><pre><code class="nohighlight hljs">distance(centerpoint, A) * distance(centerpoint, A′) == rad^2</code></pre><p>Return (true, A′) or (false, A).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L488-L498">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.pointlinedistance-Tuple{Point, Point, Point}" href="#Luxor.pointlinedistance-Tuple{Point, Point, Point}"><code>Luxor.pointlinedistance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pointlinedistance(p::Point, a::Point, b::Point)</code></pre><p>Find the distance between a point <code>p</code> and a line between two points <code>a</code> and <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L132-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polar-Tuple{Any, Any}" href="#Luxor.polar-Tuple{Any, Any}"><code>Luxor.polar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polar(r, theta)</code></pre><p>Convert point in polar form (radius and angle) to a Point.</p><pre><code class="nohighlight hljs">polar(10, pi/4)</code></pre><p>produces</p><pre><code class="nohighlight hljs">Luxor.Point(7.071067811865475, 7.0710678118654755)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L393-L403">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.poly" href="#Luxor.poly"><code>Luxor.poly</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">poly(bbox::BoundingBox, :action; kwargs...)</code></pre><p>Make a polygon around the BoundingBox in <code>bbox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L300-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.poly-Tuple{Vector{Point}}" href="#Luxor.poly-Tuple{Vector{Point}}"><code>Luxor.poly</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Draw a polygon.</p><pre><code class="nohighlight hljs">poly(pointlist::Array{Point, 1}, action = :none;
    close=false,
    reversepath=false)</code></pre><p>Create a path with the points in <code>pointlist</code> and apply <code>action</code>. By default <code>poly()</code> doesn&#39;t close or fill the polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyarea-Tuple{Vector{Point}}" href="#Luxor.polyarea-Tuple{Vector{Point}}"><code>Luxor.polyarea</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polyarea(p::Array)</code></pre><p>Find the area of a simple polygon. It works only for polygons that don&#39;t self-intersect. See also <code>polyorientation()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L1105-L1110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polycentroid-Tuple{Vector{Point}}" href="#Luxor.polycentroid-Tuple{Vector{Point}}"><code>Luxor.polycentroid</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find the centroid of a simple polygon.</p><pre><code class="nohighlight hljs">polycentroid(pointlist)</code></pre><p>Returns a point. This only works for simple (non-intersecting) polygons.</p><p>You could test the point using <code>isinside()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L41-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polycross" href="#Luxor.polycross"><code>Luxor.polycross</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">polycross(pt::Point, radius, npoints::Int, ratio=0.5, orientation=0.0;
    action      = :none,
    splay       = 0.5,
    vertices    = false,
    reversepath = false)
polycross(pt::Point, radius, npoints::Int, ratio=0.5, orientation=0.0, action;
    splay       = 0.5,
    vertices    = false,
    reversepath = false)</code></pre><p>Make a cross-shaped polygon with <code>npoints</code> arms to fit inside a circle of radius <code>radius</code> centered at <code>pt</code>.</p><p><code>ratio</code> specifies the ratio of the two sides of each arm. <code>splay</code> makes the arms ... splayed.</p><p>Use <code>vertices=true</code> to return the vertices of the shape instead of executing the action.</p><p>(Adapted from Compose.jl.xgon()))</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">polycross(O, 100, 5,
    action = :fill,
    splay  = 0.5)

polycross(O, 120, 5, 0.5, 0.0, :stroke,
    splay  = 0.5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/shapes.jl#L524-L556">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polydistances-Tuple{Vector{Point}}" href="#Luxor.polydistances-Tuple{Vector{Point}}"><code>Luxor.polydistances</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polydistances(p::Array{Point, 1}; closed=true)</code></pre><p>Return an array of the cumulative lengths of a polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L911-L915">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyfit" href="#Luxor.polyfit"><code>Luxor.polyfit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">polyfit(plist::Array, npoints=30)</code></pre><p>Build a polygon that constructs a B-spine approximation to it. The resulting list of points makes a smooth path that runs between the first and last points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L833-L838">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyhull-Tuple{Any}" href="#Luxor.polyhull-Tuple{Any}"><code>Luxor.polyhull</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polyhull(pts)</code></pre><p>Find all points in <code>pts</code> that form a convex hull around the points in <code>pts</code>, and return them.</p><p>This uses the Graham Scan algorithm.</p><p>TODO : experimental, can be improved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L1548-L1557">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyintersect-Tuple{AbstractVector{Point}, AbstractVector{Point}}" href="#Luxor.polyintersect-Tuple{AbstractVector{Point}, AbstractVector{Point}}"><code>Luxor.polyintersect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polyintersect(p1::AbstractArray{Point, 1}, p2::AbstractArray{Point, 1};
    closed=true)</code></pre><p>TODO: Fix/test/improve this experimental polygon intersection routine.</p><p>Return the points where polygon p1 and polygon p2 cross.</p><p>If <code>closed</code> is false, the intersection points must lie on the first <code>n - 1</code> lines of each polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L1347-L1356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyintersections-Tuple{Vector{Point}, Vector{Point}}" href="#Luxor.polyintersections-Tuple{Vector{Point}, Vector{Point}}"><code>Luxor.polyintersections</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polyintersections(S::Array{Point, 1}, C::Array{Point, 1})</code></pre><p>Return an array of the points in polygon S plus the points where polygon S crosses polygon C. Calls <code>intersectlinepoly()</code>.</p><p>TODO This code is experimental...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L1142-L1149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polymorph-Tuple{Array{Vector{Point}}, Array{Vector{Point}}, Any}" href="#Luxor.polymorph-Tuple{Array{Vector{Point}}, Array{Vector{Point}}, Any}"><code>Luxor.polymorph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polymorph(pgon1::Array{Array{Point,1}}, pgon2::Array{Array{Point,1}}, k;
    samples = 100,
    easingfunction = easingflat,
    min_k = 0.01,
    max_k = 0.99,
    kludge = true)</code></pre><p>&quot;morph&quot; is to gradually change from one thing to another. This function changes one polygon into another.</p><p>It returns an array of polygons, <code>[p_1, p_2, p_3, ... ]</code>, where each polygon <code>p_n</code> is the intermediate shape between the corresponding shape in <code>pgon1[1...n]</code> and <code>pgon2[1...n]</code> at <code>k</code>, where <code>0.0 &lt; k &lt; 1.0</code>. When <code>k &lt;= min_k</code> , the <code>pgon1[1...n]</code> is returned, and when <code>k &gt;= max_k</code>, <code>pgon2[1...n]</code> is returned.</p><p><code>pgon1</code> and <code>pgon2</code> can be either simple polygons or arrays of one or more polygonal shapes (eg as created by <code>pathtopoly()</code>). For example, <code>pgon1</code> might consist of two polygonal shapes, a square and a triangular shaped hole inside; <code>pgon2</code> might be a triangular shape with a square hole.</p><p>It makes sense for both arguments to have the same number of polygonal shapes. If one has more than another, some shapes would be lost when it morphs. But the suggestively-named <code>kludge</code> keyword argument, when set to (the default) true, tries to compensate for this.</p><p>By default, <code>easingfunction = easingflat</code>, so the intermediate steps are linear. If you use another easing function, intermediate steps are determined by the value of the easing function at <code>k</code>.</p><p>This function isn&#39;t very efficient, because it copies the polygons and resamples them.</p><p>TODO : experimental, can surely be improved.</p><p><strong>Extended help</strong></p><p><strong>Examples</strong></p><p>This simple morph between a small square and a larger octagon is controlled by the easing function <code>easeinoutinversequad</code>, which slows down around the middle of the transition.</p><p>Only the first shape of the returned polygon array is needed.</p><pre><code class="language-julia hljs">pgon1 = ngon(O, 30, 4, 0, vertices = true)
pgon2 = ngon(O, 220, 8, 0, vertices = true)
for i in 0:0.1:1.0
    poly(first(polymorph(pgon1, pgon2, i,
            easingfunction = easeinoutinversequad)),
        action = :stroke,
        close = true)
end</code></pre><p>This next example morphs between the first shape - a circle with a square hole - and the second shape, a square with a circular hole.</p><pre><code class="language-julia hljs">ngon(O - (250, 0), 30, 50, 0, :path)
newsubpath()
ngon(O - (250, 0), 10, 4, 0, reversepath = true, :path)
pg1 = pathtopoly()

newpath()
ngon(O + (250, 0), 30, 4, 0, :path)
newsubpath()
ngon(O + (250, 0), 10, 50, 0, reversepath = true, :path)
pg2 = pathtopoly()

for i in reverse(0.0:0.1:1.0)
    randomhue()
    newpath()
    # use :path followed by fillpath() to preserve correct &quot;hole&quot;-iness
    poly.(polymorph(pg1, pg2, i), :path, close = true)
    fillpath()
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L1638-L1726">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polymove!-Tuple{Any, Point, Point}" href="#Luxor.polymove!-Tuple{Any, Point, Point}"><code>Luxor.polymove!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polymove!(pgon, frompoint::Point, topoint::Point)</code></pre><p>Move (permanently) a polygon from <code>frompoint</code> to <code>topoints</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L1247-L1251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyorientation-Tuple{Vector{Point}}" href="#Luxor.polyorientation-Tuple{Vector{Point}}"><code>Luxor.polyorientation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polyorientation(pgon)</code></pre><p>Returns a number which is positive if the polygon is clockwise in Luxor...</p><p>TODO This code is still experimental...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L1166-L1172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyperimeter-Tuple{Vector{Point}}" href="#Luxor.polyperimeter-Tuple{Vector{Point}}"><code>Luxor.polyperimeter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polyperimeter(p::Array{Point, 1}; closed=true)</code></pre><p>Find the total length of the sides of polygon <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L932-L936">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyportion" href="#Luxor.polyportion"><code>Luxor.polyportion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">polyportion(p::Array{Point, 1}, portion=0.5; closed=true, pdist=[])</code></pre><p>Return a portion of a polygon, starting at a value between 0.0 (the beginning) and 1.0 (the end). 0.5 returns the first half of the polygon, 0.25 the first quarter, 0.75 the first three quarters, and so on.</p><p>Use <code>closed=false</code> to exclude the line joining the final point to the first point from the calculations.</p><p>If you already have a list of the distances between each point in the polygon (the &quot;polydistances&quot;), you can pass them in <code>pdist</code>, otherwise they&#39;ll be calculated afresh, using <code>polydistances(p, closed=closed)</code>.</p><p>Use the complementary <code>polyremainder()</code> function to return the other part.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L960-L978">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyreflect!" href="#Luxor.polyreflect!"><code>Luxor.polyreflect!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">polyreflect!(pgon, pt1 = O, pt2 = O + (0, 100)</code></pre><p>Reflect (permanently) a polygon in a line (default to the y-axis) joining two points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L1307-L1312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyremainder" href="#Luxor.polyremainder"><code>Luxor.polyremainder</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">polyremainder(p::Array{Point, 1}, portion=0.5; closed=true, pdist=[])</code></pre><p>Return the rest of a polygon, starting at a value between 0.0 (the beginning) and 1.0 (the end). 0.5 returns the last half of the polygon, 0.25 the last three quarters, 0.75 the last quarter, and so on.</p><p>Use <code>closed=false</code> to exclude the line joining the final point to the first point from the calculations.</p><p>If you already have a list of the distances between each point in the polygon (the &quot;polydistances&quot;), you can pass them in <code>pdist</code>, otherwise they&#39;ll be calculated afresh, using <code>polydistances(p, closed=closed)</code>.</p><p>Use the complementary <code>polyportion()</code> function to return the other part.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L1008-L1023">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyremovecollinearpoints-Tuple{Vector{Point}}" href="#Luxor.polyremovecollinearpoints-Tuple{Vector{Point}}"><code>Luxor.polyremovecollinearpoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polyremovecollinearpoints(pgon::Array{Point, 1})</code></pre><p>Return copy of polygon with no collinear points.</p><p>Caution: may return an empty polygon... !</p><p>TODO This code is still experimental...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L1223-L1231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyrotate!-Tuple{Any, Any}" href="#Luxor.polyrotate!-Tuple{Any, Any}"><code>Luxor.polyrotate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polyrotate!(pgon, θ;
    center=O)</code></pre><p>Rotate (permanently) a polygon around <code>center</code> by <code>θ</code> radians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L1289-L1294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polysample-Tuple{Vector{Point}, Integer}" href="#Luxor.polysample-Tuple{Vector{Point}, Integer}"><code>Luxor.polysample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polysample(p::Array{Point, 1}, npoints::T where T &lt;: Integer;
        closed=true)</code></pre><p>Sample the polygon <code>p</code>, returning a polygon with <code>npoints</code> to represent it. The first sampled point is:</p><p><code>1/`npoints` * `perimeter of p</code>`</p><p>away from the original first point of <code>p</code>.</p><p>If <code>npoints</code> is the same as <code>length(p)</code> the returned polygon is the same as the original, but the first point finishes up at the end (so <code>new=circshift(old, 1)</code>).</p><p>If <code>closed</code> is true, the entire polygon (including the edge joining the last point to the first point) is sampled.</p><p>If <code>include_first</code> is true, the first point of <code>plist</code> is included in the result.</p><p>If the resulting polygon&#39;s first and end points are the same, the end point is discarded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L1051-L1074">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyscale!-Tuple{Any, Any, Any}" href="#Luxor.polyscale!-Tuple{Any, Any, Any}"><code>Luxor.polyscale!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polyscale!(pgon, sh, sv;
    center=O)</code></pre><p>Scale (permanently) a polygon by <code>sh</code> horizontally and <code>sv</code> vertically, relative to <code>center</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L1274-L1280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyscale!-Tuple{Any, Any}" href="#Luxor.polyscale!-Tuple{Any, Any}"><code>Luxor.polyscale!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polyscale!(pgon, s;
   center=O)</code></pre><p>Scale (permanently) a polygon by <code>s</code>, relative to <code>center</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L1260-L1265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polysmooth-Tuple{Vector{Point}, Any, Symbol}" href="#Luxor.polysmooth-Tuple{Vector{Point}, Any, Symbol}"><code>Luxor.polysmooth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polysmooth(points, radius, action=:action; debug=false)
polysmooth(points, radius; action=:none, debug=false)</code></pre><p>Make a closed path from the <code>points</code> and round the corners by making them arcs with the given radius. Execute the action when finished.</p><p>The arcs are sometimes different sizes: if the given radius is bigger than the length of the shortest side, the arc can&#39;t be drawn at its full radius and is therefore drawn as large as possible (as large as the shortest side allows).</p><p>The <code>debug</code> option also draws the construction circles at each corner.</p><p>TODO Return something more useful than a Boolean.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L462-L476">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polysortbyangle" href="#Luxor.polysortbyangle"><code>Luxor.polysortbyangle</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Sort the points of a polygon into order. Points are sorted according to the angle they make with a specified point.</p><pre><code class="nohighlight hljs">polysortbyangle(pointlist::Array, refpoint=minimum(pointlist))</code></pre><p>The <code>refpoint</code> can be chosen, but the default minimum point is usually OK too:</p><pre><code class="nohighlight hljs">polysortbyangle(parray, polycentroid(parray))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L90-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polysortbydistance-Tuple{Vector{Point}, Point}" href="#Luxor.polysortbydistance-Tuple{Vector{Point}, Point}"><code>Luxor.polysortbydistance</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Sort a polygon by finding the nearest point to the starting point, then the nearest point to that, and so on.</p><pre><code class="nohighlight hljs">polysortbydistance(p, starting::Point)</code></pre><p>You can end up with convex (self-intersecting) polygons, unfortunately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L109-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polysplit-Tuple{Vector{Point}, Point, Point}" href="#Luxor.polysplit-Tuple{Vector{Point}, Point, Point}"><code>Luxor.polysplit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polysplit(p, p1, p2)</code></pre><p>Split a polygon into two where it intersects with a line. It returns two polygons:</p><pre><code class="nohighlight hljs">(poly1, poly2)</code></pre><p>This doesn&#39;t always work, of course. For example, a polygon the shape of the letter &quot;E&quot; might end up being divided into more than two parts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L231-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polytopath-Tuple{Vector{Point}}" href="#Luxor.polytopath-Tuple{Vector{Point}}"><code>Luxor.polytopath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polytopath(ptlist)</code></pre><p>Convert a polygon to a Path object.</p><pre><code class="language-julia hljs">@draw drawpath(polytopath(ngon(O, 145, 5, vertices=true)), action=:fill)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Path.jl#L160-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polytriangulate-Tuple{Vector{Point}}" href="#Luxor.polytriangulate-Tuple{Vector{Point}}"><code>Luxor.polytriangulate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polytriangulate(plist::Array{Point,1}; epsilon = -0.01)</code></pre><p>Triangulate the polygon in <code>plist</code>.</p><p>This uses the Bowyer–Watson/Delaunay algorithm to make triangles. It returns an array of triangular polygons.</p><p>TODO: This experimental polygon function is not very efficient, because it first copies the list of points (to avoid modifying the original), and sorts it, before making triangles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L1420-L1428">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.prettypoly" href="#Luxor.prettypoly"><code>Luxor.prettypoly</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prettypoly(bbox::BoundingBox, action; kwargs...)</code></pre><p>Make a decorated polygon around the BoundingBox in <code>bbox</code>. The vertices are in the order: bottom left, top left, top right, and bottom right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L308-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.prettypoly" href="#Luxor.prettypoly"><code>Luxor.prettypoly</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prettypoly(points::Array{Point, 1}, vertexfunction = () -&gt; circle(O, 2, :stroke);
    action=:none,
    close=false,
    reversepath=false,
    vertexlabels = (n, l) -&gt; ()
    )</code></pre><p>Draw the polygon defined by <code>points</code>, possibly closing and reversing it, using the current parameters, and then evaluate the <code>vertexfunction</code> function at every vertex of the polygon.</p><p>The default vertexfunction draws a 2 pt radius circle.</p><p>To mark each vertex of a polygon with a randomly colored filled circle:</p><pre><code class="nohighlight hljs">p = star(O, 70, 7, 0.6, 0, vertices=true)
prettypoly(p, action=:fill, () -&gt;
    begin
        randomhue()
        circle(O, 10, :fill)
    end,
    close=true)</code></pre><p>The optional keyword argument <code>vertexlabels</code> lets you supply a function with two arguments that can access the current vertex number and the total number of vertices at each vertex. For example, you can label the vertices of a triangle &quot;1 of 3&quot;, &quot;2 of 3&quot;, and &quot;3 of 3&quot; using:</p><pre><code class="nohighlight hljs">prettypoly(triangle, action=:stroke,
    vertexlabels = (n, l) -&gt; (text(string(n, &quot; of &quot;, l))))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L282-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.preview-Tuple{}" href="#Luxor.preview-Tuple{}"><code>Luxor.preview</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">preview()</code></pre><p>If working in a notebook (eg Jupyter/IJulia), display a PNG or SVG file in the notebook.</p><p>If working in Juno, display a PNG or SVG file in the Plot pane.</p><p>Drawings of type :image should be converted to a matrix with <code>image_as_matrix()</code> before calling <code>finish()</code>.</p><p>Otherwise:</p><ul><li>on macOS, open the file in the default application, which is probably the Preview.app for PNG and PDF, and Safari for SVG</li><li>on Unix, open the file with <code>xdg-open</code></li><li>on Windows, refer to <code>COMSPEC</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/drawings.jl#L509-L525">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.randomcolor-Tuple{}" href="#Luxor.randomcolor-Tuple{}"><code>Luxor.randomcolor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">randomcolor()</code></pre><p>Set a random color. This may change the current alpha opacity too.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/colors_styles.jl#L213-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.randomhue-Tuple{}" href="#Luxor.randomhue-Tuple{}"><code>Luxor.randomhue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">randomhue()</code></pre><p>Set a random hue, without changing the current alpha opacity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/colors_styles.jl#L202-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.randompoint-NTuple{4, Any}" href="#Luxor.randompoint-NTuple{4, Any}"><code>Luxor.randompoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">randompoint(lowx, lowy, highx, highy)</code></pre><p>Return a random point somewhere inside a rectangle defined by the four values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/randompoints.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.randompoint-Tuple{Point, Point}" href="#Luxor.randompoint-Tuple{Point, Point}"><code>Luxor.randompoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">randompoint(lowpt, highpt)</code></pre><p>Return a random point somewhere inside the rectangle defined by the two points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/randompoints.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.randompointarray-NTuple{5, Any}" href="#Luxor.randompointarray-NTuple{5, Any}"><code>Luxor.randompointarray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">randompointarray(lowx, lowy, highx, highy, n)</code></pre><p>Return an array of <code>n</code> random points somewhere inside the rectangle defined by the four coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/randompoints.jl#L39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.randompointarray-Tuple{Any, Any, Any}" href="#Luxor.randompointarray-Tuple{Any, Any, Any}"><code>Luxor.randompointarray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">randompointarray(w, h, d; attempts=20)</code></pre><p>Return an array of randomly positioned points inside the rectangle defined by the current origin (0/0) and the <code>width</code> and <code>height</code>. <code>d</code> determines the minimum distance between each point. Increase <code>attempts</code> if you want the function to try harder to fill empty spaces; decrease it if it&#39;s taking too long to look for samples that work.</p><p>This uses Bridson&#39;s Poisson Disk Sampling algorithm: https://www.cs.ubc.ca/~rbridson/docs/bridson-siggraph07-poissondisk.pdf</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">for pt in randompointarray(BoundingBox(), 20)
    randomhue()
    circle(pt, 10, :fill)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/randompoints.jl#L92-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.randompointarray-Tuple{BoundingBox, Any}" href="#Luxor.randompointarray-Tuple{BoundingBox, Any}"><code>Luxor.randompointarray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">randompointarray(bbox::BoundingBox, d; attempts=20)</code></pre><p>Return an array of randomly positioned points inside the bounding box <code>d</code> units apart.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/randompoints.jl#L147-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.randompointarray-Tuple{Point, Point, Any}" href="#Luxor.randompointarray-Tuple{Point, Point, Any}"><code>Luxor.randompointarray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">randompointarray(lowpt, highpt, n)</code></pre><p>Return an array of <code>n</code> random points somewhere inside the rectangle defined by two points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/randompoints.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.readpng-Tuple{Any}" href="#Luxor.readpng-Tuple{Any}"><code>Luxor.readpng</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readpng(pathname)</code></pre><p>Read a PNG file.</p><p>This returns a image object suitable for placing on the current drawing with <code>placeimage()</code>. You can access its <code>width</code> and <code>height</code> fields:</p><pre><code class="nohighlight hljs">image = readpng(&quot;test-image.png&quot;)
w = image.width
h = image.height</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/images.jl#L5-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.readsvg-Tuple{Any}" href="#Luxor.readsvg-Tuple{Any}"><code>Luxor.readsvg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readsvg(str)</code></pre><p>Read an SVG image. <code>str</code> is either pathname or pure SVG code. This returns an SVG image object suitable for placing on the current drawing with <code>placeimage()</code>.</p><p>Placing an SVG file:</p><pre><code class="nohighlight hljs">@draw begin
    mycoollogo = readsvg(&quot;mylogo.svg&quot;)
    placeimage(mycoollogo)
end</code></pre><p>Placing SVG code:</p><pre><code class="nohighlight hljs"># from https://github.com/edent/SuperTinyIcons
julialogocode = &quot;&quot;&quot;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;
    aria-label=&quot;Julia&quot; role=&quot;img&quot;
    viewBox=&quot;0 0 512 512&quot;&gt;
    &lt;rect width=&quot;512&quot; height=&quot;512&quot; rx=&quot;15%&quot; fill=&quot;#fff&quot;/&gt;
    &lt;circle fill=&quot;#389826&quot; cx=&quot;256&quot; cy=&quot;137&quot; r=&quot;83&quot;/&gt;
    &lt;circle fill=&quot;#cb3c33&quot; cx=&quot;145&quot; cy=&quot;329&quot; r=&quot;83&quot;/&gt;
    &lt;circle fill=&quot;#9558b2&quot; cx=&quot;367&quot; cy=&quot;329&quot; r=&quot;83&quot;/&gt;
&lt;/svg&gt;&quot;&quot;&quot;

@draw begin
    julia_logo = readsvg(julialogocode)
    placeimage(julia_logo, centered=true)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/images.jl#L114-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.rect-NTuple{4, Real}" href="#Luxor.rect-NTuple{4, Real}"><code>Luxor.rect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rect(xmin, ymin, w, h; action=:none)
rect(xmin, ymin, w, h, action)</code></pre><p>Create a rectangle with one corner at (<code>xmin</code>/<code>ymin</code>) with width <code>w</code> and height <code>h</code>, and add it to the current path. Then apply <code>action</code>.</p><p>Returns a tuple of two points, the corners of a bounding box that encloses the rectangle.</p><p>See <code>box()</code> for more ways to do similar things, such as supplying two opposite corners, placing by centerpoint and dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/shapes.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.rect-Tuple{Point, Real, Real}" href="#Luxor.rect-Tuple{Point, Real, Real}"><code>Luxor.rect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rect(cornerpoint, w, h; action = none, reversepath=false,
    vertices=false)
rect(cornerpoint, w, h, action; reversepath=false,
    vertices=false)</code></pre><p>Create a rectangle with one corner at <code>cornerpoint</code> with width <code>w</code> and height <code>h</code>, and add it to the current path. Then apply <code>action</code>.</p><p>Use <code>vertices=true</code> to return an array of the four corner points: bottom left, top left, top right, bottom right.</p><p><code>reversepath</code> reverses the direction of the path (and returns points in the order: bottom left, bottom right, top right, top left).</p><p>Returns the four corner vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/shapes.jl#L28-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.rescale" href="#Luxor.rescale"><code>Luxor.rescale</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rescale(x, from_min, from_max, to_min=0.0, to_max=1.0)</code></pre><p>Convert <code>x</code> from one linear scale (<code>from_min</code> to <code>from_max</code>) to another (<code>to_min</code> to <code>to_max</code>).</p><p>The scales can also be supplied in tuple form:</p><pre><code class="nohighlight hljs">rescale(x, (from_min, from_max), (to_min, to_max))</code></pre><pre><code class="nohighlight hljs">using Luxor
julia&gt; rescale(15, 0, 100, 0, 1)
0.15

julia&gt; rescale(15, (0, 100), (0, 1))
0.15

julia&gt; rescale(pi/20, 0, 2pi, 0, 1)
0.025

julia&gt; rescale(pi/20, (0, 2pi), (0, 1))
0.025

julia&gt; rescale(25, 0, 1, 0, 1.609344)
40.2336

julia&gt; rescale(15, (0, 100), (1000, 0))
850.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L29-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.rline-Tuple{Any, Any}" href="#Luxor.rline-Tuple{Any, Any}"><code>Luxor.rline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rline(pt)</code></pre><p>Draw a line relative to the current position to the <code>pt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L389-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.rmove-Tuple{Any, Any}" href="#Luxor.rmove-Tuple{Any, Any}"><code>Luxor.rmove</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rmove(pt)</code></pre><p>Move relative to current position by the <code>pt</code>&#39;s x and y:</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L358-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.rotate-Tuple{Any}" href="#Luxor.rotate-Tuple{Any}"><code>Luxor.rotate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate(a::Float64)</code></pre><p>Rotate workspace by <code>a</code> radians clockwise (from positive x-axis to positive y-axis).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L552-L556">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.rotate_point_around_point-Tuple{Any, Any, Any}" href="#Luxor.rotate_point_around_point-Tuple{Any, Any, Any}"><code>Luxor.rotate_point_around_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate_point_around_point(targetpt, pt, angle)</code></pre><p>Rotate a target point around another point by an angle specified in radians. Returns the new point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L610-L615">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.rotationmatrix-Tuple{Any}" href="#Luxor.rotationmatrix-Tuple{Any}"><code>Luxor.rotationmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotationmatrix(a)</code></pre><p>Return a 3x3 Julia matrix that will apply a rotation through <code>a</code> radians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/matrix.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.rule" href="#Luxor.rule"><code>Luxor.rule</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rule(pos, theta;
    boundingbox=BoundingBox(),
    vertices=false)</code></pre><p>Draw a straight line through <code>pos</code> at an angle <code>theta</code> from the x axis.</p><p>By default, the line spans the entire drawing, but you can supply a BoundingBox to change the extent of the line.</p><pre><code class="nohighlight hljs">rule(O)       # draws an x axis
rule(O, pi/2) # draws a  y axis</code></pre><p>The function:</p><pre><code class="nohighlight hljs">rule(O, pi/2, boundingbox=BoundingBox()/2)</code></pre><p>draws a line that spans a bounding box half the width and height of the drawing, and returns a Set of end points. If you just want the vertices and don&#39;t want to draw anything, use <code>vertices=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L397-L419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.rulers-Tuple{}" href="#Luxor.rulers-Tuple{}"><code>Luxor.rulers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rulers()</code></pre><p>Draw and label two rulers starting at <code>O</code>, the current 0/0, and continuing out along the current positive x and y axes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L617-L622">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.scale-Tuple{Real, Real}" href="#Luxor.scale-Tuple{Real, Real}"><code>Luxor.scale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scale(x, y)</code></pre><p>Scale workspace by <code>x</code> and <code>y</code>.</p><p>Example:</p><pre><code class="nohighlight hljs">scale(0.2, 0.3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L531-L542">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.scale-Tuple{Real}" href="#Luxor.scale-Tuple{Real}"><code>Luxor.scale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scale(f)</code></pre><p>Scale workspace by <code>f</code> in both <code>x</code> and <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L545-L549">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.scalingmatrix-Tuple{Any, Any}" href="#Luxor.scalingmatrix-Tuple{Any, Any}"><code>Luxor.scalingmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scalingmatrix(sx, sy)</code></pre><p>Return a 3x3 Julia matrix that will apply a scaling by <code>sx</code> and <code>sy</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/matrix.jl#L143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.sector-NTuple{4, Real}" href="#Luxor.sector-NTuple{4, Real}"><code>Luxor.sector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sector(innerradius::Real, outerradius::Real, startangle::Real, endangle::Real;
   action=:none)</code></pre><p>Make an annular sector centered at the origin, and add it to the current path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L312-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.sector-Tuple{Point, Real, Real, Real, Real, Real}" href="#Luxor.sector-Tuple{Point, Real, Real, Real, Real, Real}"><code>Luxor.sector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sector(centerpoint::Point, innerradius, outerradius,
        startangle, endangle, cornerradius;
       action:none)</code></pre><p>Make an annular sector with rounded corners, basically a bent sausage shape, centered at <code>centerpoint</code>, and add it to the current path.</p><p>TODO: The results aren&#39;t 100% accurate at the moment. There are small discontinuities where the curves join.</p><p>TODO - return something more useful than a Boolean</p><p>The cornerradius is reduced from the supplied value if neceesary to prevent overshoots.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L325-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.sector-Tuple{Point, Real, Real, Real, Real}" href="#Luxor.sector-Tuple{Point, Real, Real, Real, Real}"><code>Luxor.sector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sector(centerpoint::Point, innerradius, outerradius, startangle, endangle;
    action=:none)</code></pre><p>Make an annular sector centered at <code>centerpoint</code>, and add it to the current path.</p><p>TODO - return something more useful than a Boolean</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L283-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.sector-Tuple{Real, Real, Real, Real, Real, Symbol}" href="#Luxor.sector-Tuple{Real, Real, Real, Real, Real, Symbol}"><code>Luxor.sector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sector(innerradius::Real, outerradius::Real, startangle::Real, endangle::Real,
   cornerradius::Real, action)</code></pre><p>Make an annular sector with rounded corners, centered at the current origin, and add it to the current path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L413-L419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setantialias-Tuple{Any}" href="#Luxor.setantialias-Tuple{Any}"><code>Luxor.setantialias</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setantialias(n)</code></pre><p>Set the current antialiasing to a value between 0 and 6:</p><pre><code class="nohighlight hljs">antialias_default  = 0, the default antialiasing for the subsystem and target device
antialias_none     = 1, use a bilevel alpha mask
antialias_gray     = 2, use single-color antialiasing (using shades of gray for black text on a white background, for example)
antialias_subpixel = 3, take advantage of the order of subpixel elements on devices such as LCD panels
antialias_fast     = 4, perform some antialiasing but prefer speed over quality
antialias_good     = 5, balance quality against performance
antialias_best     = 6, render at the highest quality, sacrificing speed if necessary</code></pre><p>This affects subsequent graphics, but not text, and it doesn&#39;t apply to all types of output file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L117-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setbezierhandles-Tuple{BezierPathSegment}" href="#Luxor.setbezierhandles-Tuple{BezierPathSegment}"><code>Luxor.setbezierhandles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setbezierhandles(bps::BezierPathSegment;
        angles  = [0.05, -0.1],
        handles = [0.3, 0.3])</code></pre><p>Return a new BezierPathSegment with new locations for the Bezier control points in the BezierPathSegment <code>bps</code>.</p><p><code>angles</code> are the two angles that the &quot;handles&quot; make with the line direciton.</p><p><code>handles</code> are the lengths of the &quot;handles&quot;. 0.3 is a typical value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/bezierpath.jl#L529-L540">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setbezierhandles-Tuple{BezierPath}" href="#Luxor.setbezierhandles-Tuple{BezierPath}"><code>Luxor.setbezierhandles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setbezierhandles(bezpath::BezierPath;
    angles=[0 .05, -0.1],
    handles=[0.3, 0.3])</code></pre><p>Return a new BezierPath with new locations for the Bézier control points in every Bézier path segment of the BezierPath in <code>bezpath</code>.</p><p><code>angles</code> are the two angles that the &quot;handles&quot; make with the line direciton.</p><p><code>handles</code> are the lengths of the &quot;handles&quot;. 0.3 is a typical value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/bezierpath.jl#L552-L563">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setblend-Tuple{Cairo.CairoPattern}" href="#Luxor.setblend-Tuple{Cairo.CairoPattern}"><code>Luxor.setblend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setblend(blend)</code></pre><p>Start using the named blend for filling graphics.</p><p>This aligns the original coordinates of the blend definition with the current axes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/blends.jl#L110-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setblendextend-Tuple{Cairo.CairoPattern, Any}" href="#Luxor.setblendextend-Tuple{Cairo.CairoPattern, Any}"><code>Luxor.setblendextend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setblendextend(blend::Blend, mode)</code></pre><p>Specify how color blend patterns are repeated/extended. Supply the blend and one of the following strings:</p><ul><li><p>&quot;repeat&quot;:  the pattern is repeated</p></li><li><p>&quot;reflect&quot;: the pattern is reflected (repeated in reverse)</p></li><li><p>&quot;pad&quot;: outside the pattern, use the closest color</p></li><li><p>&quot;none&quot;: outside of the pattern, use transparent pixels</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/blends.jl#L175-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setcolor-Tuple{AbstractString}" href="#Luxor.setcolor-Tuple{AbstractString}"><code>Luxor.setcolor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setcolor(&quot;gold&quot;)
setcolor(&quot;darkturquoise&quot;)</code></pre><p>Set the current color to a named color. This use the definitions in Colors.jl to convert a string to RGBA eg <code>setcolor(&quot;gold&quot;)</code> or &quot;green&quot;, &quot;darkturquoise&quot;, &quot;lavender&quot;, etc. The list is at <code>Colors.color_names</code>.</p><p>Use <code>sethue()</code> for changing colors without changing current opacity level.</p><p><code>sethue()</code> and <code>setcolor()</code> return the three or four values that were used:</p><pre><code class="nohighlight hljs">julia&gt; setcolor(sethue(&quot;red&quot;)..., .8)

(1.0, 0.0, 0.0, 0.8)

julia&gt; sethue(setcolor(&quot;red&quot;)[1:3]...)

(1.0, 0.0, 0.0)</code></pre><p>You can also do:</p><pre><code class="nohighlight hljs">using Colors
sethue(colorant&quot;red&quot;)</code></pre><p>See also <a href="#Luxor.setcolor-Tuple{AbstractString}"><code>setcolor</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/colors_styles.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setcolor-Tuple{ColorTypes.Colorant}" href="#Luxor.setcolor-Tuple{ColorTypes.Colorant}"><code>Luxor.setcolor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setcolor(r, g, b)
setcolor(r, g, b, alpha)
setcolor(color)
setcolor(col::Colors.Colorant)
setcolor(sethue(&quot;red&quot;)..., .2)</code></pre><p>Set the current color.</p><p>Examples:</p><pre><code class="nohighlight hljs">setcolor(convert(Colors.HSV, Colors.RGB(0.5, 1, 1)))
setcolor(.2, .3, .4, .5)
setcolor(convert(Colors.HSV, Colors.RGB(0.5, 1, 1)))

for i in 1:15:360
   setcolor(convert(Colors.RGB, Colors.HSV(i, 1, 1)))
   ...
end</code></pre><p>See also <a href="#Luxor.sethue-Tuple{AbstractString}"><code>sethue</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/colors_styles.jl#L40-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setcolor-Tuple{NTuple{4, Number}}" href="#Luxor.setcolor-Tuple{NTuple{4, Number}}"><code>Luxor.setcolor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setcolor((r, g, b, a))</code></pre><p>Set the color to the tuple&#39;s values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/colors_styles.jl#L172-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setcolor-Tuple{Tuple{Number, Number, Number}}" href="#Luxor.setcolor-Tuple{Tuple{Number, Number, Number}}"><code>Luxor.setcolor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setcolor((r, g, b))</code></pre><p>Set the color to the tuple&#39;s values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/colors_styles.jl#L165-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setdash" href="#Luxor.setdash"><code>Luxor.setdash</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setdash(dashes::Vector, offset=0.0)</code></pre><p>Set the dash pattern to the values in <code>dashes</code>. The first number is the length of the ink, the second the gap, and so on.</p><p>The <code>offset</code> specifies an offset into the pattern at which the stroke begins. So an offset of 10 means that the stroke starts at <code>dashes[1] + 10</code> into the pattern.</p><p>Or use <code>setdash(&quot;dot&quot;)</code> etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L319-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setdash-Tuple{AbstractString}" href="#Luxor.setdash-Tuple{AbstractString}"><code>Luxor.setdash</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setdash(&quot;dot&quot;)</code></pre><p>Set the dash pattern to one of: &quot;solid&quot;, &quot;dotted&quot;, &quot;dot&quot;, &quot;dotdashed&quot;, &quot;longdashed&quot;, &quot;shortdashed&quot;, &quot;dash&quot;, &quot;dashed&quot;, &quot;dotdotdashed&quot;, &quot;dotdotdotdashed&quot;.</p><p>Use <code>setdash(dashes::Vector)</code> to specify the pattern numerically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L306-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setfont-Tuple{AbstractString, Any}" href="#Luxor.setfont-Tuple{AbstractString, Any}"><code>Luxor.setfont</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setfont(family, fontsize)</code></pre><p>Select a font and specify the size.</p><p>Example:</p><pre><code class="nohighlight hljs">setfont(&quot;Helvetica&quot;, 24)
settext(&quot;Hello in Helvetica 24 using the Pro API&quot;, Point(0, 10))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/text.jl#L407-L416">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setgray-Tuple{Any}" href="#Luxor.setgray-Tuple{Any}"><code>Luxor.setgray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setgray(n)
setgrey(n)</code></pre><p>Set the color to a gray level of <code>n</code>, where <code>n</code> is between 0 and 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/colors_styles.jl#L193-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.sethue-Tuple{AbstractString}" href="#Luxor.sethue-Tuple{AbstractString}"><code>Luxor.sethue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sethue(&quot;black&quot;)
sethue(0.3, 0.7, 0.9)
setcolor(sethue(&quot;red&quot;)..., .2)</code></pre><p>Set the color without changing opacity.</p><p><code>sethue()</code> is like <code>setcolor()</code>, but we sometimes want to change the current color without changing alpha/opacity. Using <code>sethue()</code> rather than <code>setcolor()</code> doesn&#39;t change the current alpha opacity.</p><p>See also <a href="#Luxor.setcolor-Tuple{AbstractString}"><code>setcolor</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/colors_styles.jl#L97-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.sethue-Tuple{Any, Any, Any}" href="#Luxor.sethue-Tuple{Any, Any, Any}"><code>Luxor.sethue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sethue(0.3, 0.7, 0.9)</code></pre><p>Set the color&#39;s <code>r</code>, <code>g</code>, <code>b</code> values. Use <code>setcolor(r, g, b, a)</code> to set transparent colors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/colors_styles.jl#L137-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.sethue-Tuple{ColorTypes.Colorant}" href="#Luxor.sethue-Tuple{ColorTypes.Colorant}"><code>Luxor.sethue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sethue(col::Colors.Colorant)</code></pre><p>Set the color without changing the current alpha/opacity:</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/colors_styles.jl#L122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.sethue-Tuple{NTuple{4, Number}}" href="#Luxor.sethue-Tuple{NTuple{4, Number}}"><code>Luxor.sethue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sethue((r, g, b, a))</code></pre><p>Set the color to the tuple&#39;s values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/colors_styles.jl#L158-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.sethue-Tuple{Tuple{Number, Number, Number}}" href="#Luxor.sethue-Tuple{Tuple{Number, Number, Number}}"><code>Luxor.sethue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sethue((r, g, b))</code></pre><p>Set the color to the tuple&#39;s values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/colors_styles.jl#L151-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setline-Tuple{Any}" href="#Luxor.setline-Tuple{Any}"><code>Luxor.setline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setline(n)</code></pre><p>Set the line width, in points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L256-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setlinecap" href="#Luxor.setlinecap"><code>Luxor.setlinecap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setlinecap(s)</code></pre><p>Set the line ends. <code>s</code> can be &quot;butt&quot; or <code>:butt</code> (the default), &quot;square&quot; or <code>:square</code>, or &quot;round&quot; or <code>:round</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L263-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setlinejoin" href="#Luxor.setlinejoin"><code>Luxor.setlinejoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setlinejoin(&quot;miter&quot;)
setlinejoin(&quot;round&quot;)
setlinejoin(&quot;bevel&quot;)</code></pre><p>Set the line join style, or how to render the junction of two lines when stroking.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L289-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setmatrix-Tuple{Array}" href="#Luxor.setmatrix-Tuple{Array}"><code>Luxor.setmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setmatrix(m::Array)</code></pre><p>Change the current matrix to matrix <code>m</code>. Use <code>getmatrix()</code> to get the current matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/matrix.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setmesh-Tuple{Cairo.CairoPattern}" href="#Luxor.setmesh-Tuple{Cairo.CairoPattern}"><code>Luxor.setmesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setmesh(mesh::Mesh)</code></pre><p>Select a mesh, previously created with <code>mesh()</code>, for filling and stroking subsequent graphics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/mesh.jl#L158-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setmode-Tuple{AbstractString}" href="#Luxor.setmode-Tuple{AbstractString}"><code>Luxor.setmode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setmode(mode::AbstractString)</code></pre><p>Set the compositing/blending mode. <code>mode</code> can be one of:</p><ul><li><code>&quot;clear&quot;</code> Where the second object is drawn, the first is completely removed.</li><li><code>&quot;source&quot;</code> The second object is drawn as if nothing else were below.</li><li><code>&quot;over&quot;</code> The default mode: like two transparent slides overlapping.</li><li><code>&quot;in&quot;</code> The first object is removed completely, the second is only drawn where the first was.</li><li><code>&quot;out&quot;</code> The second object is drawn only where the first one wasn&#39;t.</li><li><code>&quot;atop&quot;</code> The first object is mostly intact, but mixes both objects in the overlapping area. The second object object is not drawn elsewhere.</li><li><code>&quot;dest&quot;</code> Discard the second object completely.</li><li><code>&quot;dest_over&quot;</code> Like &quot;over&quot; but draw second object below the first</li><li><code>&quot;dest_in&quot;</code> Keep the first object whereever the second one overlaps.</li><li><code>&quot;dest_out&quot;</code> The second object is used to reduce the visibility of the first where they overlap.</li><li><code>&quot;dest_atop&quot;</code> Like &quot;over&quot; but draw second object below the first.</li><li><code>&quot;xor&quot;</code> XOR where the objects overlap</li><li><code>&quot;add&quot;</code> Add the overlapping areas together</li><li><code>&quot;saturate&quot;</code> Increase Saturation where objects overlap</li><li><code>&quot;multiply&quot;</code> Multiply where objects overlap</li><li><code>&quot;screen&quot;</code> Input colors are complemented and multiplied, the product is complemented again. The result is at least as light as the lighter of the input colors.</li><li><code>&quot;overlay&quot;</code> Multiplies or screens colors, depending on the lightness of the destination color.</li><li><code>&quot;darken&quot;</code> Selects the darker of the color values in each component.</li><li><code>&quot;lighten&quot;</code> Selects the lighter of the color values in each component.</li></ul><p>See the <a href="https://www.cairographics.org/operators/">Cairo documentation</a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/colors_styles.jl#L235-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setopacity-Tuple{Any}" href="#Luxor.setopacity-Tuple{Any}"><code>Luxor.setopacity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setopacity(alpha)</code></pre><p>Set the current opacity to a value between 0 and 1. This modifies the alpha value of the current color.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/colors_styles.jl#L179-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setstrokescale-Tuple{Bool}" href="#Luxor.setstrokescale-Tuple{Bool}"><code>Luxor.setstrokescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setstrokescale(state::Bool)</code></pre><p>Enable/disable stroke scaling for the current drawing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L342-L346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setstrokescale-Tuple{}" href="#Luxor.setstrokescale-Tuple{}"><code>Luxor.setstrokescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setstrokescale()</code></pre><p>Return the current stroke scaling setting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L334-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.settext-Tuple{AbstractString, Point}" href="#Luxor.settext-Tuple{AbstractString, Point}"><code>Luxor.settext</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">settext(text, pos;
    halign = &quot;left&quot;,
    valign = &quot;bottom&quot;,
    angle  = 0, # degrees!
    markup = false)

settext(text;
    kwargs)</code></pre><p>Draw the <code>text</code> at <code>pos</code> (if omitted defaults to <code>0/0</code>). If no font is specified, on macOS the default font is Times Roman.</p><p>To align the text, use <code>halign</code>, one of &quot;left&quot;, &quot;center&quot;, or &quot;right&quot;, and <code>valign</code>, one of &quot;top&quot;, &quot;center&quot;, or &quot;bottom&quot;.</p><p><code>angle</code> is the rotation - in counterclockwise degrees, rather than Luxor&#39;s default clockwise (+x-axis to +y-axis) radians.</p><p>If <code>markup</code> is <code>true</code>, then the string can contain some HTML-style markup. Supported tags include:</p><pre><code class="nohighlight hljs">&lt;b&gt;, &lt;i&gt;, &lt;s&gt;, &lt;sub&gt;, &lt;sup&gt;, &lt;small&gt;, &lt;big&gt;, &lt;u&gt;, &lt;tt&gt;, and &lt;span&gt;</code></pre><p>The <code>&lt;span&gt;</code> tag can contains things like this:</p><pre><code class="nohighlight hljs">&lt;span font=&#39;26&#39; background=&#39;green&#39; foreground=&#39;red&#39;&gt;unreadable text&lt;/span&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/text.jl#L424-L451">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.shiftbezierhandles-Tuple{BezierPathSegment}" href="#Luxor.shiftbezierhandles-Tuple{BezierPathSegment}"><code>Luxor.shiftbezierhandles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shiftbezierhandles(bps::BezierPathSegment;
    angles=[0.1, -0.1],
    handles=[1.1, 1.1])</code></pre><p>Return a new BezierPathSegment that modifies the Bézier path in <code>bps</code> by moving the control handles. The values in <code>angles</code> increase the angle of the handles; the values in <code>handles</code> modifies the lengths: 1 preserves the length, 0.5 halves the length of the  handles, 2 doubles them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/bezierpath.jl#L574-L583">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.simplify" href="#Luxor.simplify"><code>Luxor.simplify</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Simplify a polygon:</p><pre><code class="nohighlight hljs">simplify(pointlist::Array, detail=0.1)</code></pre><p><code>detail</code> is the maximum approximation error of simplified polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/polygons.jl#L167-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.slope-Tuple{Any, Any}" href="#Luxor.slope-Tuple{Any, Any}"><code>Luxor.slope</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">slope(pointA::Point, pointB::Point)</code></pre><p>Find angle of a line starting at <code>pointA</code> and ending at <code>pointB</code>.</p><p>Return a value between 0 and 2pi. Value will be relative to the current axes.</p><pre><code class="nohighlight hljs">slope(O, Point(0, 100)) |&gt; rad2deg # y is positive down the page
90.0

slope(Point(0, 100), O) |&gt; rad2deg
270.0</code></pre><p>The slope isn&#39;t the same as the gradient. A vertical line going up has a slope of 3π/2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L306-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.snapshot-Tuple{}" href="#Luxor.snapshot-Tuple{}"><code>Luxor.snapshot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">snapshot(;
    fname = :png,
    cb = missing,
    scalefactor = 1.0)

snapshot(fname, cb, scalefactor)
-&gt; finished snapshot drawing, for display</code></pre><p>Take a snapshot and save to &#39;fname&#39; name and suffix. This requires that the current drawing is a recording surface. You can continue drawing on the same recording surface.</p><p><strong>Arguments</strong></p><p><code>fname</code> the file name or symbol, see <a href="#Luxor.Drawing"><code>Drawing</code></a></p><p><code>cb</code> crop box::BoundingBox - what&#39;s inside is copied to snapshot</p><p><code>scalefactor</code> snapshot width/crop box width. Same for height.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">snapshot()
snapshot(fname = &quot;temp.png&quot;)
snaphot(fname = :svg)
cb = BoundingBox(Point(0, 0), Point(102.4, 96))
snapshot(cb = cb)
pngdrawing = snapshot(fname = &quot;temp.png&quot;, cb = cb, scalefactor = 10)</code></pre><p>The last example would return and also write a png drawing with 1024 x 960 pixels to storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/drawings.jl#L385-L418">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.spiral-Tuple{Any, Any}" href="#Luxor.spiral-Tuple{Any, Any}"><code>Luxor.spiral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spiral(a, b;
    action = :none,
    stepby = 0.01,
    period = 4pi,
    vertices = false,
    log =false)
spiral(a, b, action;
    stepby = 0.01,
    period = 4pi,
    vertices = false,
    log =false)</code></pre><p>Make a spiral, and add it to the current path. The two primary parameters <code>a</code> and <code>b</code> determine the start radius, and the tightness.</p><p>For linear spirals (<code>log=false</code>), <code>b</code> values are:</p><pre><code class="nohighlight hljs">lituus: -2

hyperbolic spiral: -1

Archimedes&#39; spiral: 1

Fermat&#39;s spiral: 2</code></pre><p>For logarithmic spirals (<code>log=true</code>):</p><pre><code class="nohighlight hljs">golden spiral: b = ln(phi)/ (pi/2) (about 0.30)</code></pre><p>Values of <code>b</code> around 0.1 produce tighter, staircase-like spirals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L778-L810">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.splitbezier-Tuple{BezierPathSegment, Any}" href="#Luxor.splitbezier-Tuple{BezierPathSegment, Any}"><code>Luxor.splitbezier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splitbezier(bps::BezierPathSegment, t)</code></pre><p>Split the Bezier path segment at t, where t is between 0 and 1.</p><p>Use Paul de Casteljaus&#39; algorithm (the man who really introduced Bezier curves...).</p><p>Returns a tuple of two BezierPathSegments, the &#39;lower&#39; one (0 to <code>t</code>) followed by the &#39;higher&#39; one (<code>t</code> to 1).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">bps = BezierPathSegment(ngon(O, 200, 4, vertices=true)...)
l, h = splitbezier(bps::BezierPathSegment, 0.5)

julia&gt; l
4-element BezierPathSegment:
 Point(1.2246467991473532e-14, 200.0)
 Point(-100.0, 100.00000000000001)
 Point(-100.0, 1.4210854715202004e-14)
 Point(-50.00000000000001, -49.99999999999999)

julia&gt; h
4-element BezierPathSegment:
 Point(-50.00000000000001, -49.99999999999999)
 Point(-1.4210854715202004e-14, -100.0)
 Point(99.99999999999999, -100.00000000000003)
 Point(200.0, -4.898587196589413e-14)</code></pre><p>julia&gt; l.p2 == h.p1 true</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/bezierpath.jl#L721-L755">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.splittext-Tuple{Any}" href="#Luxor.splittext-Tuple{Any}"><code>Luxor.splittext</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splittext(s)</code></pre><p>Split the text in string <code>s</code> into an array, but keep all the separators attached to the preceding word.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/text.jl#L557-L562">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.squircle-Tuple{Point, Real, Real}" href="#Luxor.squircle-Tuple{Point, Real, Real}"><code>Luxor.squircle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">squircle(center::Point, hradius, vradius;
    action=:none,
    rt = 0.5, stepby = pi/40, vertices=false)
squircle(center::Point, hradius, vradius, action;
    rt = 0.5, stepby = pi/40, vertices=false)</code></pre><p>Make a squircle or superellipse (basically a rectangle with rounded corners), and add it to the current path. Specify the center position, horizontal radius (distance from center to a side), and vertical radius (distance from center to top or bottom):</p><p>The root (<code>rt</code>) option defaults to 0.5, and gives an intermediate shape. Values less than 0.5 make the shape more rectangular. Values above make the shape more round. The horizontal and vertical radii can be different.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/curves.jl#L127-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.star" href="#Luxor.star"><code>Luxor.star</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">star(center, radius, npoints, ratio=0.5, orientation, action=:none;
    vertices = false, reversepath=false)
star(center, radius, npoints, ratio=0.5, orientation=0.0;
    action=:none, vertices = false, reversepath=false)</code></pre><p>Make a star centered at <code>center</code> with <code>npoints</code> sections oriented by <code>orientation</code>. <code>ratio</code> specifies the height of the smaller radius of the star relative to the larger.</p><p>Returns the vertices of the star.</p><p>Use <code>vertices=true</code> to only return the vertices of a star instead of making it.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">star(O, 120, 5, 0.5, 0.0, :fill,
    vertices = false,
    reversepath=false)

star(O, 220, 5, 0.5;
    action=:stroke,
    vertices = false,
    reversepath=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/shapes.jl#L422-L449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.storepath-Tuple{}" href="#Luxor.storepath-Tuple{}"><code>Luxor.storepath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">storepath()</code></pre><p>Obtain the current Cairo path and make a Luxor Path object, which is an array of PathElements.</p><p>Returns the Path object.</p><p>See also getpath() and getpathflat().</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Path.jl#L102-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.strokepath-Tuple{}" href="#Luxor.strokepath-Tuple{}"><code>Luxor.strokepath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">strokepath()</code></pre><p>Stroke the current path with the current line width, line join, line cap, dash, and stroke scaling settings. The current path is then cleared.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L157-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.strokepreserve-Tuple{}" href="#Luxor.strokepreserve-Tuple{}"><code>Luxor.strokepreserve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">strokepreserve()</code></pre><p>Stroke the current path with current line width, line join, line cap, dash, and stroke scaling settings, but then keep the path current.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L179-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.svgstring-Tuple{}" href="#Luxor.svgstring-Tuple{}"><code>Luxor.svgstring</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">svgstring()</code></pre><p>Return the current and recently completed SVG drawing as a string of SVG commands.</p><p>Returns <code>&quot;&quot;</code> if there is no SVG information available.</p><p>To display the SVG string as a graphic, try the <code>HTML()</code> function in Base.</p><pre><code class="nohighlight hljs">...
HTML(svgstring())</code></pre><p>In a Pluto notebook, you can also display the SVG using:</p><pre><code class="nohighlight hljs"># using PlutoUI
...
PlutoUI.Show(MIME&quot;image/svg+xml&quot;(), svgstring())</code></pre><p>(This lets you right-click to save the SVG.)</p><p><strong>Example</strong></p><p>This example manipulates the raw SVG code representing the Julia logo:</p><pre><code class="nohighlight hljs">Drawing(500, 500, :svg)
origin()
julialogo()
finish()
s = svgstring()
eachmatch(r&quot;rgb.*?;&quot;, s) |&gt; collect
    6-element Vector{RegexMatch}:
    RegexMatch(&quot;rgb(100%,100%,100%);&quot;)
    RegexMatch(&quot;rgb(0%,0%,0%);&quot;)
    RegexMatch(&quot;rgb(79.6%,23.5%,20%);&quot;)
    RegexMatch(&quot;rgb(25.1%,38.8%,84.7%);&quot;)
    RegexMatch(&quot;rgb(58.4%,34.5%,69.8%);&quot;)
    RegexMatch(&quot;rgb(22%,59.6%,14.9%);&quot;)</code></pre><pre><code class="nohighlight hljs">@drawsvg begin
    background(&quot;midnightblue&quot;)
    fontface(&quot;JuliaMono-Regular&quot;)
    fontsize(20)
    sethue(&quot;gold&quot;)
    text(&quot;JuliaMono: a monospaced font &quot;, halign=:center)
    text(&quot;with reasonable Unicode support&quot;, O + (0, 22), halign=:center)
end 500 150
write(&quot;txt.svg&quot;, svgstring())
# minimize SVG
run(`svgo txt.svg -o txt-min.svg`)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/drawings.jl#L1063-L1120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.text-Tuple{Any, Point}" href="#Luxor.text-Tuple{Any, Point}"><code>Luxor.text</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">text(str)
text(str, pos)
text(str, pos, angle = pi/2)
text(str, x, y)
text(str, pos, halign = :left)
text(str, valign = :baseline)
text(str, valign = :baseline, halign = :left)
text(str, pos, valign = :baseline, halign = :left)
text(latexstr, pos, valign = :baseline, halign = :left, rotationfixed = false, angle = 0)</code></pre><p>Draw the text in the string <code>str</code> at <code>x</code>/<code>y</code> or <code>pt</code>, placing the start of the string at the point. If you omit the point, it&#39;s placed at the current <code>0/0</code>.</p><p><code>angle</code> specifies the rotation of the text relative to the current x-axis.</p><p>Horizontal alignment <code>halign</code> can be <code>:left</code>, <code>:center</code>, (also <code>:centre</code>) or <code>:right</code>.  Vertical alignment <code>valign</code> can be <code>:baseline</code>, <code>:top</code>, <code>:middle</code>, or <code>:bottom</code>.</p><p>The default alignment is <code>:left</code>, <code>:baseline</code>.</p><p>This uses <code>textextents()</code> to query the dimensions of the text. This returns values of the built in to the font. You can&#39;t find</p><p>This uses Cairo&#39;s Toy text API.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/text.jl#L5-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.textbox" href="#Luxor.textbox"><code>Luxor.textbox</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">textbox(lines::Array, pos::Point=O;
    leading = 12,
    linefunc::Function = (linenumber, linetext, startpos, height) -&gt; (),
    alignment=:left)</code></pre><p>Draw the strings in the array <code>lines</code> vertically downwards. <code>leading</code> controls the spacing between each line (default 12), and <code>alignment</code> determines the horizontal alignment (default <code>:left</code>).</p><p>Optionally, before each line, execute the function <code>linefunc(linenumber, linetext, startpos, height)</code>.</p><p>Returns the position of what would have been the next line.</p><p>See also <code>textwrap()</code>, which modifies the text so that the lines fit into a specified width.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/text.jl#L635-L652">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.textbox" href="#Luxor.textbox"><code>Luxor.textbox</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">textbox(s::AbstractString, pos::Point=O;
    leading = 12,
    linefunc::Function = (linenumber, linetext, startpos, height) -&gt; (),
    alignment=:left)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/text.jl#L672-L677">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.textcurve" href="#Luxor.textcurve"><code>Luxor.textcurve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">textcurve(the_text, start_angle, start_radius, x_pos = 0, y_pos = 0;
      # optional keyword arguments:
      spiral_ring_step = 0,    # step out or in by this amount
      letter_spacing = 0,      # tracking/space between chars, tighter is (-), looser is (+)
      spiral_in_out_shift = 0, # + values go outwards, - values spiral inwards
      clockwise = true
      )</code></pre><p>Place a string of text on a curve. It can spiral in or out.</p><p><code>start_angle</code> is relative to +ve x-axis, arc/circle is centered on <code>(x_pos,y_pos)</code> with radius <code>start_radius</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/text.jl#L295-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.textcurvecentered-Tuple{Any, Any, Any, Point}" href="#Luxor.textcurvecentered-Tuple{Any, Any, Any, Point}"><code>Luxor.textcurvecentered</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">textcurvecentered(the_text, the_angle, the_radius, center::Point;
      clockwise = true,
      letter_spacing = 0,
      baselineshift = 0</code></pre><p>This version of the <code>textcurve()</code> function is designed for shorter text strings that need positioning around a circle. (A cheesy effect much beloved of hipster brands and retronauts.)</p><p><code>letter_spacing</code> adjusts the tracking/space between chars, tighter is (-), looser is (+)). <code>baselineshift</code> moves the text up or down away from the baseline.</p><p><code>textcurvecentred</code> (UK spelling) is a synonym.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/text.jl#L356-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.textextents-Tuple{Any}" href="#Luxor.textextents-Tuple{Any}"><code>Luxor.textextents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">textextents(str)</code></pre><p>Return an array of six Float64s containing the measurements of the string <code>str</code> when set using the current font settings (Toy API):</p><p>1 x_bearing</p><p>2 y_bearing</p><p>3 width</p><p>4 height</p><p>5 x_advance</p><p>6 y_advance</p><p>The x and y bearings are the displacement from the reference point to the upper-left corner of the bounding box. It is often zero or a small positive value for x displacement, but can be negative x for characters like &quot;j&quot;; it&#39;s almost always a negative value for y displacement.</p><p>The width and height then describe the size of the bounding box. The advance takes you to the suggested reference point for the next letter. Note that bounding boxes for subsequent blocks of text can overlap if the bearing is negative, or the advance is smaller than the width would suggest.</p><p>Example:</p><pre><code class="nohighlight hljs">textextents(&quot;R&quot;)</code></pre><p>returns</p><pre><code class="nohighlight hljs">[1.18652; -9.68335; 8.04199; 9.68335; 9.74927; 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/text.jl#L130-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.textfit" href="#Luxor.textfit"><code>Luxor.textfit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">textfit(str, bbox::BoundingBox, maxfontsize = 800;
     horizontalmargin=12,
     leading=100)</code></pre><p>Fit the string <code>str</code> into the bounding box <code>bbox</code> by adjusting the font size and line breaks.</p><p>Instead of using the current font size, a suitable value will be calculated. You can specify the largest size in <code>maxfontsize</code>, otherwise the largest possible value below 200 will be used.</p><p><code>horizontalmargin</code> is applied to each side.</p><p>Optionally, <code>leading</code> can be supplied, and it will be interpreted as a percentage of the final calculated font size. The default value is 100, so no extra leading is used.</p><p>The function returns a named tuple with information about the calculated values:</p><pre><code class="language-julialang hljs">(fontsize = 37.6, linecount = 5, finalpos = Point(-117.43, 92.60)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function is in need of improvement. It&#39;s not Adobe InDesign... :)</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/text.jl#L929-L959">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.textlines-Tuple{AbstractString, Real}" href="#Luxor.textlines-Tuple{AbstractString, Real}"><code>Luxor.textlines</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">textlines(s::AbstractString, width::Real;
     rightgutter=5)</code></pre><p>Split the text in <code>s</code> into lines up to <code>width</code> units wide (in the current font).</p><p>Returns an array of strings. Use <code>textwrap</code> to draw an array of strings.</p><p>TODO: A <code>rightgutter</code> optional keyword adds some padding to the right hand side of the column. This appears to be needed sometimes -— perhaps the algorithm needs improving to take account of the interaction of <code>textextents</code> and spaces?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/text.jl#L584-L595">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.textonpoly-Tuple{Any, Any}" href="#Luxor.textonpoly-Tuple{Any, Any}"><code>Luxor.textonpoly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">textonpoly(str, pgon;
        tracking = 0,
        startoffset = 0.0,
        baselineshift = 0.0,
        closed = false)</code></pre><p>Draw the text in <code>str</code> along the route of the polygon in <code>pgon</code>.</p><p>The <code>closed</code> option determines whether the final edge of the polygon (joining the last point to the first) is included or not. Eg if you want to draw a string around all three sides of a triangle, you&#39;d use <code>closed=true</code>:</p><pre><code class="language-julia hljs">textonpoly(&quot;mèdeis ageômetrètos eisitô mou tèn
stegèn - let no one ignorant of geometry come under my roof
&quot;,
    ngon(O, 100, 3, vertices=true),
    closed=true)</code></pre><p>If <code>false</code>, only two sides are considered.</p><p>Increase <code>tracking</code> from 0 to add space between the glyphs.</p><p>The <code>startoffset</code> value is a normalized percentage that specifies the start position. So, to start drawing the text halfway along the polygon, specify a start offset value of 0.5.</p><p>Positive values for <code>baselineshift</code> move the characters upwards from the baseline.</p><p>Returns a tuple with the number of characters drawn, and the final value of the index, between 0.0 and 1.0. If the returned index value is less than 1, this means that the text supplied ran out before the end of the polygon was reached.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/text.jl#L1027-L1066">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.textoutlines-Tuple{AbstractString, Point}" href="#Luxor.textoutlines-Tuple{AbstractString, Point}"><code>Luxor.textoutlines</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">textoutlines(s::AbstractString, pos::Point=O;
    action=:none,
    halign=:left,
    valign=:baseline,
    startnewpath=true)</code></pre><p>Convert text to polygons and apply <code>action</code>.</p><p>By default this function discards any current path, unless you use <code>startnewpath=false</code></p><p>See also <code>textpath()</code>. <code>textpath()</code> retains Bezier curves, whereas <code>textoutlines()</code> returns flattened curves.</p><p>TODO Return something more useful than a Boolean.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/text.jl#L227-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.textpath-Tuple{AbstractString, Point}" href="#Luxor.textpath-Tuple{AbstractString, Point}"><code>Luxor.textpath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">textpath(s::AbstractString, pos::Point;
    action=:none,
    halign=:left,
    valign=:baseline,
    startnewpath=true)</code></pre><p>Convert the text in string <code>s</code> to paths and apply the action.</p><p>TODO Return something more useful than a Boolean.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/text.jl#L180-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.textpath-Tuple{Any}" href="#Luxor.textpath-Tuple{Any}"><code>Luxor.textpath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">textpath(t)</code></pre><p>Convert the text in string <code>t</code> to paths, adding them to the current path, for subsequent filling/stroking etc...</p><p>You can use <code>pathtopoly()</code> or <code>getpath()</code> or <code>getpathflat()</code> to convert the paths to polygons.</p><p>See also <code>textoutlines()</code>. <code>textpath()</code> retains Bezier curves, whereas <code>textoutlines()</code> returns flattened curves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/text.jl#L168-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.textplace-Tuple{AbstractString, Point, Vector}" href="#Luxor.textplace-Tuple{AbstractString, Point, Vector}"><code>Luxor.textplace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">textplace(txt::AbstractString, pos::Point, params::Vector;
    action = :fill,
    startnewpath = false)</code></pre><p>A low-level function that places text characters one by one according to the parameters in <code>params</code>. First character uses the first tuple, second character uses the second, and so on.</p><p>Returns the next text position.</p><p>A tuple of parameters is:</p><pre><code class="language-julia hljs">(face = &quot;TimesRoman&quot;, size = 12, color=colorant&quot;black&quot;, kern = 0, shift = 0, advance = true)</code></pre><p>where</p><ul><li><p><code>face</code> is fontface &quot;string&quot;                   # sticky</p></li><li><p><code>size</code> is fontsize # pts                      # sticky</p></li><li><p><code>color</code> is color                              # sticky</p></li><li><p><code>kern</code> amount (pixels) shifted to the right   # resets after each char</p></li><li><p><code>shift</code> = baseline shifted vertically         # resets after each char</p></li><li><p><code>advance</code> - whether to advance                # resets after each char</p></li></ul><p>Some parameters are &quot;sticky&quot;: once set, they apply for all subsequent characters until a new value is supplied. Others aren&#39;t sticky, and are reset for each character. So font face, size, and color parameters need only be specified once, whereas kern/shift/advance modifiers are reset for each character.</p><p><strong>Example</strong></p><p>Draw the Hogwarts Express Platform number 9 and 3/4:</p><pre><code class="language-julia hljs">txtpos = textplace(&quot;93—4!&quot;, O - (200, 0), [
    # format for 9:
    (size=120, face=&quot;Bodoni-Poster&quot;, color=colorant&quot;grey10&quot;),
    # format for 3:
    (size=60,  kern = 5, shift = 60,  advance=false,),
    # format for -:
    (          kern = 0, shift = 25,  advance=false,),
    # format for 4:
    (          kern = 5, shift = -20, advance=true),
    # format for !:
    (size=120, kern = 20,),
    ])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/text.jl#L846-L903">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.texttrack-NTuple{4, Any}" href="#Luxor.texttrack-NTuple{4, Any}"><code>Luxor.texttrack</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">texttrack(txt, pos, tracking;
    action=:fill,
    halign=:left,
    valign=:baseline,
    startnewpath=true)
texttrack(txt, pos, tracking, fontsize;
    action=:fill,
    halign=:left,
    valign=:baseline,
    startnewpath=true)</code></pre><p>Place the text in <code>txt</code> at <code>pos</code>, left-justified, and letter space (&#39;track&#39;) the text using the value in <code>tracking</code>.</p><p>The tracking units depend on the current font size. In a 12‑point font, 1 em equals 12 points. A point is about 0.35mm, 1em is about 4.2mm, and a 1000 units of tracking are about 4.2mm. So a tracking value of 1000 for a 12 point font places about 4mm between each character.</p><p>A negative value tightens the letter spacing noticeably.</p><p>The text drawing action applied to each character defaults to <code>textoutlines(... :fill)</code>.</p><p>If <code>startnewpath</code> is true, each character is acted on separately. To clip and track text, specify the clip action and avoid resetting the clipping path for each character.</p><pre><code class="language-julia hljs">    newpath()
    texttrack(t, O + (0, 80), 200, action=:clip, startnewpath=false)
    ...
    clipreset()</code></pre><p>TODO Is it possible to fix strings with combining characters such as &quot;̈&quot;?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/text.jl#L736-L774">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.textwrap-Tuple{AbstractString, Real, Point, Function}" href="#Luxor.textwrap-Tuple{AbstractString, Real, Point, Function}"><code>Luxor.textwrap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">textwrap(s::T where T&lt;:AbstractString, width::Real, pos::Point;
    rightgutter=5,
    leading=0)
textwrap(s::T where T&lt;:AbstractString, width::Real, pos::Point, linefunc::Function;
    rightgutter=5,
    leading=0)</code></pre><p>Draw the string in <code>s</code> by splitting it at whitespace characters into lines, so that each line is no longer than <code>width</code> units. The text starts at <code>pos</code> such that the first line of text is drawn entirely below a line drawn horizontally through that position. Each line is aligned on the left side, below <code>pos</code>.</p><p>See also <code>textbox()</code>.</p><p>Optionally, before each line, execute the function <code>linefunc(linenumber, linetext, startpos, leading)</code>.</p><p>If you don&#39;t supply a value for <code>leading</code>, the font&#39;s built-in extents are used.</p><p>Text with no whitespace characters won&#39;t wrap. You can write a simple chunking function to split a string or array into chunks:</p><pre><code class="nohighlight hljs">chunk(x, n) = [x[i:min(i+n-1,length(x))] for i in 1:n:length(x)]</code></pre><p>For example:</p><pre><code class="nohighlight hljs">textwrap(the_text, 300, boxtopleft(BoundingBox()) + 20,
    (ln, lt, sp, ht) -&gt; begin
        c = count(t -&gt; occursin(r&quot;[[:punct:]]&quot;, t), split(lt, &quot;&quot;))
        @layer begin
            fontface(&quot;Menlo&quot;)
            sethue(&quot;darkred&quot;)
            text(string(&quot;[&quot;, c, &quot;]&quot;), sp + (310, 0))
        end
    end)</code></pre><p>puts a count of the number of punctuation characters in each line at the end of the line.</p><p>Returns the position of what would have been the next line.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/text.jl#L680-L724">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.tickline-Tuple{Any, Any}" href="#Luxor.tickline-Tuple{Any, Any}"><code>Luxor.tickline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tickline(startpos, finishpos;
    startnumber         = 0,
    finishnumber        = 1,
    major               = 1,
    minor               = 0,
    major_tick_function = nothing,
    minor_tick_function = nothing,
    rounding            = 2,
    axis                = true, # draw the line?
    log                 = false,
    vertices            = false # just return the points
    )</code></pre><p>Draw a line with ticks. <code>major</code> is the number of ticks required between the start and finish point. So <code>1</code> divides the line in half. <code>minor</code> is the number of ticks between each major tick.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">tickline(Point(0, 0), Point(100, 0))
tickline(Point(0, 0), Point(100, 0), major = 4)
majorticks, minorticks = tickline(Point(0, 0), Point(100, 0), axis=false)</code></pre><p><strong>Custom ticks</strong></p><p>Supply functions to make custom ticks. Custom tick functions should have arguments as follows:</p><pre><code class="nohighlight hljs">function mtick(n, pos;
        startnumber         = 0,
        finishnumber        = 1,
        nticks = 1)
        ...</code></pre><p>and</p><pre><code class="nohighlight hljs">function mntick(n, pos;
        startnumber        = 0,
        finishnumber       = 1,
        nticks             = 1,
        majorticklocations = [])
        ...</code></pre><p>For example:</p><pre><code class="nohighlight hljs">tickline(O - (300, 0), Point(300, 0),
    startnumber  = -10,
    finishnumber = 10,
    minor        = 0,
    major        = 4,
    axis         = false,
    major_tick_function = (n, pos;
        startnumber=30, finishnumber=40, nticks=10) -&gt; begin
        @layer begin
            translate(pos)
            ticklength = get_fontsize()
            line(O, O + polar(ticklength, 3π/2), :stroke)
            k = rescale(n, 0, nticks - 1, startnumber, finishnumber)
            ticklength = get_fontsize() * 1.3
            text(&quot;$(round(k, digits=2))&quot;,
                O + (0, ticklength),
                halign=:center,
                valign=:middle,
                angle = -getrotation())
        end
    end)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/arrows.jl#L574-L649">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.tidysvg-Tuple{Any}" href="#Luxor.tidysvg-Tuple{Any}"><code>Luxor.tidysvg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tidysvg(fname)</code></pre><p>Read the SVG image in <code>fname</code> and write it to a file <code>fname-tidy.svg</code> with modified glyph names.</p><p>Return the name of the modified file.</p><p>SVG images use named defs for text, which cause errors problem when used in a notebook. <a href="https://github.com/jupyter/notebook/issues/333">See</a> for example.</p><p>A kludgy workround is to rename the elements...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/drawings.jl#L160-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.transform-Tuple{Array}" href="#Luxor.transform-Tuple{Array}"><code>Luxor.transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform(a::Array)</code></pre><p>Modify the current matrix by multiplying it by matrix <code>a</code>.</p><p>For example, to skew the current state by 45 degrees in x and move by 20 in y direction:</p><pre><code class="nohighlight hljs">transform([1, 0, tand(45), 1, 0, 20])</code></pre><p>Use <code>getmatrix()</code> to get the current matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/matrix.jl#L98-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.translate-Tuple{Real, Real}" href="#Luxor.translate-Tuple{Real, Real}"><code>Luxor.translate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">translate(point)
translate(x::Real, y::Real)</code></pre><p>Translate the workspace to <code>x</code> and <code>y</code> or to <code>pt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/basics.jl#L559-L564">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.translationmatrix-Tuple{Any, Any}" href="#Luxor.translationmatrix-Tuple{Any, Any}"><code>Luxor.translationmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">translationmatrix(x, y)</code></pre><p>Return a 3x3 Julia matrix that will apply a translation in <code>x</code> and <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/matrix.jl#L132-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.trianglecenter-Tuple{Point, Point, Point}" href="#Luxor.trianglecenter-Tuple{Point, Point, Point}"><code>Luxor.trianglecenter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trianglecenter(pt1::Point, pt2::Point, pt3::Point)</code></pre><p>Return the centroid of the triangle defined by <code>pt1</code>, <code>pt2</code>, and <code>pt3</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/triangles.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.trianglecircumcenter-Tuple{Point, Point, Point}" href="#Luxor.trianglecircumcenter-Tuple{Point, Point, Point}"><code>Luxor.trianglecircumcenter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trianglecircumcenter(pt1::Point, pt2::Point, pt3::Point)</code></pre><p>Return the circumcenter of the triangle defined by <code>pt1</code>, <code>pt2</code>, and <code>pt3</code>. The circumcenter is the center of a circle that passes through the vertices of the triangle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/triangles.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.triangleincenter-Tuple{Point, Point, Point}" href="#Luxor.triangleincenter-Tuple{Point, Point, Point}"><code>Luxor.triangleincenter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">triangleincenter(pt1::Point, pt2::Point, pt3::Point)</code></pre><p>Return the incenter of the triangle defined by <code>pt1</code>, <code>pt2</code>, and <code>pt3</code>. The incenter is the center of a circle inscribed inside the triangle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/triangles.jl#L30-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.triangleorthocenter-Tuple{Point, Point, Point}" href="#Luxor.triangleorthocenter-Tuple{Point, Point, Point}"><code>Luxor.triangleorthocenter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">triangleorthocenter(pt1::Point, pt2::Point, pt3::Point)</code></pre><p>Return the orthocenter of the triangle defined by <code>pt1</code>, <code>pt2</code>, and <code>pt3</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/triangles.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.trimbezier-Tuple{BezierPathSegment, Any, Any}" href="#Luxor.trimbezier-Tuple{BezierPathSegment, Any, Any}"><code>Luxor.trimbezier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trimbezier(bps::BezierPathSegment, lowpt, highpt)</code></pre><p>Chop the ends of a BezierPathSegment at <code>lowpt</code> and <code>highpt</code>. <code>lowpt</code> and <code>highpt</code> should be between 0 and 1.</p><p>Returns a trimmed BezierPathSegment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/bezierpath.jl#L767-L774">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.unpremultiplyalpha-Tuple{Any}" href="#Luxor.unpremultiplyalpha-Tuple{Any}"><code>Luxor.unpremultiplyalpha</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unpremultiplyalpha(a)</code></pre><p>Given an array of UInt32 values, divide each value by the alpha value. See alphadivide or reversing premultiplied alpha values.</p><p>Returns an array of arrays, where each array has four Float64 values.</p><p>In a premultiplied image array, a 50% transparent red pixel is stored as 0x80800000, rather than not 0x80ff0000. This function reverses the process,  dividing each RGB value by the alpha value.</p><p>The highest two digits of each incoming element is interpreted as the alpha value.</p><pre><code class="nohighlight hljs">unpremultiplyalpha([0x80800000])
 1-element Array{Array{Float64,1},1}:
 [1.0, 0.0, 0.0, 0.5019607843137255]</code></pre><p>Notice the arithmetic errors introduced as 0x80 gets converted to 0.5019.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/drawings.jl#L809-L835">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.AnimatedGif" href="#Luxor.AnimatedGif"><code>Luxor.AnimatedGif</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Wraps the location of an animated gif so that it can be displayed</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.BezierPath" href="#Luxor.BezierPath"><code>Luxor.BezierPath</code></a> — <span class="docstring-category">Type</span></header><section><div><p>BezierPath is an array of BezierPathSegments. <code>segments</code> is <code>Vector{BezierPathSegment}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/bezierpath.jl#L43-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.BezierPathSegment" href="#Luxor.BezierPathSegment"><code>Luxor.BezierPathSegment</code></a> — <span class="docstring-category">Type</span></header><section><div><p>BezierPathSegment is an array of four points:</p><p><code>p1</code>  - start point <code>cp1</code> - control point for start point <code>cp2</code> - control point for finishpoint <code>p2</code>  - finish point</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/bezierpath.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.BoundingBox-Tuple{AbstractString}" href="#Luxor.BoundingBox-Tuple{AbstractString}"><code>Luxor.BoundingBox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoundingBox(str::AbstractString)</code></pre><p>Return a BoundingBox that just encloses a text string, given the current font selection. Uses the Toy text API (ie <code>text()</code> and <code>textextents()</code>).</p><p>Text is assumed to be placed at the origin (<code>0/0</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L92-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.BoundingBox-Tuple{BoxmapTile}" href="#Luxor.BoundingBox-Tuple{BoxmapTile}"><code>Luxor.BoundingBox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoundingBox(tile::BoxmapTile)</code></pre><p>Return a BoundingBox of a BoxmapTile (as created with <code>boxmap()</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Boxmaptile.jl#L172-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.BoundingBox-Tuple{Path}" href="#Luxor.BoundingBox-Tuple{Path}"><code>Luxor.BoundingBox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoundingBox(path::Path)</code></pre><p>Find bounding box of a stored Path (made with <code>storepath()</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Path.jl#L195-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.BoundingBox-Tuple{Vector{Point}}" href="#Luxor.BoundingBox-Tuple{Vector{Point}}"><code>Luxor.BoundingBox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoundingBox(pointlist::Array)</code></pre><p>Return the BoundingBox of a polygon (array of points).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.BoundingBox-Tuple{}" href="#Luxor.BoundingBox-Tuple{}"><code>Luxor.BoundingBox</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>BoundingBox()</code> with no arguments returns a BoundingBox that includes the current drawing.</p><p>The default <code>BoundingBox(;centered=true)</code> returns a BoundingBox the same size and position as the current drawing, and assumes the origin (0, 0) is at the center.</p><p>If the <code>centered</code> option is <code>false</code>, the function assumes that the origin is at the top left of the drawing. So this function doesn&#39;t really work if the current matrix has been modified (by <code>translate()</code>, <code>scale()</code>, <code>rotate()</code> etc.)</p><p>An instance of the BoundingBox type holds two Points, <code>corner1</code> and <code>corner2</code>.</p><p>BoundingBox(;centered = true)   # the bounding box of the Drawing</p><p>BoundingBox(s::AbstractString)  # the bounding box of a text string at the origin</p><p>BoundingBox(pt::Array)          # the bounding box of a polygon</p><p>BoundingBox(circle(O, 100))     # the bounding box of a path added by circle()</p><p>BoundingBox(path::Path)         # the bounding box of a Path</p><p>You can use <code>BoundingBox()</code> with the functions that add graphic shapes to the current path (eg <code>box()</code>, <code>circle()</code>, <code>star()</code>, <code>ngon()</code>). But note that eg <code>BoundingBox(box(O, 100, 100))</code> adds a shape to the current path as well as returning a bounding box.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/BoundingBox.jl#L10-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Drawing" href="#Luxor.Drawing"><code>Luxor.Drawing</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Create a new drawing, and optionally specify file type (PNG, PDF, SVG, EPS), file-based or in-memory, and dimensions.</p><pre><code class="nohighlight hljs">Drawing(width=600, height=600, file=&quot;luxor-drawing.png&quot;)</code></pre><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">Drawing()</code></pre><p>creates a drawing, defaulting to PNG format, default filename &quot;luxor-drawing.png&quot;, default size 800 pixels square.</p><p>You can specify dimensions, and assume the default output filename:</p><pre><code class="nohighlight hljs">Drawing(400, 300)</code></pre><p>creates a drawing 400 pixels wide by 300 pixels high, defaulting to PNG format, default filename &quot;luxor-drawing.png&quot;.</p><pre><code class="nohighlight hljs">Drawing(400, 300, &quot;my-drawing.pdf&quot;)</code></pre><p>creates a PDF drawing in the file &quot;my-drawing.pdf&quot;, 400 by 300 pixels.</p><pre><code class="nohighlight hljs">Drawing(1200, 800, &quot;my-drawing.svg&quot;)</code></pre><p>creates an SVG drawing in the file &quot;my-drawing.svg&quot;, 1200 by 800 pixels.</p><pre><code class="nohighlight hljs">Drawing(width, height, surfacetype | filename)</code></pre><p>creates a new drawing of the given surface type (e.g. :svg, :png), storing the picture only in memory if no filename is provided.</p><pre><code class="nohighlight hljs">Drawing(1200, 1200/Base.Mathconstants.golden, &quot;my-drawing.eps&quot;)</code></pre><p>creates an EPS drawing in the file &quot;my-drawing.eps&quot;, 1200 wide by 741.8 pixels (= 1200 ÷ ϕ) high. Only for PNG files must the dimensions be integers.</p><pre><code class="nohighlight hljs">Drawing(&quot;A4&quot;, &quot;my-drawing.pdf&quot;)</code></pre><p>creates a drawing in ISO A4 size (595 wide by 842 high) in the file &quot;my-drawing.pdf&quot;. Other sizes available are: &quot;A0&quot;, &quot;A1&quot;, &quot;A2&quot;, &quot;A3&quot;, &quot;A4&quot;, &quot;A5&quot;, &quot;A6&quot;, &quot;Letter&quot;, &quot;Legal&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;. Append &quot;landscape&quot; to get the landscape version.</p><pre><code class="nohighlight hljs">Drawing(&quot;A4landscape&quot;)</code></pre><p>creates the drawing A4 landscape size.</p><p>PDF files default to a white background, but PNG defaults to transparent, unless you specify one using <code>background()</code>.</p><pre><code class="nohighlight hljs">Drawing(width, height, :image)</code></pre><p>creates the drawing in an image buffer in memory. You can obtain the data as a matrix with <code>image_as_matrix()</code>.</p><pre><code class="nohighlight hljs">Drawing(width, height, :rec)</code></pre><p>creates the drawing in a recording surface in memory. <code>snapshot(fname, ...)</code> to any file format and bounding box, or render as pixels with <code>image_as_matrix()</code>.</p><pre><code class="nohighlight hljs">Drawing(width, height, strokescale=true)</code></pre><p>creates the drawing and enables stroke scaling (strokes will be scaled according to the current transformation). (Stroke scaling is disabled by default.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/drawings.jl#L250-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.GridHex" href="#Luxor.GridHex"><code>Luxor.GridHex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GridHex(startpoint, radius, width=1200.0, height=1200.0)</code></pre><p>Define a hexagonal grid, to start at <code>startpoint</code> and proceed along the x-axis and then along the y-axis, <code>radius</code> is the radius of a circle that encloses each hexagon. The distance in <code>x</code> between the centers of successive hexagons is:</p><p><span>$\frac{\sqrt{(3)} radius}{2}$</span></p><p>To get the next point from the grid, use <code>nextgridpoint(g::Grid)</code>.</p><p>When you run out of grid points, you&#39;ll wrap round and start again.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/tiles-grids.jl#L162-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.GridRect" href="#Luxor.GridRect"><code>Luxor.GridRect</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GridRect(startpoint, xspacing, yspacing, width, height)</code></pre><p>Define a rectangular grid, to start at <code>startpoint</code> and proceed along the x-axis in steps of <code>xspacing</code>, then along the y-axis in steps of <code>yspacing</code>.</p><pre><code class="nohighlight hljs">GridRect(startpoint, xspacing=100.0, yspacing=100.0, width=1200.0, height=1200.0)</code></pre><p>For a column, set the <code>xspacing</code> to 0:</p><pre><code class="nohighlight hljs">grid = GridRect(O, 0, 40)</code></pre><p>To get points from the grid, use <code>nextgridpoint(g::Grid)</code>.</p><pre><code class="nohighlight hljs">julia&gt; grid = GridRect(O, 0, 40);
julia&gt; nextgridpoint(grid)
Luxor.Point(0.0, 0.0)

julia&gt; nextgridpoint(grid)
Luxor.Point(0.0, 40.0)</code></pre><p>When you run out of grid points, you&#39;ll wrap round and start again.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/tiles-grids.jl#L120-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Movie" href="#Luxor.Movie"><code>Luxor.Movie</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The <code>Movie</code> and <code>Scene</code> types and the <code>animate()</code> function are designed to help you create the frames that can be used to make an animated GIF or movie.</p><p>1 Provide width, height, title, and optionally a frame range to the Movie constructor:</p><pre><code class="nohighlight hljs">demo = Movie(400, 400, &quot;test&quot;, 1:500)</code></pre><p>2 Define one or more scenes and scene-drawing functions.</p><p>3 Run the <code>animate()</code> function, calling those scenes.</p><p>Example</p><pre><code class="nohighlight hljs">bang = Movie(400, 100, &quot;bang&quot;)

backdrop(scene, framenumber) =  background(&quot;black&quot;)

function frame1(scene, framenumber)
    background(&quot;white&quot;)
    sethue(&quot;black&quot;)
    eased_n = scene.easingfunction(framenumber, 0, 1, scene.framerange.stop)
    circle(O, 40 * eased_n, :fill)
end

animate(bang, [
    Scene(bang, backdrop, 0:200),
    Scene(bang, frame1, 0:200, easingfunction=easeinsine)],
    creategif=true,
    pathname=&quot;/tmp/animationtest.gif&quot;)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Movie-Tuple{Any, Any, AbstractString}" href="#Luxor.Movie-Tuple{Any, Any, AbstractString}"><code>Luxor.Movie</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Movie(width, height, movietitle)</code></pre><p>Define a movie, specifying the width, height, and a title. The title will be used to make the output file name. The range defaults to <code>1:250</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Partition" href="#Luxor.Partition"><code>Luxor.Partition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">p = Partition(areawidth, areaheight, tilewidth, tileheight)</code></pre><p>A Partition is an iterator that, for each iteration, returns a tuple of:</p><ul><li>the <code>x</code>/<code>y</code> point of the center of each tile in a set of tiles that divide up a</li></ul><p>rectangular space such as a page into rows and columns (relative to current 0/0)</p><ul><li>the number of the tile</li></ul><p><code>areawidth</code> and <code>areaheight</code> are the dimensions of the area to be tiled, <code>tilewidth</code>/<code>tileheight</code> are the dimensions of the tiles.</p><p>Tiler and Partition are similar:</p><ul><li><p>Partition lets you specify the width and height of a cell</p></li><li><p>Tiler lets you specify how many rows and columns of cells you want, and a margin</p></li></ul><pre><code class="nohighlight hljs">tiles = Partition(1200, 1200, 30, 30)
for (pos, n) in tiles
    # the point pos is the center of the tile
end</code></pre><p>You can access the calculated tile width and height like this:</p><pre><code class="nohighlight hljs">tiles = Partition(1200, 1200, 30, 30)
for (pos, n) in tiles
    ellipse(pos.x, pos.y, tiles.tilewidth, tiles.tileheight, :fill)
end</code></pre><p>It&#39;s sometimes useful to know which row and column you&#39;re currently on:</p><pre><code class="nohighlight hljs">tiles.currentrow
tiles.currentcol</code></pre><p>should have that information for you.</p><p>Unless the tilewidth and tileheight are exact multiples of the area width and height, you&#39;ll see a border at the right and bottom where the tiles won&#39;t fit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/tiles-grids.jl#L245-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Path" href="#Luxor.Path"><code>Luxor.Path</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A Path object contains, in the <code>.path</code> field, a vector of <code>PathElement</code>s (<code>PathCurve</code>, <code>PathMove</code>, <code>PathLine</code>, <code>PathClose</code>) that describe a Cairo path. Use <code>drawpath()</code> to draw it.</p><pre><code class="nohighlight hljs">Path([PathMove(Point(2.0, 90.5625)),
      PathCurve(Point(4.08203, 68.16015), Point(11.28, 45.28), Point(24.8828, 26.40234)),
      PathLine(Point(2.0, 90.5625)),
      PathClose()
     ])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Path.jl#L20-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Path-Tuple{Vector{Point}}" href="#Luxor.Path-Tuple{Vector{Point}}"><code>Luxor.Path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Path(ptlist::Vector{Point}; close=false))</code></pre><p>Create a Path from the points in <code>ptlist</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Path.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Point" href="#Luxor.Point"><code>Luxor.Point</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The Point type holds two coordinates. It&#39;s immutable, you can&#39;t change the values of the x and y values directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L6-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Scene" href="#Luxor.Scene"><code>Luxor.Scene</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The Scene type defines a function to be used to render a range of frames in a movie.</p><ul><li>the <code>movie</code> created by Movie()</li><li>the <code>framefunction</code> is a function taking two arguments: the scene and the framenumber.</li><li>the <code>framerange</code> determines which frames are processed by the function. Defaults to the entire movie.</li><li>the optional <code>easingfunction</code> can be accessed by the framefunction to vary the transition speed</li><li>the optional <code>opts</code> which is a single argument of an abstract type which can be accessed within the framefunction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L55-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Scene-Tuple{Movie, Function}" href="#Luxor.Scene-Tuple{Movie, Function}"><code>Luxor.Scene</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Scene(movie, function, range;
    easingfunction=easinoutquad,
    optarg=nothing)</code></pre><p>Use the Scene() constructor function to create a scene. Supply a movie, a function to generate the scene, and a range of frames. Optionally you can supply an easing function, and other information, in <code>optarg</code>, which can be accessed as <code>scene.opts</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">function initial(scene, framenumber)
    balls = scene.opts
    ...
end

animate(poolmovie, [
    Scene(poolmovie, initial, optarg=balls,   1:20),
    ...
    ])</code></pre><p>To use an easing function inside the frame-generating function, you can create a normalized value with, for example:</p><pre><code class="nohighlight hljs">eased_n = scene.easingfunction(framenumber, 0, 1, scene.framerange.stop)</code></pre><p>Or, if the scene doesn&#39;t start at frame 1, calculate normalized easing function like this:</p><pre><code class="nohighlight hljs">eased_n = scene.easingfunction(framenumber - scene.framerange.start,
    0, 1, scene.framerange.stop - scene.framerange.start)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/animate.jl#L72-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Table" href="#Luxor.Table"><code>Luxor.Table</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">t = Table(nrows, ncols)
t = Table(nrows, ncols, colwidth, rowheight)
t = Table(rowheights, columnwidths)</code></pre><p>Tables are centered at <code>O</code>, but you can supply a point after the specifications.</p><pre><code class="nohighlight hljs">t = Table(nrows, ncols, centerpoint)
t = Table(nrows, ncols, colwidth, rowheight, centerpoint)
t = Table(rowheights, columnwidths, centerpoint)</code></pre><p>Examples</p><p>Simple tables</p><pre><code class="nohighlight hljs">t = Table(4, 3) # 4 rows and 3 cols, default is 100w, 50 h
t = Table(4, 3, 80, 30)   # 4 rows of 30pts high, 3 cols of 80pts wide
t = Table(4, 3, (80, 30)) # same
t = Table((4, 3), (80, 30)) # same</code></pre><p>Specify row heights and column widths instead of quantities:</p><pre><code class="nohighlight hljs">t = Table([60, 40, 100], 50) # 3 different height rows, 1 column 50 wide
t = Table([60, 40, 100], [100, 60, 40]) # 3 rows, 3 columns
t = Table(fill(30, (10)), [50, 50, 50]) # 10 rows 30 high, 3 columns 10 wide
t = Table(50, [60, 60, 60]) # just 1 row (50 high), 3 columns 60 wide
t = Table([50], [50]) # just 1 row, 1 column, both 50 units wide
t = Table(50, 50, 10, 5) # 50 rows, 50 columns, 10 units wide, 5 units high
t = Table([6, 11, 16, 21, 26, 31, 36, 41, 46], [6, 11, 16, 21, 26, 31, 36, 41, 46])
t = Table(15:5:55, vcat(5:2:15, 15:-2:5))
 #  table has 108 cells, with:
 #  row heights: 15 20 25 30 35 40 45 50 55
 #  col widths:  5 7 9 11 13 15 15 13 11 9 7 5
t = Table(vcat(5:10:60, 60:-10:5), vcat(5:10:60, 60:-10:5))
t = Table(vcat(5:10:60, 60:-10:5), 50) # 1 column 50 units wide
t = Table(vcat(5:10:60, 60:-10:5), 1:5:50)</code></pre><p>A Table is an iterator that, for each iteration, returns a tuple of:</p><ul><li><p>the <code>x</code>/<code>y</code> point of the center of cells arranged in rows and columns (relative to current 0/0)</p></li><li><p>the number of the cell (left to right, then top to bottom)</p></li></ul><p><code>nrows</code>/<code>ncols</code> are the number of rows and columns required.</p><p>It&#39;s sometimes useful to know which row and column you&#39;re currently on while iterating:</p><pre><code class="nohighlight hljs">t.currentrow
t.currentcol</code></pre><p>and row heights and column widths are available in:</p><pre><code class="nohighlight hljs">t.rowheights
t.colwidths</code></pre><p><code>box(t::Table, r, c)</code> can be used to fill table cells:</p><pre><code class="nohighlight hljs">@svg begin
    for (pt, n) in (t = Table(8, 3, 30, 15))
        randomhue()
        box(t, t.currentrow, t.currentcol, :fill)
        sethue(&quot;white&quot;)
        text(string(n), pt)
    end
end</code></pre><p>or without iteration, using cellnumber:</p><pre><code class="nohighlight hljs">@svg begin
    t = Table(8, 3, 30, 15)
    for n in eachindex(t)
        randomhue()
        box(t, n, :fill)
        sethue(&quot;white&quot;)
        text(string(n), t[n])
    end
end</code></pre><p>To use a Table to make grid points:</p><pre><code class="nohighlight hljs">julia&gt; first.(collect(Table(10, 6)))
60-element Array{Luxor.Point,1}:
 Luxor.Point(-10.0, -18.0)
 Luxor.Point(-6.0, -18.0)
 Luxor.Point(-2.0, -18.0)
 ⋮
 Luxor.Point(2.0, 18.0)
 Luxor.Point(6.0, 18.0)
 Luxor.Point(10.0, 18.0)</code></pre><p>which returns an array of points that are the center points of the cells in the table.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Table.jl#L13-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Tiler" href="#Luxor.Tiler"><code>Luxor.Tiler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">tiles = Tiler(areawidth, areaheight, nrows, ncols, margin=20)</code></pre><p>A Tiler is an iterator that, for each iteration, returns a tuple of:</p><ul><li><p>the <code>x</code>/<code>y</code> point of the center of each tile in a set of tiles that divide up a rectangular space such as a page into rows and columns (relative to current 0/0)</p></li><li><p>the number of the tile</p></li></ul><p><code>areawidth</code> and <code>areaheight</code> are the dimensions of the area to be tiled, <code>nrows</code>/<code>ncols</code> are the number of rows and columns required, and <code>margin</code> is applied to all four edges of the area before the function calculates the tile sizes required.</p><p>Tiler and Partition are similar:</p><ul><li><p>Partition lets you specify the width and height of a cell</p></li><li><p>Tiler lets you specify how many rows and columns of cells you want, and a margin:</p></li></ul><pre><code class="nohighlight hljs">tiles = Tiler(1000, 800, 4, 5, margin=20)
for (pos, n) in tiles
    # the point pos is the center of the tile
end</code></pre><p>You can access the calculated tile width and height like this:</p><pre><code class="nohighlight hljs">tiles = Tiler(1000, 800, 4, 5, margin=20)
for (pos, n) in tiles
    ellipse(pos.x, pos.y, tiles.tilewidth, tiles.tileheight, :fill)
end</code></pre><p>It&#39;s sometimes useful to know which row and column you&#39;re currently on. <code>tiles.currentrow</code> and <code>tiles.currentcol</code> should have that information for you.</p><p>To use a Tiler to make grid points:</p><pre><code class="nohighlight hljs">first.(collect(Tiler(800, 800, 4, 4)))</code></pre><p>which returns an array of points that are the center points of the grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/tiles-grids.jl#L1-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Turtle" href="#Luxor.Turtle"><code>Luxor.Turtle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Turtle()
Turtle(O)
Turtle(0, 0)
Turtle(O, pendown=true, orientation=0, pencolor=(1.0, 0.25, 0.25))</code></pre><p>Create a Turtle. You can command a turtle to move and draw &quot;turtle graphics&quot;.</p><p>The commands (unusually for Julia) start with a capital letter, and angles are specified in degrees.</p><p>Basic commands are <code>Forward()</code>, <code>Turn()</code>, <code>Pendown()</code>, <code>Penup()</code>, <code>Pencolor()</code>, <code>Penwidth()</code>, <code>Circle()</code>, <code>Orientation()</code>, <code>Rectangle()</code>, and <code>Reposition()</code>.</p><p>Others include <code>Push()</code>, <code>Pop()</code>, <code>Message()</code>, <code>HueShift()</code>, <code>Randomize_saturation()</code>, <code>Reposition()</code>, and <code>Pen_opacity_random()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/Turtle.jl#L20-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.O" href="#Luxor.O"><code>Luxor.O</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>O is a shortcut for the current origin, <code>0/0</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/point.jl#L15-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.paper_sizes" href="#Luxor.paper_sizes"><code>Luxor.paper_sizes</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">paper_sizes</code></pre><p>The <code>paper_sizes</code> Dictionary holds a few paper sizes, width is first, so default is Portrait:</p><pre><code class="nohighlight hljs">&quot;A0&quot;      =&gt; (2384, 3370),
&quot;A1&quot;      =&gt; (1684, 2384),
&quot;A2&quot;      =&gt; (1191, 1684),
&quot;A3&quot;      =&gt; (842, 1191),
&quot;A4&quot;      =&gt; (595, 842),
&quot;A5&quot;      =&gt; (420, 595),
&quot;A6&quot;      =&gt; (298, 420),
&quot;A&quot;       =&gt; (612, 792),
&quot;Letter&quot;  =&gt; (612, 792),
&quot;Legal&quot;   =&gt; (612, 1008),
&quot;Ledger&quot;  =&gt; (792, 1224),
&quot;B&quot;       =&gt; (612, 1008),
&quot;C&quot;       =&gt; (1584, 1224),
&quot;D&quot;       =&gt; (2448, 1584),
&quot;E&quot;       =&gt; (3168, 2448))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/4a9db77b41528d8d055b74f92ec46f3383837d90/src/drawings.jl#L210-L232">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../functionindex/">« Alphabetical function list</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Tuesday 5 April 2022 09:02">Tuesday 5 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
