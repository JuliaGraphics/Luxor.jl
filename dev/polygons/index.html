<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Polygons and paths Â· Luxor</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Luxor logo"/></a><div class="docs-package-name"><span class="docs-autofit">Luxor</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction to Luxor</a></li><li><a class="tocitem" href="../examples/">A few examples</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../basics/">Basic concepts</a></li><li><a class="tocitem" href="../simplegraphics/">Simple shapes</a></li><li><a class="tocitem" href="../moregraphics/">More graphics</a></li><li><a class="tocitem" href="../geometrytools/">Geometry tools</a></li><li><a class="tocitem" href="../tables-grids/">Tables and grids</a></li><li><a class="tocitem" href="../colors-styles/">Colors and styles</a></li><li class="is-active"><a class="tocitem" href>Polygons and paths</a><ul class="internal"><li><a class="tocitem" href="#Regular-polygons-(&quot;ngons&quot;)-1"><span>Regular polygons (&quot;ngons&quot;)</span></a></li><li><a class="tocitem" href="#Stars-1"><span>Stars</span></a></li><li><a class="tocitem" href="#Polygons-1"><span>Polygons</span></a></li><li><a class="tocitem" href="#Converting-paths-to-polygons-1"><span>Converting paths to polygons</span></a></li><li><a class="tocitem" href="#Polygons-to-BÃ©zier-paths-and-back-again-1"><span>Polygons to BÃ©zier paths and back again</span></a></li><li><a class="tocitem" href="#Brush-strokes-1"><span>Brush strokes</span></a></li><li><a class="tocitem" href="#Polygon-information-1"><span>Polygon information</span></a></li><li><a class="tocitem" href="#Polygon-selection-and-modification-1"><span>Polygon selection and modification</span></a></li><li><a class="tocitem" href="#Other-polygon-operations-1"><span>Other polygon operations</span></a></li></ul></li><li><a class="tocitem" href="../text/">Text</a></li><li><a class="tocitem" href="../transforms/">Transforms and matrices</a></li><li><a class="tocitem" href="../clipping/">Clipping</a></li><li><a class="tocitem" href="../images/">Images</a></li><li><a class="tocitem" href="../turtle/">Turtle graphics</a></li><li><a class="tocitem" href="../animation/">Animation</a></li><li><a class="tocitem" href="../moreexamples/">More examples</a></li><li><a class="tocitem" href="../functionindex/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Polygons and paths</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Polygons and paths</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGraphics/Luxor.jl/blob/master/docs/src/polygons.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Polygons-and-paths-1"><a class="docs-heading-anchor" href="#Polygons-and-paths-1">Polygons and paths</a><a class="docs-heading-anchor-permalink" href="#Polygons-and-paths-1" title="Permalink"></a></h1><p>For drawing shapes, Luxor provides polygons and paths.</p><p>A polygon is an ordered collection of Points stored in an array.</p><p>A path is a sequence of one or more straight and curved (circular arc or BÃ©zier curve) segments. Paths can consist of subpaths. Luxor maintains a &#39;current path&#39;, to which you can add lines and curves until you finish with a stroke or fill instruction.</p><p>Luxor also provides a BezierPath type, which is an array of four-point tuples, each of which is a BÃ©zier cubic curve section.</p><p><img src="../assets/figures/polytable.png" alt="polygons etc"/></p><h2 id="Regular-polygons-(&quot;ngons&quot;)-1"><a class="docs-heading-anchor" href="#Regular-polygons-(&quot;ngons&quot;)-1">Regular polygons (&quot;ngons&quot;)</a><a class="docs-heading-anchor-permalink" href="#Regular-polygons-(&quot;ngons&quot;)-1" title="Permalink"></a></h2><p>A polygon is an array of points. The points can be joined with straight lines.</p><p>You can make regular polygons â€” from triangles, pentagons, hexagons, septagons, heptagons, octagons, nonagons, decagons, and on-and-on-agons â€” with <code>ngon()</code>.</p><pre><code class="language-julia">cols = distinguishable_colors(10)
setline(2)
fontsize(12)
tiles = Tiler(700, 600, 3, 3)

for (pos, n) in tiles
    @layer begin
        translate(pos)

        p = ngon(O, 80, n, vertices=true)

        sethue(cols[n])

        poly(p, :fill, close=true)
        sethue(&quot;black&quot;)
        poly(p, :stroke, close=true)

        circle(O, 4, :fill)

        label.([string(i) for i in 1:n], slope.(O, p), p, offset=5)
    end
end</code></pre><p>The initial orientation of the polygon defaults to 0.</p><p><img src="../assets/figures/n-gon.png" alt="n-gons"/></p><p>If you want to specify the side length rather than the circumradius, use <code>ngonside()</code>.</p><pre><code class="language-julia">for i in 20:-1:3
    sethue(i/20, 0.5, 0.7)
    ngonside(O, 75, i, 0, :fill)
    sethue(&quot;black&quot;)
    ngonside(O, 75, i, 0, :stroke)
end</code></pre><p><img src="../assets/figures/ngonside.png" alt="stars"/></p><p>The functions return the vertices, or you can use the <code>vertices=true</code> option.</p><pre><code class="language-julia">ngon(O, 10, 5)</code></pre><pre><code class="language-5-element"> Point(3.0901699437494745, 9.510565162951535)
 Point(-8.090169943749473, 5.877852522924733)
 Point(-8.090169943749475, -5.87785252292473)
 Point(3.0901699437494723, -9.510565162951536)
 Point(10.0, -2.4492935982947065e-15)</code></pre><article class="docstring"><header><a class="docstring-binding" id="Luxor.ngon" href="#Luxor.ngon"><code>Luxor.ngon</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ngon(x, y, radius, sides=5, orientation=0, action=:nothing;
    vertices=false, reversepath=false)</code></pre><p>Draw a regular polygon centered at point <code>centerpos</code>.</p></div></section><section><div><pre><code class="language-none">ngon(centerpos, radius, sides=5, orientation=0, action=:nothing;
    vertices=false,
    reversepath=false)</code></pre><p>Draw a regular polygon centered at point <code>centerpos</code>.</p><p>Find the vertices of a regular n-sided polygon centered at <code>x</code>, <code>y</code> with circumradius <code>radius</code>.</p><p>The polygon is constructed counterclockwise, starting with the first vertex drawn below the positive x-axis.</p><p>If you just want the raw points, use keyword argument <code>vertices=true</code>, which returns the array of points. Compare:</p><pre><code class="language-julia">ngon(0, 0, 4, 4, 0, vertices=true) # returns the polygon&#39;s points:

    4-element Array{Luxor.Point, 1}:
    Luxor.Point(2.4492935982947064e-16, 4.0)
    Luxor.Point(-4.0, 4.898587196589413e-16)
    Luxor.Point(-7.347880794884119e-16, -4.0)
    Luxor.Point(4.0, -9.797174393178826e-16)</code></pre><p>whereas</p><pre><code class="language-none">ngon(0, 0, 4, 4, 0, :close) #Â draws a polygon</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.ngonside" href="#Luxor.ngonside"><code>Luxor.ngonside</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ngonside(centerpoint::Point, sidelength::Real, sides::Int=5, orientation=0,
    action=:nothing; kwargs...)</code></pre><p>Draw a regular polygon centered at <code>centerpoint</code> with <code>sides</code> sides of length <code>sidelength</code>.</p></div></section></article><h2 id="Stars-1"><a class="docs-heading-anchor" href="#Stars-1">Stars</a><a class="docs-heading-anchor-permalink" href="#Stars-1" title="Permalink"></a></h2><p>Use <code>star()</code> to make a star. You can draw it immediately, or use the points it can create.</p><pre><code class="language-julia">tiles = Tiler(400, 300, 4, 6, margin=5)
for (pos, n) in tiles
    randomhue()
    star(pos, tiles.tilewidth/3, rand(3:8), 0.5, 0, :fill)
end</code></pre><p><img src="../assets/figures/stars.png" alt="stars"/></p><p>The <code>ratio</code> determines the length of the inner radius compared with the outer.</p><pre><code class="language-julia">tiles = Tiler(500, 250, 1, 6, margin=10)
for (pos, n) in tiles
    star(pos, tiles.tilewidth/2, 5, rescale(n, 1, 6, 1, 0), 0, :stroke)
end</code></pre><p><img src="../assets/figures/star-ratios.png" alt="stars"/></p><article class="docstring"><header><a class="docstring-binding" id="Luxor.star" href="#Luxor.star"><code>Luxor.star</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">star(xcenter, ycenter, radius, npoints=5, ratio=0.5, orientation=0, action=:nothing;
    vertices = false,
    reversepath=false)</code></pre><p>Make a star. <code>ratio</code> specifies the height of the smaller radius of the star relative to the larger.</p><p>Use <code>vertices=true</code> to return the vertices of a star instead of drawing it.</p></div></section><section><div><pre><code class="language-none">star(center, radius, npoints=5, ratio=0.5, orientation=0, action=:nothing;
    vertices = false, reversepath=false)</code></pre><p>Draw a star centered at a position:</p></div></section></article><h2 id="Polygons-1"><a class="docs-heading-anchor" href="#Polygons-1">Polygons</a><a class="docs-heading-anchor-permalink" href="#Polygons-1" title="Permalink"></a></h2><p>Use <code>poly()</code> to draw lines connecting the points and/or just fill the area:</p><pre><code class="language-julia">tiles = Tiler(600, 250, 1, 2, margin=20)
tile1, tile2 = collect(tiles)

randompoints = [Point(rand(-100:100), rand(-100:100)) for i in 1:10]

gsave()
translate(tile1[1])
poly(randompoints, :stroke)
grestore()

gsave()
translate(tile2[1])
poly(randompoints, :fill)
grestore()</code></pre><p><img src="../assets/figures/simplepoly.png" alt="simple poly"/></p><article class="docstring"><header><a class="docstring-binding" id="Luxor.poly" href="#Luxor.poly"><code>Luxor.poly</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">poly(bbox::BoundingBox, :action; kwargs...)</code></pre><p>Make a polygon around the BoundingBox in <code>bbox</code>.</p></div></section><section><div><p>Draw a polygon.</p><pre><code class="language-none">poly(pointlist::Array{Point, 1}, action = :nothing;
    close=false,
    reversepath=false)</code></pre><p>A polygon is an Array of Points. By default <code>poly()</code> doesn&#39;t close or fill the polygon, to allow for clipping.</p></div></section></article><p>A polygon can contain holes. The <code>reversepath</code> keyword changes the direction of the polygon. The following piece of code uses <code>ngon()</code> to make and draw two paths, the second forming a hole in the first, to make a hexagonal bolt shape:</p><pre><code class="language-julia">setline(5)
sethue(&quot;gold&quot;)
line(Point(-200, 0), Point(200, 0), :stroke)
sethue(&quot;orchid4&quot;)
ngon(0, 0, 60, 6, 0, :path)
newsubpath()
ngon(0, 0, 40, 6, 0, :path, reversepath=true)
fillstroke()</code></pre><p><img src="../assets/figures/holes.png" alt="holes"/></p><p>The <code>prettypoly()</code> function can place graphics at each vertex of a polygon. After the polygon action, the supplied <code>vertexfunction</code> function is evaluated at each vertex. For example, to mark each vertex of a polygon with a randomly-colored circle:</p><pre><code class="language-julia">apoly = star(O, 70, 7, 0.6, 0, vertices=true)
prettypoly(apoly, :fill, () -&gt;
        begin
            randomhue()
            circle(O, 10, :fill)
        end,
    close=true)</code></pre><p><img src="../assets/figures/prettypolybasic.png" alt="prettypoly"/></p><p>An optional keyword argument <code>vertexlabels</code> lets you pass a function that can number each vertex. The function can use two arguments, the current vertex number, and the total number of points in the polygon:</p><pre><code class="language-julia">apoly = star(O, 80, 5, 0.6, 0, vertices=true)
prettypoly(apoly,
    :stroke,
    vertexlabels = (n, l) -&gt; (text(string(n, &quot; of &quot;, l), halign=:center)),
    close=true)</code></pre><p><img src="../assets/figures/prettypolyvertex.png" alt="prettypoly"/></p><article class="docstring"><header><a class="docstring-binding" id="Luxor.prettypoly" href="#Luxor.prettypoly"><code>Luxor.prettypoly</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prettypoly(bbox::BoundingBox, :action; kwargs...)</code></pre><p>Make a decorated polygon around the BoundingBox in <code>bbox</code>. The vertices are in the order: bottom left, top left, top right, and bottom right.</p></div></section><section><div><pre><code class="language-none">prettypoly(points::Array{Point, 1}, action=:nothing, vertexfunction = () -&gt; circle(O, 2, :stroke);
    close=false,
    reversepath=false,
    vertexlabels = (n, l) -&gt; ()
    )</code></pre><p>Draw the polygon defined by <code>points</code>, possibly closing and reversing it, using the current parameters, and then evaluate the <code>vertexfunction</code> function at every vertex of the polygon.</p><p>The default vertexfunction draws a 2 pt radius circle.</p><p>To mark each vertex of a polygon with a randomly colored filled circle:</p><pre><code class="language-none">p = star(O, 70, 7, 0.6, 0, vertices=true)
prettypoly(p, :fill, () -&gt;
    begin
        randomhue()
        circle(O, 10, :fill)
    end,
    close=true)</code></pre><p>The optional keyword argument <code>vertexlabels</code> lets you supply a function with two arguments that can access the current vertex number and the total number of vertices at each vertex. For example, you can label the vertices of a triangle &quot;1 of 3&quot;, &quot;2 of 3&quot;, and &quot;3 of 3&quot; using:</p><pre><code class="language-none">prettypoly(triangle, :stroke,
    vertexlabels = (n, l) -&gt; (text(string(n, &quot; of &quot;, l))))</code></pre></div></section></article><p>Recursive decoration is possible:</p><pre><code class="language-julia">decorate(pos, p, level) = begin
    if level &lt; 4
        randomhue()
        scale(0.25, 0.25)
        prettypoly(p, :fill, () -&gt; decorate(pos, p, level+1), close=true)
    end
end

apoly = star(O, 100, 7, 0.6, 0, vertices=true)
prettypoly(apoly, :fill, () -&gt; decorate(O, apoly, 1), close=true)</code></pre><p><img src="../assets/figures/prettypolyrecursive.png" alt="prettypoly"/></p><p>Polygons can be simplified using the Douglas-Peucker algorithm (non-recursive version), via <code>simplify()</code>.</p><pre><code class="language-julia">sincurve = [Point(6x, 80sin(x)) for x in -5Ï€:Ï€/20:5Ï€]
prettypoly(collect(sincurve), :stroke,
    () -&gt; begin
            sethue(&quot;red&quot;)
            circle(O, 3, :fill)
          end)
text(string(&quot;number of points: &quot;, length(collect(sincurve))), 0, 100)
translate(0, 200)
simplercurve = simplify(collect(sincurve), 0.5)
prettypoly(simplercurve, :stroke,
    () -&gt; begin
            sethue(&quot;red&quot;)
            circle(O, 3, :fill)
          end)
text(string(&quot;number of points: &quot;, length(simplercurve)), 0, 100)</code></pre><p><img src="../assets/figures/simplify.png" alt="simplify"/></p><article class="docstring"><header><a class="docstring-binding" id="Luxor.simplify" href="#Luxor.simplify"><code>Luxor.simplify</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p>Simplify a polygon:</p><pre><code class="language-none">simplify(pointlist::Array, detail=0.1)</code></pre><p><code>detail</code> is the smallest permitted distance between two points in pixels.</p></div></section></article><p>The <code>isinside()</code> function returns true if a point is inside a polygon.</p><pre><code class="language-julia">apolygon = star(O, 200, 8, 0.5, 0, vertices=true)
for pt in collect(first.(Table(30, 30, 15, 15)))
    sethue(noise(pt.x/600, pt.y/600), noise(pt.x/300, pt.y/300), noise(pt.x/250, pt.y/250))
    isinside(pt, apolygon, allowonedge=true) ? circle(pt, 8, :fill) : circle(pt, 3, :fill)
end</code></pre><p><img src="../assets/figures/isinside.png" alt="isinside"/></p><article class="docstring"><header><a class="docstring-binding" id="Luxor.isinside" href="#Luxor.isinside"><code>Luxor.isinside</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isinside(p::Point, bb:BoundingBox)</code></pre><p>Returns <code>true</code> if <code>pt</code> is inside bounding box <code>bb</code>.</p></div></section><section><div><pre><code class="language-none">isinside(p, pol; allowonedge=false)</code></pre><p>Is a point <code>p</code> inside a polygon <code>pol</code>? Returns true if it does, or false.</p><p>This is an implementation of the Hormann-Agathos (2001) Point in Polygon algorithm.</p><p>The classification of points lying on the edges of the target polygon, or coincident with its vertices is not clearly defined, due to rounding errors or arithmetical inadequacy. By default these will generate errors, but you can suppress these by setting <code>allowonedge</code> to <code>true</code>.</p></div></section></article><p>You can use <code>randompoint()</code> and <code>randompointarray()</code> to create a random Point or list of Points.</p><pre><code class="language-julia">pt1 = Point(-100, -100)
pt2 = Point(100, 100)

sethue(&quot;gray80&quot;)
map(pt -&gt; circle(pt, 6, :fill), (pt1, pt2))
box(pt1, pt2, :stroke)

sethue(&quot;red&quot;)
circle(randompoint(pt1, pt2), 7, :fill)

sethue(&quot;blue&quot;)
map(pt -&gt; circle(pt, 2, :fill), randompointarray(pt1, pt2, 100))</code></pre><p><img src="../assets/figures/randompoints.png" alt="isinside"/></p><article class="docstring"><header><a class="docstring-binding" id="Luxor.randompoint" href="#Luxor.randompoint"><code>Luxor.randompoint</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randompoint(lowpt, highpt)</code></pre><p>Return a random point somewhere inside the rectangle defined by the two points.</p></div></section><section><div><pre><code class="language-none">randompoint(lowx, lowy, highx, highy)</code></pre><p>Return a random point somewhere inside a rectangle defined by the four values.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.randompointarray" href="#Luxor.randompointarray"><code>Luxor.randompointarray</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randompointarray(lowpt, highpt, n)</code></pre><p>Return an array of <code>n</code> random points somewhere inside the rectangle defined by two points.</p></div></section><section><div><pre><code class="language-none">randompointarray(lowx, lowy, highx, highy, n)</code></pre><p>Return an array of <code>n</code> random points somewhere inside the rectangle defined by the four coordinates.</p></div></section></article><h3 id="Quickly-changing-polygons-1"><a class="docs-heading-anchor" href="#Quickly-changing-polygons-1">Quickly changing polygons</a><a class="docs-heading-anchor-permalink" href="#Quickly-changing-polygons-1" title="Permalink"></a></h3><p>If you want to quickly and permanently modify a polygon, there&#39;s <code>polymove!()</code>, <code>polyscale!()</code>, <code>polyreflect!()</code>, and <code>polyrotate!()</code>.</p><pre><code class="language-julia">shape = star(O, 10, 5, 0.5, 0, vertices=true)

circle(O, 3, :stroke)

polymove!(shape, O, O + (0, 50))

poly(shape, :stroke, close=true)

for i in 1:20
    poly(polyrotate!(shape, Ï€/5), :fill, close=true)
    polyscale!(shape, 19//18)
end</code></pre><p>The polygon is continually modified (notice the <code>!</code> in the function names).</p><p><img src="../assets/figures/polychange.png" alt="poly changing"/></p><pre><code class="language-julia">pgon = randompointarray(BoundingBox()/2 ..., 10)
polymove!(pgon, O, Point(-80, 0))
poly(pgon, :fill, close=true)
# reflect in y axis:
polyreflect!(pgon, Point(0, 0), Point(0, 100))
sethue(&quot;blue&quot;)
poly(pgon, :fill, close=true)</code></pre><p><img src="../assets/figures/polyreflect.png" alt="poly reflect"/></p><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyscale!" href="#Luxor.polyscale!"><code>Luxor.polyscale!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">polyscale!(pgon, s;
   center=O)</code></pre><p>Scale (permanently) a polygon by <code>s</code>, relative to <code>center</code>.</p></div></section><section><div><pre><code class="language-none">polyscale!(pgon, sh, sv;
    center=O)</code></pre><p>Scale (permanently) a polygon by <code>sh</code> horizontally and <code>sv</code> vertically, relative to <code>center</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polymove!" href="#Luxor.polymove!"><code>Luxor.polymove!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">polymove!(pgon, frompoint::Point, topoint::Point)</code></pre><p>Move (permanently) a polygon from <code>frompoint</code> to <code>topoints</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyreflect!" href="#Luxor.polyreflect!"><code>Luxor.polyreflect!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">polyreflect!(pgon, pt1 = O, pt2 = O + (0, 100)</code></pre><p>Reflect (permanently) a polygon in a line (default to the y-axis) joining two points.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyrotate!" href="#Luxor.polyrotate!"><code>Luxor.polyrotate!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">polyrotate!(pgon, Î¸;
    center=O)</code></pre><p>Rotate (permanently) a polygon around <code>center</code> by <code>Î¸</code> radians.</p></div></section></article><h3 id="Other-functions-1"><a class="docs-heading-anchor" href="#Other-functions-1">Other functions</a><a class="docs-heading-anchor-permalink" href="#Other-functions-1" title="Permalink"></a></h3><p>There are a number of experimental polygon functions. These won&#39;t work well for polygons that aren&#39;t simple or where the sides intersect each other, but they sometimes do a reasonable job. For example, here&#39;s <code>polysplit()</code>:</p><pre><code class="language-julia">s = squircle(O, 60, 60, vertices=true)
pt1 = Point(0, -120)
pt2 = Point(0, 120)
line(pt1, pt2, :stroke)
poly1, poly2 = polysplit(s, pt1, pt2)
randomhue()
poly(poly1, :fill)
randomhue()
poly(poly2, :fill)</code></pre><p><img src="../assets/figures/polysplit.png" alt="polysplit"/></p><article class="docstring"><header><a class="docstring-binding" id="Luxor.polysplit" href="#Luxor.polysplit"><code>Luxor.polysplit</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">polysplit(p, p1, p2)</code></pre><p>Split a polygon into two where it intersects with a line. It returns two polygons:</p><pre><code class="language-none">(poly1, poly2)</code></pre><p>This doesn&#39;t always work, of course. For example, a polygon the shape of the letter &quot;E&quot; might end up being divided into more than two parts.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polysortbydistance" href="#Luxor.polysortbydistance"><code>Luxor.polysortbydistance</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p>Sort a polygon by finding the nearest point to the starting point, then the nearest point to that, and so on.</p><pre><code class="language-none">polysortbydistance(p, starting::Point)</code></pre><p>You can end up with convex (self-intersecting) polygons, unfortunately.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polysortbyangle" href="#Luxor.polysortbyangle"><code>Luxor.polysortbyangle</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p>Sort the points of a polygon into order. Points are sorted according to the angle they make with a specified point.</p><pre><code class="language-none">polysortbyangle(pointlist::Array, refpoint=minimum(pointlist))</code></pre><p>The <code>refpoint</code> can be chosen, but the minimum point is usually OK too:</p><pre><code class="language-none">polysortbyangle(parray, polycentroid(parray))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polycentroid" href="#Luxor.polycentroid"><code>Luxor.polycentroid</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p>Find the centroid of simple polygon.</p><pre><code class="language-none">polycentroid(pointlist)</code></pre><p>Returns a point. This only works for simple (non-intersecting) polygons.</p><p>You could test the point using <code>isinside()</code>.</p></div></section></article><h3 id="Smoothing-polygons-1"><a class="docs-heading-anchor" href="#Smoothing-polygons-1">Smoothing polygons</a><a class="docs-heading-anchor-permalink" href="#Smoothing-polygons-1" title="Permalink"></a></h3><p>Because polygons can have sharp corners, the experimental <code>polysmooth()</code> function attempts to insert arcs at the corners and draw the result.</p><p>The original polygon is shown in red; the smoothed polygon is shown on top:</p><pre><code class="language-julia">tiles = Tiler(600, 250, 1, 5, margin=10)
for (pos, n) in tiles
    p = star(pos, tiles.tilewidth/2 - 2, 5, 0.3, 0, vertices=true)
    sethue(&quot;red&quot;)
    poly(p, close=true, :stroke)
    sethue(&quot;black&quot;)
    polysmooth(p, n * 2, :fill)
end</code></pre><p><img src="../assets/figures/polysmooth.svg" alt="polysmooth"/></p><p>The final polygon shows that you can get unexpected results if you attempt to smooth corners by more than the possible amount. The <code>debug=true</code> option draws the circles if you want to find out what&#39;s going wrong, or if you want to explore the effect in more detail.</p><pre><code class="language-julia">p = star(O, 60, 5, 0.35, 0, vertices=true)
setdash(&quot;dot&quot;)
sethue(&quot;red&quot;)
prettypoly(p, close=true, :stroke)
setdash(&quot;solid&quot;)
sethue(&quot;black&quot;)
polysmooth(p, 40, :fill, debug=true)</code></pre><p><img src="../assets/figures/polysmooth-pathological.svg" alt="polysmooth"/></p><article class="docstring"><header><a class="docstring-binding" id="Luxor.polysmooth" href="#Luxor.polysmooth"><code>Luxor.polysmooth</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">polysmooth(points, radius, action=:action; debug=false)</code></pre><p>Make a closed path from the <code>points</code> and round the corners by making them arcs with the given radius. Execute the action when finished.</p><p>The arcs are sometimes different sizes: if the given radius is bigger than the length of the shortest side, the arc can&#39;t be drawn at its full radius and is therefore drawn as large as possible (as large as the shortest side allows).</p><p>The <code>debug</code> option also draws the construction circles at each corner.</p></div></section></article><h3 id="Offsetting-polygons-1"><a class="docs-heading-anchor" href="#Offsetting-polygons-1">Offsetting polygons</a><a class="docs-heading-anchor-permalink" href="#Offsetting-polygons-1" title="Permalink"></a></h3><p>The experimental <code>offsetpoly()</code> function constructs an outline polygon outside or inside an existing polygon. In the following example, the dotted red polygon is the original, the black polygons have positive offsets and surround the original, the cyan polygons have negative offsets and run inside the original. Use <code>poly()</code> to draw the result returned by <code>offsetpoly()</code>.</p><pre><code class="language-julia">p = star(O, 45, 5, 0.5, 0, vertices=true)
sethue(&quot;red&quot;)
setdash(&quot;dot&quot;)
poly(p, :stroke, close=true)
setdash(&quot;solid&quot;)
sethue(&quot;black&quot;)

poly(offsetpoly(p, 20), :stroke, close=true)
poly(offsetpoly(p, 25), :stroke, close=true)
poly(offsetpoly(p, 30), :stroke, close=true)
poly(offsetpoly(p, 35), :stroke, close=true)

sethue(&quot;darkcyan&quot;)

poly(offsetpoly(p, -10), :stroke, close=true)
poly(offsetpoly(p, -15), :stroke, close=true)
poly(offsetpoly(p, -20), :stroke, close=true)</code></pre><p><img src="../assets/figures/polyoffset-simple.png" alt="offset poly"/></p><p>The function is intended for simple cases, and it can go wrong if pushed too far. Sometimes the offset distances can be larger than the polygon segments, and things will start to go wrong. In this example, the offset goes so far negative that the polygon overshoots the origin, becomes inverted and starts getting larger again.</p><p><img src="../assets/figures/polygon-offset.gif" alt="offset poly problem"/></p><article class="docstring"><header><a class="docstring-binding" id="Luxor.offsetpoly" href="#Luxor.offsetpoly"><code>Luxor.offsetpoly</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">offsetpoly(path::Array{Point, 1}, d)</code></pre><p>Return a polygon that is offset from a polygon by <code>d</code> units.</p><p>The incoming set of points <code>path</code> is treated as a polygon, and another set of points is created, which form a polygon lying <code>d</code> units away from the source poly.</p><p>Polygon offsetting is a topic on which people have written PhD theses and published academic papers, so this short brain-dead routine will give good results for simple polygons up to a point (!). There are a number of issues to be aware of:</p><ul><li><p>very short lines tend to make the algorithm &#39;flip&#39; and produce larger lines</p></li><li><p>small polygons that are counterclockwise and larger offsets may make the new</p></li></ul><p>polygon appear the wrong side of the original</p><ul><li><p>very sharp vertices will produce even sharper offsets, as the calculated intersection point veers off to infinity</p></li><li><p>duplicated adjacent points might cause the routine to scratch its head and wonder how to draw a line parallel to them</p></li></ul></div></section></article><h3 id="Fitting-splines-1"><a class="docs-heading-anchor" href="#Fitting-splines-1">Fitting splines</a><a class="docs-heading-anchor-permalink" href="#Fitting-splines-1" title="Permalink"></a></h3><p>The experimental <code>polyfit()</code> function constructs a B-spline that follows the points approximately.</p><pre><code class="language-julia">pts = [Point(x, rand(-100:100)) for x in -280:30:280]
setopacity(0.7)
sethue(&quot;red&quot;)
prettypoly(pts, :none, () -&gt; circle(O, 5, :fill))
sethue(&quot;darkmagenta&quot;)
poly(polyfit(pts, 200), :stroke)</code></pre><p><img src="../assets/figures/polyfit.png" alt="offset poly"/></p><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyfit" href="#Luxor.polyfit"><code>Luxor.polyfit</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">polyfit(plist::Array, npoints=30)</code></pre><p>Build a polygon that constructs a B-spine approximation to it. The resulting list of points makes a smooth path that runs between the first and last points.</p></div></section></article><h2 id="Converting-paths-to-polygons-1"><a class="docs-heading-anchor" href="#Converting-paths-to-polygons-1">Converting paths to polygons</a><a class="docs-heading-anchor-permalink" href="#Converting-paths-to-polygons-1" title="Permalink"></a></h2><p>You can convert the current path to an array of polygons, using <code>pathtopoly()</code>.</p><p>In the next example, the path consists of a number of paths, some of which are subpaths, which form the holes.</p><pre><code class="language-julia">textpath(&quot;get polygons from paths&quot;)
plist = pathtopoly()
for (n, pgon) in enumerate(plist)
    randomhue()
    prettypoly(pgon, :stroke, close=true)
    gsave()
    translate(0, 100)
    poly(polysortbyangle(pgon, polycentroid(pgon)), :stroke, close=true)
    grestore()
end</code></pre><p><img src="../assets/figures/path-to-poly.png" alt="path to polygon"/></p><p>The <code>pathtopoly()</code> function calls <code>getpathflat()</code> to convert the current path to an array of polygons, with each curved section flattened to line segments.</p><p>The <code>getpath()</code> function gets the current path as an array of elements, lines, and unflattened curves.</p><article class="docstring"><header><a class="docstring-binding" id="Luxor.pathtopoly" href="#Luxor.pathtopoly"><code>Luxor.pathtopoly</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pathtopoly()</code></pre><p>Convert the current path to an array of polygons.</p><p>Returns an array of polygons, corresponding to the paths and subpaths of the original path.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.getpath" href="#Luxor.getpath"><code>Luxor.getpath</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getpath()</code></pre><p>Get the current path and return a CairoPath object, which is an array of <code>element_type</code> and <code>points</code> objects. With the results you can step through and examine each entry:</p><pre><code class="language-none">o = getpath()
for e in o
      if e.element_type == Cairo.CAIRO_PATH_MOVE_TO
          (x, y) = e.points
          move(x, y)
      elseif e.element_type == Cairo.CAIRO_PATH_LINE_TO
          (x, y) = e.points
          # straight lines
          line(x, y)
          strokepath()
          circle(x, y, 1, :stroke)
      elseif e.element_type == Cairo.CAIRO_PATH_CURVE_TO
          (x1, y1, x2, y2, x3, y3) = e.points
          # Bezier control lines
          circle(x1, y1, 1, :stroke)
          circle(x2, y2, 1, :stroke)
          circle(x3, y3, 1, :stroke)
          move(x, y)
          curve(x1, y1, x2, y2, x3, y3)
          strokepath()
          (x, y) = (x3, y3) #Â update current point
      elseif e.element_type == Cairo.CAIRO_PATH_CLOSE_PATH
          closepath()
      else
          error(&quot;unknown CairoPathEntry &quot; * repr(e.element_type))
          error(&quot;unknown CairoPathEntry &quot; * repr(e.points))
      end
  end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.getpathflat" href="#Luxor.getpathflat"><code>Luxor.getpathflat</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getpathflat()</code></pre><p>Get the current path, like <code>getpath()</code> but flattened so that there are no BÃ¨zier curves.</p><p>Returns a CairoPath which is an array of <code>element_type</code> and <code>points</code> objects.</p></div></section></article><h2 id="Polygons-to-BÃ©zier-paths-and-back-again-1"><a class="docs-heading-anchor" href="#Polygons-to-BÃ©zier-paths-and-back-again-1">Polygons to BÃ©zier paths and back again</a><a class="docs-heading-anchor-permalink" href="#Polygons-to-BÃ©zier-paths-and-back-again-1" title="Permalink"></a></h2><p>Use the <code>makebezierpath()</code> and <code>drawbezierpath()</code> functions to make and draw BÃ©zier paths, and <code>pathtobezierpaths()</code> to convert the current path to an array of BÃ©zier paths.  </p><p>A BezierPath type contains a sequence of <code>BezierPathSegment</code>s; each curve segment is defined by four points: two end points and their control points.</p><pre><code class="language-none">    (Point(-129.904, 75.0),        # start point
     Point(-162.38, 18.75),        # ^ control point
     Point(-64.9519, -150.0),      # v control point
     Point(-2.75546e-14, -150.0)), # end point
    (Point(-2.75546e-14, -150.0),
     Point(64.9519, -150.0),
     Point(162.38, 18.75),
     Point(129.904, 75.0)),
    (Point(129.904, 75.0),
     Point(97.4279, 131.25),
     Point(-97.4279, 131.25),
     Point(-129.904, 75.0)
     ),
     ...</code></pre><p>BÃ©zier paths are different from ordinary paths in that they don&#39;t usually contain straight line segments. However, by setting the two control points to be the same as their matching start/end points, you create straight line sections.</p><p><code>makebezierpath()</code> takes the points in a polygon and converts each line segment into one BÃ©zier curve. <code>drawbezierpath()</code> draws the resulting sequence.</p><pre><code class="language-julia">pts = ngon(O, 150, 3, pi/6, vertices=true)
bezpath = makebezierpath(pts)
poly(pts, :stroke)
for (p1, c1, c2, p2) in bezpath[1:end-1]
    circle.([p1, p2], 4, :stroke)
    circle.([c1, c2], 2, :fill)
    line(p1, c1, :stroke)
    line(p2, c2, :stroke)
end
sethue(&quot;black&quot;)
setline(3)
drawbezierpath(bezpath, :stroke, close=false)</code></pre><p><img src="../assets/figures/abezierpath.png" alt="path to polygon"/></p><pre><code class="language-julia">tiles = Tiler(600, 300, 1, 4, margin=20)
for (pos, n) in tiles
    @layer begin
        translate(pos)
        pts = polysortbyangle(
                randompointarray(
                    Point(-tiles.tilewidth/2, -tiles.tilewidth/2),
                    Point(tiles.tilewidth/2, tiles.tilewidth/2),
                    4))
        setopacity(0.7)
        sethue(&quot;black&quot;)
        prettypoly(pts, :stroke, close=true)
        randomhue()
        drawbezierpath(makebezierpath(pts), :fill)
    end
end</code></pre><p><img src="../assets/figures/bezierpaths.png" alt="path to polygon"/></p><p>You can convert a BÃ©zier path to a polygon (an array of points), using the <code>bezierpathtopoly()</code> function. This chops up the curves into a series of straight line segments. An optional <code>steps</code> keyword lets you specify how many line segments are used to approximate each BÃ©zier segment.</p><p>In this example, the original star is drawn in a dotted gray line, then converted to a BÃ©zier path (drawn in orange), then the BÃ©zier path is converted (with low resolution) to a polygon but offset by 20 units before being drawn (in blue).</p><pre><code class="language-julia">pgon = star(O, 250, 5, 0.6, 0, vertices=true)

@layer begin
 setgrey(0.5)
 setdash(&quot;dot&quot;)
 poly(pgon, :stroke, close=true)
 setline(5)
end

setline(4)

sethue(&quot;orangered&quot;)

np = makebezierpath(pgon)
drawbezierpath(np, :stroke)

sethue(&quot;steelblue&quot;)
p = bezierpathtopoly(np, steps=3)

q1 = offsetpoly(p, 20)
prettypoly(q1, :stroke, close=true)</code></pre><p><img src="../assets/figures/bezierpathtopoly.png" alt="path to polygon"/></p><p>You can convert the current path to an array of BezierPaths using the <code>pathtobezierpaths()</code> function.</p><p>In the next example, the letter &quot;a&quot; is placed at the current position (set by <code>move()</code>) and then converted to an array of BÃ©zier paths. Each BÃ©zier path is drawn first of all in gray, then the control points of segment are drawn (in orange) showing how they affect the curvature.</p><pre><code class="language-julia">st = &quot;a&quot;
thefontsize = 500
fontsize(thefontsize)
sethue(&quot;red&quot;)
tex = textextents(st)
move(-tex[3]/2, tex[4]/2)
textpath(st)
nbps = pathtobezierpaths()
setline(1.5)
for nbp in nbps
    sethue(&quot;grey80&quot;)
    drawbezierpath(nbp, :stroke)
    for p in nbp
        sethue(&quot;darkorange&quot;)
        circle(p[2], 2.0, :fill)
        circle(p[3], 2.0, :fill)
        line(p[2], p[1], :stroke)
        line(p[3], p[4], :stroke)
        if p[1] != p[4]
            sethue(&quot;black&quot;)
            circle(p[1], 2.0, :fill)
            circle(p[4], 2.0, :fill)
        end
    end
end</code></pre><p><img src="../assets/figures/pathtobezierpaths.png" alt="path to polygon"/></p><h2 id="Brush-strokes-1"><a class="docs-heading-anchor" href="#Brush-strokes-1">Brush strokes</a><a class="docs-heading-anchor-permalink" href="#Brush-strokes-1" title="Permalink"></a></h2><p>The <code>brush()</code> function builds Bezier paths in a quasi-random fashion, that could look like brush strokes. The optional keyword arguments allow a range of different effects.</p><p>You can pass a function that can adjust various drawing settings before the shapes are drawn.</p><pre><code class="language-julia">brushÎ±(nbpb) = begin
    setline(1)
    setopacity(0.3)
    drawbezierpath(nbpb, :stroke)
    sethue(0.2, 0.3, rand(0.3:0.01:0.65))
    return nbpb
end

function numberit(pos, n)
    @layer begin
        sethue(&quot;black&quot;)
        text(string(n), pos)
    end
end

t  = Tiler(800, 700, 5, 1)
sethue(&quot;orange3&quot;)
fontsize(20)
for (pos, n) in t
    start, finish = pos - (200, 0), pos + (200, 0)
    if n == 1
        # five brush strokes
        brush(start, finish, 1)
        numberit(pos, n)
    elseif n == 2
        # minwidth and maxwidth control the, er, width
         brush(start, finish, 5, minwidth = -5, maxwidth = 2)
         numberit(pos, n)
    elseif n == 3
        # dont have to have transparent strokes
         brush(start, finish, 20, minwidth = .2, randomopacity = false)
         numberit(pos, n)
    elseif n == 4
        # twist and adjust handles to taste
         brush(start, finish, minwidth = -.1, maxwidth = .2,
             twist = 2, highhandle = 2, tidystart=false)
         numberit(pos, n)
    elseif n == 5
        # call a function to modify each stroke
        brush(start, finish, 1, minwidth = -2.2, maxwidth = .8,
            lowhandle = -.4, highhandle = 1.5, twist = .5,
            strokefunction = brushÎ±)
        numberit(pos, n)
    end
end</code></pre><p><img src="../assets/figures/brush1.png" alt="brush 1"/></p><p>For more information (and more than you probably wanted to know) about Luxor&#39;s BÃ©zier paths, visit <a href="https://cormullion.github.io/blog/2018/06/21/bezier.html">https://cormullion.github.io/blog/2018/06/21/bezier.html</a>.</p><article class="docstring"><header><a class="docstring-binding" id="Luxor.bezier" href="#Luxor.bezier"><code>Luxor.bezier</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bezier(t, A::Point, A1::Point, B1::Point, B::Point)</code></pre><p>Return the result of evaluating the Bezier cubic curve function, <code>t</code> going from 0 to 1, starting at A, finishing at B, control points A1 (controlling A), and B1 (controlling B).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.bezierâ€²" href="#Luxor.bezierâ€²"><code>Luxor.bezierâ€²</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p>bezierâ€²(t, A::Point, A1::Point, B1::Point, B::Point)</p><p>Return the first derivative of the Bezier function.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.bezierâ€²â€²" href="#Luxor.bezierâ€²â€²"><code>Luxor.bezierâ€²â€²</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bezierâ€²â€²(t, A::Point, A1::Point, B1::Point, B::Point)</code></pre><p>Return the second derivative of Bezier function.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.beziercurvature" href="#Luxor.beziercurvature"><code>Luxor.beziercurvature</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">beziercurvature(t, A::Point, A1::Point, B1::Point, B::Point)</code></pre><p>Return the curvature of the Bezier curve at <code>t</code> ([0-1]), given start and end points A and B, and control points A1 and B1. The value (kappa) will typically be a value between -0.001 and 0.001 for points with coordinates in the 100-500 range.</p><p>Îº(t) is the curvature of the curve at point t, which for a parametric planar curve is:</p><div>\[\begin{equation}
\kappa = \frac{\mid \dot{x}\ddot{y}-\dot{y}\ddot{x}\mid}
    {(\dot{x}^2 + \dot{y}^2)^{\frac{3}{2}}}
nd{equation}\]</div><p>The radius of curvature, or the radius of an osculating circle at a point, is 1/Îº(t). Values of 1/Îº will typically be in the range -1000 to 1000 for points with coordinates in the 100-500 range.</p><p>TODO Fix overshoot...</p><p>...The value of kappa can sometimes collapse near 0, returning NaN (and Inf for radius of curvature).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.bezierfrompoints" href="#Luxor.bezierfrompoints"><code>Luxor.bezierfrompoints</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bezierfrompoints(startpoint::Point, pointonline1::Point,
    pointonline2::Point, endpoint::Point)</code></pre><p>Given four points, return the Bezier curve that passes through all four points, starting at <code>startpoint</code> and ending at <code>endpoint</code>. The two middle points of the returned BezierPathSegment are the two control points that make the curve pass through the two middle points supplied.</p></div></section><section><div><pre><code class="language-none">bezierfrompoints(ptslist::Array{Point, 1})</code></pre><p>Given four points, return the Bezier curve that passes through all four points.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.bezierpathtopoly" href="#Luxor.bezierpathtopoly"><code>Luxor.bezierpathtopoly</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bezierpathtopoly(bezierpath::BezierPath; steps=10)</code></pre><p>Convert a Bezier path (an array of Bezier segments, where each segment is a tuple of four points: anchor1, control1, control2, anchor2) to a polygon.</p><p>To make a Bezier path, use <code>makebezierpath()</code> on a polygon.</p><p>The <code>steps</code> optional keyword determines how many line sections are used for each path.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.bezierstroke" href="#Luxor.bezierstroke"><code>Luxor.bezierstroke</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bezierstroke(point1, point2, width=0.0)</code></pre><p>Return a BezierPath, a stroked version of a straight line between two points.</p><p>It wil have 2 or 6 Bezier path segments that define a brush or pen shape. If width is 0, the brush shape starts and ends at a point. Otherwise the brush shape starts and ends with the thick end.</p><p>To draw it, use eg <code>drawbezierpath(..., :fill)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.beziertopoly" href="#Luxor.beziertopoly"><code>Luxor.beziertopoly</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">beziertopoly(bpseg::BezierPathSegment; steps=10)</code></pre><p>Convert a Bezier segment to a polygon (an array of points).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.drawbezierpath" href="#Luxor.drawbezierpath"><code>Luxor.drawbezierpath</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">drawbezierpath(bezierpath::BezierPath, action=:none;
    close=true)</code></pre><p>Draw the BÃ©zier path, and apply the action, such as <code>:none</code>, <code>:stroke</code>, <code>:fill</code>, etc. By default the path is closed.</p></div></section><section><div><pre><code class="language-none">drawbezierpath(bps::BezierPathSegment, action=:none;
    close=false)</code></pre><p>Draw the BÃ©zier path segment, and apply the action, such as <code>:none</code>, <code>:stroke</code>, <code>:fill</code>, etc. By default the path is open.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.makebezierpath" href="#Luxor.makebezierpath"><code>Luxor.makebezierpath</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">makebezierpath(pgon::Array{Point, 1}; smoothing=1)</code></pre><p>Return a BÃ©zier path (a BezierPath) that represents a polygon (an array of points). The BÃ©zier path is an array of segments (tuples of 4 points); each segment contains the four points that make up a section of the entire BÃ©zier path. <code>smoothing</code> determines how closely the curve follows the polygon. A value of 0 returns a straight-sided path; as values move above 1 the paths deviate further from the original polygon&#39;s edges.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.pathtobezierpaths" href="#Luxor.pathtobezierpaths"><code>Luxor.pathtobezierpaths</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pathtobezierpaths(
    ; flat=true)</code></pre><p>Convert the current path (which may consist of one or more paths) to an array of Bezier paths. Each Bezier path is, in turn, an array of path segments. Each path segment is a tuple of four points. A straight line is converted to a Bezier segment in which the control points are set to be the same as the end points.</p><p>If <code>flat</code> is true, use <code>getpathflat()</code> rather than <code>getpath()</code>.</p><p><strong>Example</strong></p><p>This code draws the Bezier segments and shows the control points as &quot;handles&quot;, like a vector-editing program might.</p><pre><code class="language-none">@svg begin
    fontface(&quot;MyanmarMN-Bold&quot;)
    st = &quot;goo&quot;
    thefontsize = 100
    fontsize(thefontsize)
    sethue(&quot;red&quot;)
    fontsize(thefontsize)
    textpath(st)
    nbps = pathtobezierpaths()
    for nbp in nbps
        setline(.15)
        sethue(&quot;grey50&quot;)
        drawbezierpath(nbp, :stroke)
        for p in nbp
            sethue(&quot;red&quot;)
            circle(p[2], 0.16, :fill)
            circle(p[3], 0.16, :fill)
            line(p[2], p[1], :stroke)
            line(p[3], p[4], :stroke)
            if p[1] != p[4]
                sethue(&quot;black&quot;)
                circle(p[1], 0.26, :fill)
                circle(p[4], 0.26, :fill)
            end
        end
    end
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setbezierhandles" href="#Luxor.setbezierhandles"><code>Luxor.setbezierhandles</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setbezierhandles(bps::BezierPathSegment;
        angles  = [0.05, -0.1],
        handles = [0.3, 0.3])</code></pre><p>Return a new Bezier path segment with new locations for the Bezier control points in the Bezier path segment <code>bps</code>.</p><p><code>angles</code> are the two angles that the &quot;handles&quot; make with the line direciton.</p><p><code>handles</code> are the lengths of the &quot;handles&quot;. 0.3 is a typical value.</p></div></section><section><div><pre><code class="language-none">setbezierhandles(bezpath::BezierPath;
        angles=[0 .05, -0.1],
        handles=[0.3, 0.3])</code></pre><p>Return a new Bezierpath with new locations for the Bezier control points in every Bezier path segment of the BezierPath in <code>bezpath</code>.</p><p><code>angles</code> are the two angles that the &quot;handles&quot; make with the line direciton.</p><p><code>handles</code> are the lengths of the &quot;handles&quot;. 0.3 is a typical value.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.shiftbezierhandles" href="#Luxor.shiftbezierhandles"><code>Luxor.shiftbezierhandles</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">shiftbezierhandles(bps::BezierPathSegment;
    angles=[0.1, -0.1], handles=[1.1, 1.1])</code></pre><p>Return a new BezierPathSegment that modifies the Bezier path in <code>bps</code> by moving the control handles. The values in <code>angles</code> increase the angle of the handles; the values in <code>handles</code> modifies the lengths: 1 preserves the length, 0.5 halves the length of the  handles, 2 doubles them.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.findbeziercontrolpoints" href="#Luxor.findbeziercontrolpoints"><code>Luxor.findbeziercontrolpoints</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">findbeziercontrolpoints(previouspt::Point,
    pt1::Point,
    pt2::Point,
    nextpt::Point;
    smooth_value=0.5)</code></pre><p>Find the BÃ©zier control points for the line between <code>pt1</code> and <code>pt2</code>, where the point before <code>pt1</code> is <code>previouspt</code> and the next point after <code>pt2</code> is <code>nextpt</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.brush" href="#Luxor.brush"><code>Luxor.brush</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">brush(pt1, pt2, width=10;
    strokes=10,
    minwidth=0.01,
    maxwidth=0.03,
    twist = -1,
    lowhandle  = 0.3,
    highhandle = 0.7,
    randomopacity = true,
    tidystart = false,
    action = :fill,
    strokefunction = (nbpb) -&gt; nbpb))</code></pre><p>Draw a composite brush stroke made up of some randomized individual filled Bezier paths.</p><p><code>strokefunction</code> allows a function to process a BezierPathSegment or do other things before it&#39;s drawn.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>There is a lot of randomness in this function. Results are unpredictable.</p></div></div></div></section></article><h2 id="Polygon-information-1"><a class="docs-heading-anchor" href="#Polygon-information-1">Polygon information</a><a class="docs-heading-anchor-permalink" href="#Polygon-information-1" title="Permalink"></a></h2><p><code>polyperimeter</code> calculates the length of a polygon&#39;s perimeter.</p><pre><code class="language-julia">p = box(O, 50, 50, vertices=true)
poly(p, :stroke)
text(string(round(polyperimeter(p, closed=false))), O.x, O.y + 60)

translate(200, 0)

poly(p, :stroke, close=true)
text(string(round(polyperimeter(p, closed=true))), O.x, O.y + 60)</code></pre><p><img src="../assets/figures/polyperimeter.png" alt="polyperimeter"/></p><h2 id="Polygon-selection-and-modification-1"><a class="docs-heading-anchor" href="#Polygon-selection-and-modification-1">Polygon selection and modification</a><a class="docs-heading-anchor-permalink" href="#Polygon-selection-and-modification-1" title="Permalink"></a></h2><p>There are Luxor functions to return the first part or last part of a polygon. You can also ask for a resampling of a polygon, choosing either to increase the number of points (which places new points to the &quot;lines&quot; joining the vertices) or decrease them (which changes the shape of the polygon). It&#39;s also possible to insert vertices automatically.</p><p><code>polyportion()</code> and <code>polyremainder()</code> return part of a polygon depending on the fraction you supply. For example, <code>polyportion(p, 0.5)</code> returns the first half of polygon <code>p</code>, <code>polyremainder(p, .75)</code> returns the last quarter of it.</p><pre><code class="language-julia">p = ngon(O, 100, 7, 0, vertices=true)
poly(p, :stroke, close=true)
setopacity(0.75)

setline(20)
sethue(&quot;red&quot;)
poly(polyportion(p, 0.25), :stroke)

setline(10)
sethue(&quot;green&quot;)
poly(polyportion(p, 0.5), :stroke)

setline(5)
sethue(&quot;blue&quot;)
poly(polyportion(p, 0.75), :stroke)

setline(1)
circle(polyremainder(p, 0.75)[1], 5, :stroke) # first point</code></pre><p><img src="../assets/figures/polyportion.png" alt="polyportion"/></p><p>You can insert vertices in the edges of a polygon with <code>insertvertices!()</code>. For example, this code inserts a new vertex into each side of a polygon five times. The polygon ends up with 128 vertices.</p><pre><code class="language-julia">pts = box(O, 500, 200, vertices=true)
prettypoly(pts, :stroke, close=true)

for i in 1:5
    insertvertices!(pts)
    prettypoly(pts, :stroke, close=true)
    fontsize(16)
    label(string(length(pts)), :ne, pts[1], offset=10)
    scale(0.8)
end</code></pre><p><img src="../assets/figures/insertvertices.png" alt="poly insert vertices"/></p><p>To resample a polygon, use <code>polysample()</code>. In this example, the same four-sided polygon is resampled at multiples of 4, with different circle radii at each multiple. This adds more points to the new copy of the original polygon.</p><pre><code class="language-julia">pts = ngon(O, 100, 4, vertices=true)
for (n, npoints) in enumerate(reverse([4, 8, 16, 32, 48]))
    prettypoly(polysample(pts, npoints),
        :stroke, close=true,
        () -&gt; begin
                circle(O, 2n, :stroke)
              end)
end</code></pre><p><img src="../assets/figures/polysample.png" alt="polysampling"/></p><p>There is a <code>closed</code> option, which determines whether or not the final edge (the one that would join the final vertex to the first), is included in the sampling. In the following example, the original polygon is drawn in black, then sampled as a closed polygon (in blue), then as a non-closed one (magenta).</p><pre><code class="language-julia"># original polygon

numbervertices(l, n) = label(string(l), :N, O)
drawvertices() = ngon(O, 3, 4, 0, :fill)

pts = [Point(30x, 20sin(x)) for x in -2Ï€:Ï€/6:2Ï€]

# 1: drawn as defined

prettypoly(pts, &quot;stroke&quot;, drawvertices, vertexlabels = numbervertices)

translate(0, 50)


# 2: resampled as closed

npoints = 40

sethue(&quot;cornflowerblue&quot;)
prettypoly(polysample(pts, npoints, closed=true), :stroke, drawvertices,
    vertexlabels = numbervertices)

translate(0, 50)

# 3: resampled as open

sethue(&quot;magenta&quot;)
prettypoly(polysample(pts, npoints, closed=false), :stroke, drawvertices,
    vertexlabels = numbervertices)</code></pre><p><img src="../assets/figures/polysample2.png" alt="polysampling 2"/></p><article class="docstring"><header><a class="docstring-binding" id="Luxor.polysample" href="#Luxor.polysample"><code>Luxor.polysample</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">polysample(p::Array{Point, 1}, npoints::T where T &lt;: Integer;
        closed=true)</code></pre><p>Sample the polygon <code>p</code>, returning a polygon with <code>npoints</code> to represent it. The first sampled point is:</p><pre><code class="language-none"> 1/`npoints` * `perimeter of p`</code></pre><p>away from the original first point of <code>p</code>.</p><p>If <code>npoints</code> is the same as <code>length(p)</code> the returned polygon is the same as the original, but the first point finishes up at the end (so <code>new=circshift(old, 1)</code>).</p><p>If <code>closed</code> is true, the entire polygon (including the edge joining the last point to the first point) is sampled.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.insertvertices!" href="#Luxor.insertvertices!"><code>Luxor.insertvertices!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insertvertices!(pgon;
    ratio=0.5)</code></pre><p>Insert a new vertex into each edge of a polygon <code>pgon</code>. The default <code>ratio</code> of 0.5 divides the original edge of the polygon into half.</p></div></section></article><h3 id="Polygon-side-lengths-1"><a class="docs-heading-anchor" href="#Polygon-side-lengths-1">Polygon side lengths</a><a class="docs-heading-anchor-permalink" href="#Polygon-side-lengths-1" title="Permalink"></a></h3><p><code>polydistances</code> returns an array of the accumulated side lengths of a polygon.</p><pre><code class="language-none">julia&gt; p = ngon(O, 100, 7, 0, vertices=true);
julia&gt; polydistances(p)
8-element Array{Real,1}:
   0.0000
  86.7767
 173.553
 260.33
 347.107
 433.884
 520.66
 607.437</code></pre><p>It&#39;s used by <code>polyportion()</code> and <code>polyremainder()</code>, and you can pre-calculate and pass them to these functions via keyword arguments for performance. By default the result includes the final closing segment (<code>closed=true</code>).</p><p>These functions also make use of the <code>nearestindex()</code>, which returns a tuple of: the index of the nearest value in an array of distances to a given value; and the excess value.</p><p>In this example, we want to find a point halfway round the perimeter of a triangle. Use <code>nearestindex()</code> to find the index of the nearest vertex (<code>nidx</code>, 2), and the surplus length, (<code>over</code>, 100).</p><pre><code class="language-julia">p = ngonside(O, 200, 3, vertices=true)
prettypoly(p, :stroke, close=true, vertexlabels = (n, l) -&gt; label(string(n), :NW, offset=10))

# distances array
da = polydistances(p)

nidx, over = nearestindex(da, polyperimeter(p)/2)

sethue(&quot;red&quot;)
circle(p[nidx], 5, :stroke)

arrow(p[nidx],
      between(p[nidx], p[nidx+1], over/distance(p[nidx], p[nidx+1])),
      linewidth=2)</code></pre><p><img src="../assets/figures/nearestindex.png" alt="nearestindex"/></p><p>Of course, it&#39;s much easier to do <code>polyportion(p, 0.5)</code>.</p><h3 id="Area-of-polygon-1"><a class="docs-heading-anchor" href="#Area-of-polygon-1">Area of polygon</a><a class="docs-heading-anchor-permalink" href="#Area-of-polygon-1" title="Permalink"></a></h3><p>Use <code>polyarea()</code> to find the area of a polygon. Of course, this only works for simple polygons; polygons that intersect themselves or have holes are not correctly processed.</p><p>This code draws some regular polygons and calculates their area, perimeter, and shows how near the ratio of perimeter over radius approaches 2Ï€.</p><pre><code class="language-julia">fontface(&quot;Georgia&quot;)
sethue(&quot;black&quot;)
setline(0.25)
outerframe = Table([500], [400, 200])
total = 30
properties = Table(fill(15, total), [20, 85, 85], outerframe[1, 2])
radius = 55
sethue(&quot;grey20&quot;)
for i in 3:total
    global radius
    text(string(i), properties[i, 1], halign=:right)
    p = ngon(outerframe[1], radius, i, 0, vertices=true)
    prettypoly(p, :stroke, close=true, () -&gt; (sethue(&quot;red&quot;); circle(O, 2, :fill)))
    pa = polyarea(p)
    pp = polyperimeter(p)
    ppoverradius = pp/radius
    text(string(Int(round(pa, digits=0))), properties[i, 2], halign=:left)
    text(string(round(ppoverradius, digits=6)), properties[i, 3], halign=:left)
    radius += 5
end

fontsize(10)
[text([&quot;Sides&quot;, &quot;Area&quot;, &quot;Perimeter/Radius&quot;][n], pt, halign=:center)
    for (pt, n) in Table([20], [20, 85, 85], outerframe[2] - (0, 220))]</code></pre><p><img src="../assets/figures/polyarea.png" alt="poly area"/></p><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyperimeter" href="#Luxor.polyperimeter"><code>Luxor.polyperimeter</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">polyperimeter(p::Array{Point, 1}; closed=true)</code></pre><p>Find the total length of the sides of polygon <code>p</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyportion" href="#Luxor.polyportion"><code>Luxor.polyportion</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">polyportion(p::Array{Point, 1}, portion=0.5; closed=true, pdist=[])</code></pre><p>Return a portion of a polygon, starting at a value between 0.0 (the beginning) and 1.0 (the end). 0.5 returns the first half of the polygon, 0.25 the first quarter, 0.75 the first three quarters, and so on.</p><p>If you already have a list of the distances between each point in the polygon (the &quot;polydistances&quot;), you can pass them in <code>pdist</code>, otherwise they&#39;ll be calculated afresh, using <code>polydistances(p, closed=closed)</code>.</p><p>Use the complementary <code>polyremainder()</code> function to return the other part.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyremainder" href="#Luxor.polyremainder"><code>Luxor.polyremainder</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">polyremainder(p::Array{Point, 1}, portion=0.5; closed=true, pdist=[])</code></pre><p>Return the rest of a polygon, starting at a value between 0.0 (the beginning) and 1.0 (the end). 0.5 returns the last half of the polygon, 0.25 the last three quarters, 0.75 the last quarter, and so on.</p><p>If you already have a list of the distances between each point in the polygon (the &quot;polydistances&quot;), you can pass them in <code>pdist</code>, otherwise they&#39;ll be calculated afresh, using <code>polydistances(p, closed=closed)</code>.</p><p>Use the complementary <code>polyportion()</code> function to return the other part.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polydistances" href="#Luxor.polydistances"><code>Luxor.polydistances</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">polydistances(p::Array{Point, 1}; closed=true)</code></pre><p>Return an array of the cumulative lengths of a polygon.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.nearestindex" href="#Luxor.nearestindex"><code>Luxor.nearestindex</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nearestindex(polydistancearray, value)</code></pre><p>Return a tuple of the index of the largest value in <code>polydistancearray</code> less than <code>value</code>, and the difference value. Array is assumed to be sorted.</p><p>(Designed for use with <code>polydistances()</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyarea" href="#Luxor.polyarea"><code>Luxor.polyarea</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">polyarea(p::Array)</code></pre><p>Find the area of a simple polygon. It works only for polygons that don&#39;t self-intersect. See also <code>polyorientation()</code>.</p></div></section></article><h2 id="Other-polygon-operations-1"><a class="docs-heading-anchor" href="#Other-polygon-operations-1">Other polygon operations</a><a class="docs-heading-anchor-permalink" href="#Other-polygon-operations-1" title="Permalink"></a></h2><p>These functions are still in development. Expect varying degrees of success when using them.</p><h3 id="Intersections-1"><a class="docs-heading-anchor" href="#Intersections-1">Intersections</a><a class="docs-heading-anchor-permalink" href="#Intersections-1" title="Permalink"></a></h3><p><code>intersectlinepoly(pt1, pt2, polygon)</code> returns an array containing the points where a line from <code>pt1</code> to <code>pt2</code> crosses the perimeter of the <code>polygon</code>.</p><pre><code class="language-julia">setline(0.3)
sethue(&quot;thistle&quot;)
c = star(O, 120, 7, 0.2, vertices=true)
poly(c, :fillstroke, close=true)
for n in 1:15
    pt1 = Point(rand(-250:250, 2)...)
    pt2 = Point(rand(-250:250, 2)...)
    ips = intersectlinepoly(pt1, pt2, c)
    if !isempty(ips)
            sethue(&quot;grey20&quot;)
            line(pt1, pt2, :stroke)
            randomhue()
            circle.(ips, 2, :fill)
    else
        sethue(&quot;grey80&quot;)
        line(pt1, pt2, :stroke)
    end
end</code></pre><p><img src="../assets/figures/linepolyintersections.png" alt="line/polygon intersections"/></p><p><code>polyintersect</code> calculates the intersection points of two polygons.</p><pre><code class="language-julia">pentagon = ngon(O, 250, 5, vertices=true)
square = box(O + (80, 20), 280, 400, vertices=true)

poly(pentagon, :stroke, close=true)
poly(square, :stroke, close=true)

sethue(&quot;orange&quot;)
circle.(polyintersect(pentagon, square), 8, :fill)</code></pre><p><img src="../assets/figures/polyintersections.png" alt="polygon intersections"/></p><p>The returned polygon contains the points where one polygon crosses another.</p><article class="docstring"><header><a class="docstring-binding" id="Luxor.intersectlinepoly" href="#Luxor.intersectlinepoly"><code>Luxor.intersectlinepoly</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">intersectlinepoly(pt1::Point, pt2::Point, C)</code></pre><p>Return an array of the points where a line between pt1 and pt2 crosses polygon C.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyintersect" href="#Luxor.polyintersect"><code>Luxor.polyintersect</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">polyintersect(p1::AbstractArray{Point, 1}, p2::AbstractArray{Point, 1};
    closed=true)</code></pre><p>TODO: Fix/test/improve this experimental polygon intersection routine.</p><p>Return the points where polygon p1 and polygon p2 cross.</p><p>If <code>closed</code> is false, the intersection points must lie on the first <code>n - 1</code> lines of each polygon.</p></div></section></article><h3 id="Triangulation-1"><a class="docs-heading-anchor" href="#Triangulation-1">Triangulation</a><a class="docs-heading-anchor-permalink" href="#Triangulation-1" title="Permalink"></a></h3><p>Use <code>polytriangulate()</code> to join the vertices of a polygon to form triangles. It returns an array of triangular polygons.</p><pre><code class="language-julia">pts = ngon(O, 200, 7, vertices=true)
triangles = polytriangulate(pts)

for (n, tri) in enumerate(triangles)
    sethue([Luxor.julia_purple,
            Luxor.julia_blue,
            Luxor.julia_red,
            Luxor.julia_green
            ][mod1(n, end)])
    poly(offsetpoly(tri, -2), :fill, close = true)
    sethue(&quot;white&quot;)
    text(string(n), polycentroid(tri), halign=:center)
end

sethue(&quot;red&quot;)
setline(3)
poly(pts, :stroke, close=true)</code></pre><p><img src="../assets/figures/polytriangulate.png" alt="polygon triangulation"/></p><article class="docstring"><header><a class="docstring-binding" id="Luxor.polytriangulate" href="#Luxor.polytriangulate"><code>Luxor.polytriangulate</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">polytriangulate(plist::Array{Point,1}; epsilon = -0.01)</code></pre><p>Triangulate the polygon in <code>plist</code>.</p><p>This uses the Bowyerâ€“Watson/Delaunay algorithm to make triangles. It returns an array of triangular polygons.</p><p>TODO: This experimental polygon function is not very efficient, because it first copies the list of points (to avoid modifying the original), and sorts it, before making triangles.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../colors-styles/">Â« Colors and styles</a><a class="docs-footer-nextpage" href="../text/">Text Â»</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 3 March 2020 10:53">Tuesday 3 March 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
