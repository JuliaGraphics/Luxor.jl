<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Draw simple shapes · Luxor</title><meta name="title" content="Draw simple shapes · Luxor"/><meta property="og:title" content="Draw simple shapes · Luxor"/><meta property="twitter:title" content="Draw simple shapes · Luxor"/><meta name="description" content="Documentation for Luxor."/><meta property="og:description" content="Documentation for Luxor."/><meta property="twitter:description" content="Documentation for Luxor."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/luxor-docs.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Luxor logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Luxor</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction to Luxor</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorial/helloworld/">Hello World</a></li><li><a class="tocitem" href="../../tutorial/basicpath/">Basic path building</a></li><li><a class="tocitem" href="../../tutorial/quickstart/">Design a logo</a></li><li><a class="tocitem" href="../../tutorial/basictutorial/">Geometry tutorial</a></li><li><a class="tocitem" href="../../tutorial/pixels/">Playing with pixels</a></li><li><a class="tocitem" href="../../tutorial/simple-animation/">Simple animation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../example/examples/">Simple examples</a></li><li><a class="tocitem" href="../../example/moreexamples/">More examples</a></li><li><a class="tocitem" href="../../example/gallery/">Gallery</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">How to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../createdrawings/">Create drawings</a></li><li class="is-active"><a class="tocitem" href>Draw simple shapes</a><ul class="internal"><li><a class="tocitem" href="#Line-width"><span>Line width</span></a></li><li><a class="tocitem" href="#Rectangles-and-boxes"><span>Rectangles and boxes</span></a></li><li><a class="tocitem" href="#Triangles,-pentagons,-and-regular-polygons"><span>Triangles, pentagons, and regular polygons</span></a></li><li><a class="tocitem" href="#Circles-and-ellipses"><span>Circles and ellipses</span></a></li><li><a class="tocitem" href="#Circles-and-tangents"><span>Circles and tangents</span></a></li><li><a class="tocitem" href="#Crescents"><span>Crescents</span></a></li><li><a class="tocitem" href="#Paths-and-positions"><span>Paths and positions</span></a></li><li><a class="tocitem" href="#Lines"><span>Lines</span></a></li><li><a class="tocitem" href="#Arrows"><span>Arrows</span></a></li><li><a class="tocitem" href="#Arcs-and-curves"><span>Arcs and curves</span></a></li><li><a class="tocitem" href="#More-curved-shapes:-sectors,-spirals,-and-squircles"><span>More curved shapes: sectors, spirals, and squircles</span></a></li><li><a class="tocitem" href="#Stars-and-crosses"><span>Stars and crosses</span></a></li><li><a class="tocitem" href="#Stored-paths"><span>Stored paths</span></a></li><li><a class="tocitem" href="#Julia-logos"><span>Julia logos</span></a></li><li><a class="tocitem" href="#Hypotrochoids"><span>Hypotrochoids</span></a></li><li><a class="tocitem" href="#Ticks"><span>Ticks</span></a></li><li><a class="tocitem" href="#Cropmarks"><span>Cropmarks</span></a></li><li><a class="tocitem" href="#Dimensioning"><span>Dimensioning</span></a></li><li><a class="tocitem" href="#Barcharts"><span>Barcharts</span></a></li><li><a class="tocitem" href="#Box-maps"><span>Box maps</span></a></li></ul></li><li><a class="tocitem" href="../geometrytools/">Use geometry tools</a></li><li><a class="tocitem" href="../tables-grids/">Work with tables and grids</a></li><li><a class="tocitem" href="../colors-styles/">Use colors and styles</a></li><li><a class="tocitem" href="../polygons/">Work with polygons</a></li><li><a class="tocitem" href="../text/">Add text</a></li><li><a class="tocitem" href="../clipping/">Clip graphics</a></li><li><a class="tocitem" href="../images/">Placing images</a></li><li><a class="tocitem" href="../turtle/">Turtle graphics</a></li><li><a class="tocitem" href="../animation/">Make animations</a></li><li><a class="tocitem" href="../snapshots/">Snapshots</a></li><li><a class="tocitem" href="../livegraphics/">Interactive graphics and Threads</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Explanations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../explanation/basics/">Basic concepts</a></li><li><a class="tocitem" href="../../explanation/pathspolygons/">Paths vs Polygon</a></li><li><a class="tocitem" href="../../explanation/perfectpixels/">Perfect pixels and antialising</a></li><li><a class="tocitem" href="../../explanation/transforms/">Transforms and matrices</a></li><li><a class="tocitem" href="../../explanation/imagematrix/">Image matrix</a></li><li><a class="tocitem" href="../../explanation/fonts/">Fonts on Linux</a></li><li><a class="tocitem" href="../../explanation/luxorcairo/">Luxor and Cairo</a></li><li><a class="tocitem" href="../../explanation/strokepathdispatch/">Customize strokepath/fillpath</a></li><li><a class="tocitem" href="../../explanation/contributing/">Contributing</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/functionindex/">Alphabetical function list</a></li><li><a class="tocitem" href="../../reference/api/">Function reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">How to guides</a></li><li class="is-active"><a href>Draw simple shapes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Draw simple shapes</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGraphics/Luxor.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGraphics/Luxor.jl/blob/master/docs/src/howto/simplegraphics.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Simple-graphics"><a class="docs-heading-anchor" href="#Simple-graphics">Simple graphics</a><a id="Simple-graphics-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-graphics" title="Permalink"></a></h1><p>In Luxor, there are different ways of working with graphical items:</p><ul><li><p>Draw them immediately. Create lines and curves to build a <strong>path</strong> on the drawing. When you paint the path, the graphics are ‘fixed’, and you move on to the next.</p></li><li><p>Construct arrays of points - <strong>polygons</strong> - which you can draw at some later point. Watch out for a <code>vertices=true</code> option, which returns coordinate data rather than adding shapes to the current path.</p></li><li><p>You can combine these two approaches: create a path from lines and curves (and jumps), then store the path, ready for drawing later on.</p></li></ul><h2 id="Line-width"><a class="docs-heading-anchor" href="#Line-width">Line width</a><a id="Line-width-1"></a><a class="docs-heading-anchor-permalink" href="#Line-width" title="Permalink"></a></h2><p>The default line width in Luxor is 2 points. (Typically 1 point is 0.352777mm, 1/72.0inch.) Set the line width with <a href="../../reference/api/#Luxor.setline-Tuple{Any}"><code>setline</code></a>. Find the current line width with <a href="../../reference/api/#Luxor.getline-Tuple{}"><code>getline</code></a>. By default, line widths don&#39;t vary depending on the current drawing scale, but you can ask for them to be scaled - see <a href="../../explanation/transforms/#Scaling-of-line-thickness">Scaling-of-line-thickness</a>.</p><h2 id="Rectangles-and-boxes"><a class="docs-heading-anchor" href="#Rectangles-and-boxes">Rectangles and boxes</a><a id="Rectangles-and-boxes-1"></a><a class="docs-heading-anchor-permalink" href="#Rectangles-and-boxes" title="Permalink"></a></h2><p>Simple rectangle and box shapes can be made in different ways.</p><pre><code class="language-julia hljs">rulers()
sethue(&quot;grey40&quot;)
rect(Point(0, 0), 100, 100, action = :stroke)
sethue(&quot;blue&quot;)
box(Point(0, 0), 100, 100, action=:stroke)</code></pre><p><img src="../../assets/figures/basicrects.png" alt="rect vs box"/></p><p><a href="../../reference/api/#Luxor.rect-NTuple{4, Real}"><code>rect</code></a> rectangles are positioned by a corner, a box made with <a href="../../reference/api/#Luxor.box-Tuple{Array, Symbol}"><code>box</code></a> can be defined either by its center and dimensions, or by two opposite corners.</p><img src="aa6362a8.svg" alt="Example block output"/><p>If you want the coordinates of the corners of a box, rather than draw one immediately, use:</p><pre><code class="language-julia hljs">box(centerpoint, width, height, vertices=true)</code></pre><p>or</p><pre><code class="language-julia hljs">box(corner1,  corner2, vertices=true)</code></pre><p><a href="../../reference/api/#Luxor.box-Tuple{Array, Symbol}"><code>box</code></a> is also able to draw some of the other Luxor objects, such as BoundingBoxes and Table cells, and usually also returns the coordinates of the corners.</p><pre><code class="language-julia hljs">box(Point(0, 0), 100, 100)</code></pre><pre><code class="nohighlight hljs">4-element Array{Point,1}:
 Point(-50.0, 50.0)
 Point(-50.0, -50.0)
 Point(50.0, -50.0)
 Point(50.0, 50.0)</code></pre><p>To draw a box/rectangle with rounded corners, supply one or four values for corner radii.</p><pre><code class="language-julia hljs">setline(6)
box(O, 200, 150, 10, action = :stroke) # 1 value for all corners
sethue(&quot;purple&quot;)
box(O, 260, 220, [0, 15, 40, 80], action = :stroke) # different for each</code></pre><p><img src="../../assets/figures/round-rect-1.png" alt="rounded rect 1"/></p><p>Or you could smooth the sharp corners of a box, like so:</p><pre><code class="language-julia hljs">setline(4)
polysmooth(box(O, 200, 150, vertices=true), 10, action = :stroke)</code></pre><p><img src="../../assets/figures/round-rect.png" alt="rounded rect"/></p><p>The <a href="../../reference/api/#Luxor.squircle-Tuple{Point, Real, Real}"><code>squircle</code></a> function makes nicer shapes.</p><h2 id="Triangles,-pentagons,-and-regular-polygons"><a class="docs-heading-anchor" href="#Triangles,-pentagons,-and-regular-polygons">Triangles, pentagons, and regular polygons</a><a id="Triangles,-pentagons,-and-regular-polygons-1"></a><a class="docs-heading-anchor-permalink" href="#Triangles,-pentagons,-and-regular-polygons" title="Permalink"></a></h2><p>For regular polygons, pentagons, and so on, see the section on <a href="../polygons/#Polygons-and-paths">Polygons and paths</a>. If you like drawing hexagons, you could also read <a href="../tables-grids/#Hexagonal-grids">Hexagonal grids</a>.</p><h2 id="Circles-and-ellipses"><a class="docs-heading-anchor" href="#Circles-and-ellipses">Circles and ellipses</a><a id="Circles-and-ellipses-1"></a><a class="docs-heading-anchor-permalink" href="#Circles-and-ellipses" title="Permalink"></a></h2><p>There are various ways to make circles, including by center and radius, or passing through two or three points:</p><pre><code class="language-julia hljs">sethue(&quot;black&quot;)
p1 = Point(0, -50)
p2 = Point(100, 0)
p3 = Point(0, 65)
map(p -&gt; circle(p, 4, action = :fill), [p1, p2, p3])
sethue(&quot;orange&quot;)
circle(center3pts(p1, p2, p3)..., action = :stroke)

sethue(&quot;red&quot;)
p1 = Point(0, 30)
p2 = Point(20, -40)
p3 = Point(50, 5)
circle.((p1, p2, p3), 3, action = :stroke)
circle(p1, p2, p3, action = :stroke)</code></pre><p><img src="../../assets/figures/circles.png" alt="circles"/></p><p>The <a href="../../reference/api/#Luxor.center3pts-Tuple{Point, Point, Point}"><code>center3pts</code></a> function returns the center position and radius of a circle passing through three points:</p><pre><code class="language-julia hljs">sethue(&quot;black&quot;)
p1 = Point(0, -50)
p2 = Point(100, 0)
p3 = Point(0, 65)
map(p -&gt; circle(p, 4, action = :fill), [p1, p2, p3])
sethue(&quot;orange&quot;)
circle(center3pts(p1, p2, p3)..., action = :stroke)</code></pre><p><img src="../../assets/figures/center3.png" alt="center and radius of 3 points"/></p><p>With <a href="../../reference/api/#Luxor.ellipse-Tuple{Point, Point, Any}"><code>ellipse</code></a> you can place ellipses and circles by defining the center point and the width and height.</p><pre><code class="language-julia hljs">tiles = Tiler(500, 300, 5, 5)
width = 20
height = 25
for (pos, n) in tiles
    global width, height
    randomhue()
    ellipse(pos, width, height, action = :fill)
    sethue(&quot;black&quot;)
    label = string(round(width/height, digits=2))
    textcentered(label, pos.x, pos.y + 25)
    width += 2
end</code></pre><p><img src="../../assets/figures/ellipses.png" alt="ellipses"/></p><p><a href="../../reference/api/#Luxor.ellipse-Tuple{Point, Point, Any}"><code>ellipse</code></a> can also construct polygons that are approximations to ellipses. You supply two focal points and a length which is the sum of the distances of a point on the perimeter to the two focii.</p><pre><code class="language-julia hljs">fontface(&quot;Menlo&quot;)

f1 = Point(-100, 0)
f2 = Point(100, 0)

circle.([f1, f2], 3, action = :fill)

epoly = ellipse(f1, f2, 250, vertices=true)
poly(epoly, action = :stroke,  close=true)

pt = epoly[rand(1:end)]

poly([f1, pt, f2], action = :stroke)

label(&quot;f1&quot;, :W, f1, offset=10)
label(&quot;f2&quot;, :E, f2, offset=10)

label(string(round(distance(f1, pt), digits=1)), :SE, midpoint(f1, pt))
label(string(round(distance(pt, f2), digits=1)), :SW, midpoint(pt, f2))

label(&quot;ellipse(f1, f2, 250)&quot;, :S, Point(0, 75))</code></pre><p><img src="../../assets/figures/ellipses_1.png" alt="more ellipses"/></p><p>The advantage of this method is that there&#39;s a <code>vertices=true</code> option, allowing further scope for polygon manipulation.</p><pre><code class="language-julia hljs">f1 = Point(-100, 0)
f2 = Point(100, 0)
ellipsepoly = ellipse(f1, f2, 170, :none, vertices=true)
[ begin
    setgray(rescale(c, 150, 1, 0, 1))
    poly(offsetpoly(ellipsepoly, c), close=true, action = :fill);
    rotate(π/20)
  end
     for c in 150:-10:1 ]</code></pre><p><img src="../../assets/figures/ellipses_2.png" alt="even more ellipses"/></p><p>The <a href="../../reference/api/#Luxor.ellipseinquad-Tuple{Any}"><code>ellipseinquad</code></a> function constructs an ellipse that fits inside a four-sided quadrilateral.</p><pre><code class="language-julia hljs">pg = ngon(O, 250, 6, π/6, vertices=true)

top = vcat(O, pg[[3, 4, 5]])
left = vcat(O, pg[[1, 2, 3]])
right = vcat(O, pg[[5, 6, 1]])
sethue(&quot;red&quot;)
poly(top, action = :fill, close=true)

sethue(&quot;green&quot;)
poly(left, action = :fill, close=true)

sethue(&quot;blue&quot;)
poly(right, action = :fill, close=true)

sethue(&quot;orange&quot;)
ellipseinquad.((top, left, right), action = :fill)</code></pre><p><img src="../../assets/figures/ellipseinquad.png" alt="ellipse in quadrilateral"/></p><p><a href="../../reference/api/#Luxor.circlepath-Tuple{Point, Any}"><code>circlepath</code></a> constructs a circular path from Bézier curves, which allows you to use circles as paths.</p><pre><code class="language-julia hljs">setline(4)
tiles = Tiler(600, 250, 1, 5)
for (pos, n) in tiles
    randomhue()
    circlepath(pos, tiles.tilewidth/2, action = :path)
    newsubpath()
    circlepath(pos, rand(5:tiles.tilewidth/2 - 1), action = :fill, reversepath=true)
end</code></pre><p><img src="../../assets/figures/circle-path.png" alt="circles as paths"/></p><h2 id="Circles-and-tangents"><a class="docs-heading-anchor" href="#Circles-and-tangents">Circles and tangents</a><a id="Circles-and-tangents-1"></a><a class="docs-heading-anchor-permalink" href="#Circles-and-tangents" title="Permalink"></a></h2><p>Functions to find tangents to circles include:</p><ul><li><a href="../../reference/api/#Luxor.pointcircletangent-Tuple{Point, Point, Any}"><code>pointcircletangent</code></a> finds a point on a circle that lies on line through another point</li><li><a href="../../reference/api/#Luxor.circlecircleoutertangents-Tuple{Point, Any, Point, Any}"><code>circlecircleoutertangents</code></a> finds the points that lie on outer tangents to two circles</li><li><a href="../../reference/api/#Luxor.circlecircleinnertangents-Tuple{Point, Any, Point, Any}"><code>circlecircleinnertangents</code></a> finds the points that lie on inner tangents to two circles</li><li><a href="../../reference/api/#Luxor.circletangent2circles-Tuple{Any, Point, Any, Point, Any}"><code>circletangent2circles</code></a> makes circles of a particular radius tangential to two circles</li><li><a href="../../reference/api/#Luxor.circlepointtangent-Tuple{Point, Any, Point, Any}"><code>circlepointtangent</code></a> makes circles of a particular radius passing through a point and tangential to another circle</li></ul><pre><code class="language-julia hljs">point = Point(-150, 0)
circlecenter = Point(150, 0)
circleradius = 80

circle.((point, circlecenter), 5, action = :fill)
circle(circlecenter, circleradius, action = :stroke)
pt1, pt2 = pointcircletangent(point, circlecenter, circleradius)
circle.((pt1, pt2), 5, action = :fill)

sethue(&quot;grey65&quot;)
rule(point, slope(point, pt1))
rule(point, slope(point, pt2))</code></pre><p><img src="../../assets/figures/point-circle-tangents.png" alt="point circle tangents"/></p><pre><code class="language-julia hljs">circle1center = Point(-150, 0)
circle1radius = 60
circle2center = Point(150, 0)
circle2radius = 80

circle.((circle1center, circle2center), 5, action = :fill)
circle(circle1center, circle1radius, action = :stroke)
circle(circle2center, circle2radius, action = :stroke)

p1, p2, p3, p4 = circlecircleoutertangents(
    circle1center, circle1radius,
    circle2center, circle2radius)

sethue(&quot;orange&quot;)
rule(p1, slope(p1, p2))
rule(p3, slope(p3, p4))</code></pre><p><img src="../../assets/figures/circle-circle-outer-tangents.png" alt="circle circle outer tangents"/></p><p>Finding the inner tangents requires a separate function.</p><pre><code class="language-julia hljs">circle1center = Point(-150, 0)
circle1radius = 60
circle2center = Point(150, 0)
circle2radius = 80

circle.((circle1center, circle2center), 5, action = :fill)
circle(circle1center, circle1radius, action = :stroke)
circle(circle2center, circle2radius, action = :stroke)

p1, p2, p3, p4 = circlecircleinnertangents(
    circle1center, circle1radius,
    circle2center, circle2radius)

label.((&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;, &quot;p4&quot;), :n, (p1, p2, p3, p4))
sethue(&quot;orange&quot;)
rule(p1, slope(p1, p2))
rule(p3, slope(p3, p4))

sethue(&quot;purple&quot;)
circle.((p1, p2, p3, p4), 3, action = :fill)</code></pre><p><img src="../../assets/figures/circle-circle-inner-tangents.png" alt="circle circle inner tangents"/></p><p><a href="../../reference/api/#Luxor.circletangent2circles-Tuple{Any, Point, Any, Point, Any}"><code>circletangent2circles</code></a> takes the required radius and two existing circles:</p><pre><code class="language-julia hljs">circle1 = (Point(-100, 0), 90)
circle(circle1..., action = :stroke)
circle2 = (Point(100, 0), 90)
circle(circle2..., action = :stroke)

requiredradius = 25
ncandidates, p1, p2 = circletangent2circles(requiredradius, circle1..., circle2...)

if ncandidates==2
    sethue(&quot;orange&quot;)
    circle(p1, requiredradius, action = :fill)
    sethue(&quot;green&quot;)
    circle(p2, requiredradius, action = :fill)
    sethue(&quot;purple&quot;)
    circle(p1, requiredradius, action = :stroke)
    circle(p2, requiredradius, action = :stroke)
end

# the circles are 10 apart, so there should be just one circle
# that fits there

requiredradius = 10
ncandidates, p1, p2 = circletangent2circles(requiredradius, circle1..., circle2...)

if ncandidates==1
    sethue(&quot;blue&quot;)
    circle(p1, requiredradius, action = :fill)
    sethue(&quot;cyan&quot;)
    circle(p1, requiredradius, action = :stroke)
end</code></pre><p><img src="../../assets/figures/circle-tangents.png" alt="circle tangents"/></p><p><a href="../../reference/api/#Luxor.circlepointtangent-Tuple{Point, Any, Point, Any}"><code>circlepointtangent</code></a> looks for circles of a specified radius that pass through a point and are tangential to a circle. There are usually two candidates.</p><pre><code class="language-julia hljs">circle1 = (Point(-100, 0), 90)
circle(circle1..., action = :stroke)

requiredradius = 50
requiredpassthrough = O + (80, 0)
ncandidates, p1, p2 = circlepointtangent(requiredpassthrough, requiredradius, circle1...)

if ncandidates==2
    sethue(&quot;orange&quot;)
    circle(p1, requiredradius, action = :stroke)
    sethue(&quot;green&quot;)
    circle(p2, requiredradius, action = :stroke)
end

sethue(&quot;black&quot;)
circle(requiredpassthrough, 4, action = :fill)</code></pre><p><img src="../../assets/figures/circle-point-tangent.png" alt="circle tangents 2"/></p><p>These last two functions can return 0, 1, or 2 points (since there are often two solutions to a specific geometric layout).</p><p><a href="../../reference/api/#Luxor.circlering"><code>circlering</code></a> constructs <code>n</code> circles inside an outer circle and tangent to it. It returns both an array of &#39;circles&#39; (<code>(pt, radius)</code> tuples), and details of the circle that fits inside them.</p><pre><code class="language-julia hljs">    background(&quot;grey10&quot;)
    sethue(&quot;rebeccapurple&quot;)
    setline(3)
    circle(Point(0, 0), 200, :stroke)
    cs, ic = circlering(Point(0, 0), 200, 10)
    for c in cs
        circle(first(c), last(c), :stroke)
    end
    circle(first(ic), last(ic), :stroke)</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="800pt" height="450pt" viewBox="0 0 800 450" version="1.1">
<g id="surface1487">
<rect x="0" y="0" width="800" height="450" style="fill:rgb(10.196078%25,10.196078%25,10.196078%25);fill-opacity:1;stroke:none;"/>
<path style="fill:none;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(40%25,20%25,60%25);stroke-opacity:1;stroke-miterlimit:10;" d="M 600 225 C 600 335.457031 510.457031 425 400 425 C 289.542969 425 200 335.457031 200 225 C 200 114.542969 289.542969 25 400 25 C 510.457031 25 600 114.542969 600 225 Z M 600 225 "/>
<path style="fill:none;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(40%25,20%25,60%25);stroke-opacity:1;stroke-miterlimit:10;" d="M 570.820312 314.808594 C 570.820312 340.882812 549.683594 362.015625 523.609375 362.015625 C 497.535156 362.015625 476.398438 340.882812 476.398438 314.808594 C 476.398438 288.734375 497.535156 267.597656 523.609375 267.597656 C 549.683594 267.597656 570.820312 288.734375 570.820312 314.808594 Z M 570.820312 314.808594 "/>
<path style="fill:none;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(40%25,20%25,60%25);stroke-opacity:1;stroke-miterlimit:10;" d="M 494.425781 370.3125 C 494.425781 396.386719 473.289062 417.523438 447.214844 417.523438 C 421.140625 417.523438 400.003906 396.386719 400.003906 370.3125 C 400.003906 344.238281 421.140625 323.101562 447.214844 323.101562 C 473.289062 323.101562 494.425781 344.238281 494.425781 370.3125 Z M 494.425781 370.3125 "/>
<path style="fill:none;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(40%25,20%25,60%25);stroke-opacity:1;stroke-miterlimit:10;" d="M 399.996094 370.3125 C 399.996094 396.386719 378.859375 417.523438 352.785156 417.523438 C 326.710938 417.523438 305.574219 396.386719 305.574219 370.3125 C 305.574219 344.238281 326.710938 323.101562 352.785156 323.101562 C 378.859375 323.101562 399.996094 344.238281 399.996094 370.3125 Z M 399.996094 370.3125 "/>
<path style="fill:none;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(40%25,20%25,60%25);stroke-opacity:1;stroke-miterlimit:10;" d="M 323.601562 314.808594 C 323.601562 340.882812 302.464844 362.015625 276.390625 362.015625 C 250.316406 362.015625 229.179688 340.882812 229.179688 314.808594 C 229.179688 288.734375 250.316406 267.597656 276.390625 267.597656 C 302.464844 267.597656 323.601562 288.734375 323.601562 314.808594 Z M 323.601562 314.808594 "/>
<path style="fill:none;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(40%25,20%25,60%25);stroke-opacity:1;stroke-miterlimit:10;" d="M 294.417969 225 C 294.417969 251.074219 273.28125 272.210938 247.210938 272.210938 C 221.136719 272.210938 200 251.074219 200 225 C 200 198.925781 221.136719 177.789062 247.210938 177.789062 C 273.28125 177.789062 294.417969 198.925781 294.417969 225 Z M 294.417969 225 "/>
<path style="fill:none;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(40%25,20%25,60%25);stroke-opacity:1;stroke-miterlimit:10;" d="M 323.601562 135.191406 C 323.601562 161.265625 302.464844 182.402344 276.390625 182.402344 C 250.316406 182.402344 229.179688 161.265625 229.179688 135.191406 C 229.179688 109.117188 250.316406 87.984375 276.390625 87.984375 C 302.464844 87.984375 323.601562 109.117188 323.601562 135.191406 Z M 323.601562 135.191406 "/>
<path style="fill:none;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(40%25,20%25,60%25);stroke-opacity:1;stroke-miterlimit:10;" d="M 399.996094 79.6875 C 399.996094 105.761719 378.859375 126.898438 352.785156 126.898438 C 326.710938 126.898438 305.574219 105.761719 305.574219 79.6875 C 305.574219 53.613281 326.710938 32.476562 352.785156 32.476562 C 378.859375 32.476562 399.996094 53.613281 399.996094 79.6875 Z M 399.996094 79.6875 "/>
<path style="fill:none;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(40%25,20%25,60%25);stroke-opacity:1;stroke-miterlimit:10;" d="M 494.425781 79.6875 C 494.425781 105.761719 473.289062 126.898438 447.214844 126.898438 C 421.140625 126.898438 400.003906 105.761719 400.003906 79.6875 C 400.003906 53.613281 421.140625 32.476562 447.214844 32.476562 C 473.289062 32.476562 494.425781 53.613281 494.425781 79.6875 Z M 494.425781 79.6875 "/>
<path style="fill:none;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(40%25,20%25,60%25);stroke-opacity:1;stroke-miterlimit:10;" d="M 570.820312 135.191406 C 570.820312 161.265625 549.683594 182.402344 523.609375 182.402344 C 497.535156 182.402344 476.398438 161.265625 476.398438 135.191406 C 476.398438 109.117188 497.535156 87.984375 523.609375 87.984375 C 549.683594 87.984375 570.820312 109.117188 570.820312 135.191406 Z M 570.820312 135.191406 "/>
<path style="fill:none;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(40%25,20%25,60%25);stroke-opacity:1;stroke-miterlimit:10;" d="M 600 225 C 600 251.074219 578.863281 272.210938 552.789062 272.210938 C 526.71875 272.210938 505.582031 251.074219 505.582031 225 C 505.582031 198.925781 526.71875 177.789062 552.789062 177.789062 C 578.863281 177.789062 600 198.925781 600 225 Z M 600 225 "/>
<path style="fill:none;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(40%25,20%25,60%25);stroke-opacity:1;stroke-miterlimit:10;" d="M 505.582031 225 C 505.582031 283.3125 458.3125 330.582031 400 330.582031 C 341.6875 330.582031 294.417969 283.3125 294.417969 225 C 294.417969 166.6875 341.6875 119.417969 400 119.417969 C 458.3125 119.417969 505.582031 166.6875 505.582031 225 Z M 505.582031 225 "/>
</g>
</svg>
'/><h2 id="Crescents"><a class="docs-heading-anchor" href="#Crescents">Crescents</a><a id="Crescents-1"></a><a class="docs-heading-anchor-permalink" href="#Crescents" title="Permalink"></a></h2><p>Use <a href="../../reference/api/#Luxor.crescent-Tuple{Point, Real, Point, Real}"><code>crescent</code></a> to construct crescent shapes. There are two methods. The first method allows the two arcs to have the same radius. The second method allows the two arcs to share the same centers.</p><pre><code class="language-julia hljs"># method 1: same radius, different centers

sethue(&quot;purple&quot;)
crescent(Point(-200, 0), 200, Point(-150, 0), 200, action = :fill)

# method 2: same center, different radii

sethue(&quot;orange&quot;)
crescent(O, 100, 200, action = :fill)</code></pre><p><img src="../../assets/figures/crescents.png" alt="crescents"/></p><h2 id="Paths-and-positions"><a class="docs-heading-anchor" href="#Paths-and-positions">Paths and positions</a><a id="Paths-and-positions-1"></a><a class="docs-heading-anchor-permalink" href="#Paths-and-positions" title="Permalink"></a></h2><p>A path is a sequence of lines and curves. You can add lines and curves to the current path with various functions, then use <a href="../../reference/api/#Luxor.closepath-Tuple{}"><code>closepath</code></a> to join the last point to the first. Once you fill or stroke it, the path is emptied, and you start again.</p><p>A path can have subpaths, created with<a href="../../reference/api/#Luxor.newsubpath-Tuple{}"><code>newsubpath</code></a>, which can form holes.</p><p>There is a &#39;current point&#39; which you can set with <a href="../../reference/api/#Luxor.move-Tuple{Any, Any}"><code>move</code></a>, and which is updated after functions like <a href="../../reference/api/#Luxor.line-Tuple{Any, Any}"><code>line</code></a>, <a href="../../reference/api/#Luxor.rline-Tuple{Any, Any}"><code>rline</code></a>, <a href="../../reference/api/#Luxor.rmove-Tuple{Any, Any}"><code>rmove</code></a>, <a href="../../reference/api/#Luxor.text-Tuple{AbstractString, Point}"><code>text</code></a>, <a href="../../reference/api/#Luxor.newpath-Tuple{}"><code>newpath</code></a>, <a href="../../reference/api/#Luxor.closepath-Tuple{}"><code>closepath</code></a>, <a href="../../reference/api/#Luxor.arc-Tuple{Point, Any, Any, Any}"><code>arc</code></a>, and <a href="../../reference/api/#Luxor.curve-NTuple{6, Any}"><code>curve</code></a>. Use <a href="../../reference/api/#Luxor.currentpoint-Tuple{}"><code>currentpoint</code></a> and <a href="../../reference/api/#Luxor.hascurrentpoint-Tuple{}"><code>hascurrentpoint</code></a> to find out about it.</p><p>You can store a path for later use with <a href="../../reference/api/#Luxor.storepath-Tuple{}"><code>storepath</code></a> and draw it with <a href="../../reference/api/#Luxor.drawpath-Tuple{Path, Real}"><code>drawpath</code></a>. See <a href="#Stored-paths">Stored paths</a>.</p><p>For more about paths, see <a href="../polygons/#Polygons-and-paths">Polygons and paths</a> and <a href="../../explanation/pathspolygons/#Paths-versus-polygons">Paths versus polygons</a>.</p><h2 id="Lines"><a class="docs-heading-anchor" href="#Lines">Lines</a><a id="Lines-1"></a><a class="docs-heading-anchor-permalink" href="#Lines" title="Permalink"></a></h2><p>Use <a href="../../reference/api/#Luxor.line-Tuple{Any, Any}"><code>line</code></a> and <a href="../../reference/api/#Luxor.rline-Tuple{Any, Any}"><code>rline</code></a> to draw straight lines. <code>line(pt1, pt2, action)</code> makes a path consisting of a line between two points. <code>line(pt)</code> adds a line to the current path going from the most recent current point to <code>pt</code>. <code>rline(pt)</code> adds a line relative to the current point.</p><p>You can use <a href="../../reference/api/#Luxor.rule"><code>rule</code></a> to draw a horizontal line through a point. Supply an angle for lines at an angle to the current x-axis.</p><pre><code class="language-julia hljs">y = 10
for x in 10 .^ range(0, length=100, stop=3)
    global y
    circle(Point(x, y), 2, action = :fill)
    rule(Point(x, y), -π/2, boundingbox=BoundingBox(centered=false))
    y += 2
end</code></pre><p><img src="../../assets/figures/rule.png" alt="arc"/></p><p>Use the <code>boundingbox</code> keyword argument to crop the ruled lines with a BoundingBox.</p><pre><code class="language-julia hljs">origin()
box(BoundingBox() * 0.9, action = :stroke)
for x in 10 .^ range(0, length=100, stop=3)
    rule(Point(x, 0), π/2,  boundingbox=BoundingBox() * 0.9)
    rule(Point(-x, 0), π/2, boundingbox=BoundingBox() * 0.9)
end</code></pre><p><img src="../../assets/figures/rulebbox.png" alt="arc"/></p><h2 id="Arrows"><a class="docs-heading-anchor" href="#Arrows">Arrows</a><a id="Arrows-1"></a><a class="docs-heading-anchor-permalink" href="#Arrows" title="Permalink"></a></h2><p>You can draw lines, arcs, and curves with arrows at the end with <a href="../../reference/api/#Luxor.arrow"><code>arrow</code></a>.</p><table><tr><th style="text-align: left">type</th><th style="text-align: left">function call</th></tr><tr><td style="text-align: left">straight between two points</td><td style="text-align: left">arrow(pt, pt)</td></tr><tr><td style="text-align: left">curved: radius + two angles</td><td style="text-align: left">arrow(pt, rad, θ1, θ2)</td></tr><tr><td style="text-align: left">Bezier 4 points</td><td style="text-align: left">arrow(pt1, pt2, pt3, pt4, action)</td></tr><tr><td style="text-align: left">Bezier start finish + box</td><td style="text-align: left">arrow(pt1, pt2, [ht1, ht2])</td></tr></table><p>For straight arrows, supply the start and end points. For arrows as circular arcs, you provide center, radius, and start and finish angles. You can optionally provide dimensions for the <code>arrowheadlength</code> and <code>arrowheadangle</code> of the tip of the arrow (angle in radians between side and center). The default line weight is 1.0, equivalent to <code>setline(1)</code>, but you can specify another.</p><pre><code class="language-julia hljs">arrow(Point(0, 0), Point(0, -65))
arrow(Point(0, 0), Point(100, -65), arrowheadlength=20, arrowheadangle=pi/4, linewidth=.3)
arrow(Point(0, 0), 100, π, π/2, arrowheadlength=25,   arrowheadangle=pi/12, linewidth=1.25)</code></pre><p><img src="../../assets/figures/arrow.png" alt="arrows"/></p><p>If you provide four points, you can draw a Bézier curve with optional arrowheads at each end. Use the various options to control their presence and appearance.</p><pre><code class="language-julia hljs">pts = ngon(Point(0, 0), 100, 8, vertices=true)
sethue(&quot;mediumvioletred&quot;)
arrow(pts[2:5]..., :stroke, startarrow=false, finisharrow=true)
sethue(&quot;cyan4&quot;)
arrow(pts[3:6]..., startarrow=true, finisharrow=true)
sethue(&quot;midnightblue&quot;)
arrow(pts[[4, 2, 6, 8]]..., :stroke,
    startarrow=true,
    finisharrow=true,
    arrowheadangle = π/6,
    arrowheadlength = 35,
    linewidth  = 1.5)</code></pre><p><img src="../../assets/figures/arrowbezier.png" alt="arrows"/></p><h3 id="Decoration"><a class="docs-heading-anchor" href="#Decoration">Decoration</a><a id="Decoration-1"></a><a class="docs-heading-anchor-permalink" href="#Decoration" title="Permalink"></a></h3><p>The <a href="../../reference/api/#Luxor.arrow"><code>arrow</code></a> functions allow you to specify <strong>decorations</strong> - graphics at one or more points somewhere along the shaft. For example, say you want to draw a number and a circle at the midpoint of an arrow&#39;s shaft, you can define a function that draws text <code>t</code> in a circle of radius <code>r</code> like this:</p><pre><code class="nohighlight hljs">function marker(r, t)
    @layer begin
        sethue(&quot;purple&quot;)
        circle(Point(0, 0), r,  :fill)
        sethue(&quot;white&quot;)
        fontsize(30)
        text(string(t), halign=:center, valign=:middle)
    end
end</code></pre><p>and then pass this to the <code>decorate</code> keyword argument of <code>arrow</code>. By default, the graphics origin when the function is called is placed at the midpoint (0.5) of the arrow&#39;s shaft.</p><pre><code class="language-julia hljs">pts = ngon(Point(0, 0), 100, 5, vertices=true)

sethue(&quot;mediumvioletred&quot;)

# using an anonymous function
arrow(pts[1:4]..., decorate = () -&gt; marker(10, 3))

sethue(&quot;olivedrab&quot;)

# no arrow, just a graphic, at 0.75
arrow(pts[1:4]...,
    decorate = () -&gt;
        ngon(Point(0, 0), 20, 4, 0, action = :fill),
    decoration = 0.75, :none) # default action is :stroke</code></pre><p><img src="../../assets/figures/arrowbezierdecoration.png" alt="arrows with decoration"/></p><p>Use the <code>decoration</code> keyword to specify one or more locations other than the default 0.5.</p><p>The graphics environment provided by the <code>decorate</code> function is centered at each decoration point in turn, and rotated to the slope of the shaft at that point.</p><pre><code class="language-julia hljs">using Luxor

function fletcher()
    line(O, polar(30, deg2rad(220)), action = :stroke)
    line(O, polar(30, deg2rad(140)), action = :stroke)
end

@drawsvg begin
    background(&quot;antiquewhite&quot;)
        arrow(O, 150, 0, π + π/3,
            linewidth=5,
            arrowheadlength=50,
            decorate=fletcher,
            decoration=range(0., .1, length=3))
end 800 350</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="800pt" height="350pt" viewBox="0 0 800 350" version="1.1">
<g id="surface1500">
<rect x="0" y="0" width="800" height="350" style="fill:rgb(98.039216%25,92.156863%25,84.313725%25);fill-opacity:1;stroke:none;"/>
<path style="fill:none;stroke-width:5;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(0%25,0%25,0%25);stroke-opacity:1;stroke-miterlimit:10;" d="M 550 175 C 550 224.484375 525.59375 270.785156 484.769531 298.75 C 443.945312 326.714844 391.953125 332.746094 345.8125 314.871094 C 299.667969 296.992188 265.3125 257.507812 253.984375 209.339844 C 242.65625 161.167969 255.8125 110.507812 289.152344 73.941406 "/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(0%25,0%25,0%25);fill-opacity:1;" d="M 277.015625 59.148438 L 325 45.097656 L 301.007812 88.960938 "/>
<path style="fill:none;stroke-width:5;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(0%25,0%25,0%25);stroke-opacity:1;stroke-miterlimit:10;" d="M 550 175 L 569.285156 152.019531 "/>
<path style="fill:none;stroke-width:5;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(0%25,0%25,0%25);stroke-opacity:1;stroke-miterlimit:10;" d="M 550 175 L 530.714844 152.019531 "/>
<path style="fill:none;stroke-width:5;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(0%25,0%25,0%25);stroke-opacity:1;stroke-miterlimit:10;" d="M 547.183594 203.925781 L 570.539062 185.09375 "/>
<path style="fill:none;stroke-width:5;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(0%25,0%25,0%25);stroke-opacity:1;stroke-miterlimit:10;" d="M 547.183594 203.925781 L 532.695312 177.65625 "/>
<path style="fill:none;stroke-width:5;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(0%25,0%25,0%25);stroke-opacity:1;stroke-miterlimit:10;" d="M 538.84375 231.761719 L 565.390625 217.785156 "/>
<path style="fill:none;stroke-width:5;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(0%25,0%25,0%25);stroke-opacity:1;stroke-miterlimit:10;" d="M 538.84375 231.761719 L 529.691406 203.191406 "/>
</g>
</svg>
'/><h3 id="Custom-arrowheads"><a class="docs-heading-anchor" href="#Custom-arrowheads">Custom arrowheads</a><a id="Custom-arrowheads-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-arrowheads" title="Permalink"></a></h3><p>To make custom arrowheads, you can define a three-argument function that draws them to your own design. This function takes the arguments:</p><ul><li><p>the point at the end of the arrow&#39;s shaft</p></li><li><p>the point where the tip of the arrowhead would be</p></li><li><p>the angle of the shaft at the end</p></li></ul><p>You can then use any code to draw the arrow. Pass this function to the <a href="../../reference/api/#Luxor.arrow"><code>arrow</code></a> function&#39;s <code>arrowheadfunction</code> keyword.</p><pre><code class="language-julia hljs">function redbluearrow(shaftendpoint, endpoint, shaftangle)
    @layer begin
        sethue(&quot;red&quot;)
        sidept1 = shaftendpoint  + polar(10, shaftangle + π/2 )
        sidept2 = shaftendpoint  - polar(10, shaftangle + π/2)
        poly([sidept1, endpoint, sidept2], action=:fill)
        sethue(&quot;blue&quot;)
        poly([sidept1, endpoint, sidept2], action=:stroke, close=false)
    end
end

@drawsvg begin
    background(&quot;antiquewhite&quot;)
    arrow(O, O + (120, 120),
        linewidth=4,
        arrowheadlength=40,
        arrowheadangle=π/7,
        arrowheadfunction = redbluearrow)

    arrow(O, 100, 3π/2, π,
        linewidth=4,
        arrowheadlength=20,
        clockwise=false,arrowheadfunction=redbluearrow)
end 800 250</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="800pt" height="250pt" viewBox="0 0 800 250" version="1.1">
<g id="surface1505">
<rect x="0" y="0" width="800" height="250" style="fill:rgb(98.039216%25,92.156863%25,84.313725%25);fill-opacity:1;stroke:none;"/>
<path style="fill:none;stroke-width:4;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(0%25,0%25,0%25);stroke-opacity:1;stroke-miterlimit:10;" d="M 400 125 L 494.515625 219.515625 "/>
<path style="fill-rule:nonzero;fill:rgb(100%25,0%25,0%25);fill-opacity:1;stroke-width:4;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(0%25,0%25,100%25);stroke-opacity:1;stroke-miterlimit:10;" d="M 487.445312 226.585938 L 520 245 L 501.585938 212.445312 "/>
<path style="fill:none;stroke-width:4;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(0%25,0%25,0%25);stroke-opacity:1;stroke-miterlimit:10;" d="M 400 25 C 351.855469 25 310.546875 59.304688 301.703125 106.628906 "/>
<path style="fill-rule:nonzero;fill:rgb(100%25,0%25,0%25);fill-opacity:1;stroke-width:4;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(0%25,0%25,100%25);stroke-opacity:1;stroke-miterlimit:10;" d="M 291.746094 105.703125 L 300 125 L 311.660156 107.550781 "/>
</g>
</svg>
'/><h2 id="Arcs-and-curves"><a class="docs-heading-anchor" href="#Arcs-and-curves">Arcs and curves</a><a id="Arcs-and-curves-1"></a><a class="docs-heading-anchor-permalink" href="#Arcs-and-curves" title="Permalink"></a></h2><p>There are a few standard arc-drawing commands, such as <a href="../../reference/api/#Luxor.curve-NTuple{6, Any}"><code>curve</code></a>, <a href="../../reference/api/#Luxor.arc-Tuple{Point, Any, Any, Any}"><code>arc</code></a>, <a href="../../reference/api/#Luxor.carc-Tuple{Point, Any, Any, Any}"><code>carc</code></a>, and <a href="../../reference/api/#Luxor.arc2r-Tuple{Point, Point, Point}"><code>arc2r</code></a>. Because these are often used when building complex paths, they usually add arc sections to the current path. To construct a sequence of lines and arcs, use the <code>:path</code> action, followed by a final <code>:stroke</code> or similar.</p><p><a href="../../reference/api/#Luxor.curve-NTuple{6, Any}"><code>curve</code></a> constructs Bézier curves from control points:</p><pre><code class="language-julia hljs">setline(.5)
pt1 = Point(0, -125)
pt2 = Point(200, 125)
pt3 = Point(200, -125)

label.(string.([&quot;O&quot;, &quot;control point 1&quot;, &quot;control point 2&quot;, &quot;control point 3&quot;]),
    :e,
    [O, pt1, pt2, pt3])

sethue(&quot;red&quot;)
map(p -&gt; circle(p, 4, action=:fill), [O, pt1, pt2, pt3])

line(Point(0, 0), pt1, action=:stroke)
line(pt2, pt3, action = :stroke)

sethue(&quot;black&quot;)
setline(3)

# start a path
move(Point(0, 0))
curve(pt1, pt2, pt3) #  add to current path
strokepath()</code></pre><p><img src="../../assets/figures/curve.png" alt="curve"/></p><p><a href="../../reference/api/#Luxor.arc2r-Tuple{Point, Point, Point}"><code>arc2r</code></a> draws a circular arc centered at a point that passes through two other points:</p><pre><code class="language-julia hljs">tiles = Tiler(700, 200, 1, 6)
for (pos, n) in tiles
    c1, pt2, pt3 = ngon(pos, rand(10:50), 3, rand(0:pi/12:2pi), vertices=true)
    sethue(&quot;black&quot;)
    map(pt -&gt; circle(pt, 4, action = :fill), [c1, pt3])
    sethue(&quot;red&quot;)
    circle(pt2, 4, action = :fill)
    randomhue()
    arc2r(c1, pt2, pt3, action = :stroke)
end</code></pre><p><img src="../../assets/figures/arc2r.png" alt="arc"/></p><p><a href="../../reference/api/#Luxor.arc2sagitta-Tuple{Point, Point, Real}"><code>arc2sagitta</code></a> and <a href="../../reference/api/#Luxor.carc2sagitta-Tuple{Point, Point, Real}"><code>carc2sagitta</code></a> make circular arcs based on two points and the <a href="https://en.wikipedia.org/wiki/Sagitta_(geometry)">sagitta</a>.</p><pre><code class="language-julia hljs">pt1 = Point(-100, 0)
pt2 = Point(100, 0)
for n in reverse(range(1, length=7, stop=120))
    sethue(&quot;red&quot;)
    rule(Point(0, -n))
    sethue(LCHab(70, 80, rescale(n, 120, 1, 0, 359)))
    pt, r = arc2sagitta(pt1, pt2, n, action = :fillpreserve)
    sethue(&quot;black&quot;)
    strokepath()
    text(string(round(n)), O + (120, -n))
end
circle.((pt1, pt2), 5, action = :fill)</code></pre><p><img src="../../assets/figures/arc2sagitta.svg" alt="arc"/></p><h2 id="More-curved-shapes:-sectors,-spirals,-and-squircles"><a class="docs-heading-anchor" href="#More-curved-shapes:-sectors,-spirals,-and-squircles">More curved shapes: sectors, spirals, and squircles</a><a id="More-curved-shapes:-sectors,-spirals,-and-squircles-1"></a><a class="docs-heading-anchor-permalink" href="#More-curved-shapes:-sectors,-spirals,-and-squircles" title="Permalink"></a></h2><p>A sector (technically an &quot;annular sector&quot;) has an inner and outer radius, as well as start and end angles.</p><pre><code class="language-julia hljs">sethue(&quot;tomato&quot;)
sector(50, 90, π/2, 0, action=:fill)
sethue(&quot;olive&quot;)
sector(Point(O.x + 200, O.y), 50, 90, 0, π/2, action=:fill)</code></pre><p><img src="../../assets/figures/sector.png" alt="sector"/></p><p>You can also supply a value for a corner radius. The same sector is drawn but with rounded corners.</p><pre><code class="language-julia hljs">sethue(&quot;tomato&quot;)
sector(50, 90, π/2, 0, 15, action = :fill)
sethue(&quot;olive&quot;)
sector(Point(O.x + 200, O.y), 50, 90, 0, π/2, 15, action = :fill)</code></pre><p><img src="../../assets/figures/sectorrounded.png" alt="sector"/></p><p>A pie (or wedge) has start and end angles.</p><pre><code class="language-julia hljs">pie(0, 0, 100, π/2, π, action = :fill)</code></pre><p><img src="../../assets/figures/pie.png" alt="pie"/></p><p>To construct spirals, use the <a href="../../reference/api/#Luxor.spiral-Tuple{Any, Any}"><code>spiral</code></a> function. These can be drawn directly, or used as polygons. The default is to draw Archimedean (non-logarithmic) spirals.</p><pre><code class="language-julia hljs">spiraldata = [
  (-2, &quot;Lituus&quot;,      50),
  (-1, &quot;Hyperbolic&quot;, 100),
  ( 1, &quot;Archimedes&quot;,   1),
  ( 2, &quot;Fermat&quot;,       5)]

grid = GridRect(O - (200, 0), 130, 50)

for aspiral in spiraldata
    @layer begin
        translate(nextgridpoint(grid))
        spiral(last(aspiral), first(aspiral), period=20π, action = :stroke)
        label(aspiral[2], :S, offset=100)
    end
end</code></pre><p><img src="../../assets/figures/spiral.png" alt="spiral"/></p><p>Use the <code>log=true</code> option to draw logarithmic (Bernoulli or Fibonacci) spirals.</p><pre><code class="language-julia hljs">spiraldata = [
    (10,  0.05),
    (4,   0.10),
    (0.5, 0.17)]

grid = GridRect(O - (200, 0), 175, 50)
for aspiral in spiraldata
    @layer begin
        translate(nextgridpoint(grid))
        spiral(first(aspiral), last(aspiral), log=true, period=10π, action = :stroke)
        label(string(aspiral), :S, offset=100)
    end
end</code></pre><p>Modify the <code>stepby</code> and <code>period</code> parameters to taste, or collect the vertices for further processing.</p><p><img src="../../assets/figures/spiral-log.png" alt="spiral log"/></p><p>A <em>squircle</em> is a cross between a square and a circle. You can adjust the squariness and circularity of it to taste by supplying a value for the root (keyword <code>rt</code>):</p><pre><code class="language-julia hljs">setline(2)
tiles = Tiler(600, 250, 1, 3)
for (pos, n) in tiles
    sethue(&quot;lavender&quot;)
    squircle(pos, 80, 80, rt=[0.3, 0.5, 0.7][n], action = :fillpreserve)
    sethue(&quot;grey20&quot;)
    strokepath()
    textcentered(&quot;rt = $([0.3, 0.5, 0.7][n])&quot;, pos)
end</code></pre><p><img src="../../assets/figures/squircle.png" alt="squircles"/></p><h2 id="Stars-and-crosses"><a class="docs-heading-anchor" href="#Stars-and-crosses">Stars and crosses</a><a id="Stars-and-crosses-1"></a><a class="docs-heading-anchor-permalink" href="#Stars-and-crosses" title="Permalink"></a></h2><p>Use <a href="../../reference/api/#Luxor.star"><code>star</code></a> to make a star. You can draw it immediately, or use the array of points it can create.</p><pre><code class="language-julia hljs">tiles = Tiler(400, 300, 4, 6, margin=5)
for (pos, n) in tiles
    randomhue()
    star(pos, tiles.tilewidth/3, rand(3:8), 0.5, 0, action = :fill)
end</code></pre><p><img src="../../assets/figures/stars.png" alt="stars"/></p><p>The <code>ratio</code> determines the length of the inner radius compared with the outer.</p><pre><code class="language-julia hljs">tiles = Tiler(800, 250, 1, 6, margin=10)
for (pos, n) in tiles
    s = star(pos, tiles.tilewidth/2, 5, 1/n, 0, action = :stroke)
    l2 = distance(pos, s[1])
    l1 = distance(pos, s[2])
    text(string(round(l1/l2, digits=2)), pos, halign=:center)
end</code></pre><img src="57609e3d.svg" alt="Example block output"/><p>Use <a href="../../reference/api/#Luxor.polycross"><code>polycross</code></a> to draw a cross-shaped polygon.</p><pre><code class="language-julia hljs">tiles = Tiler(600, 600, 4, 4, margin=10)
for (pos, n) in tiles
    randomhue()
    polycross(pos, min(tiles.tileheight/3, tiles.tilewidth/3),
        n + 2, # number of points
        rescale(n, 1, length(tiles), 0.9, 0.1), # ratio
        0, # orientation
        action=:fill)
end</code></pre><p><img src="../../assets/figures/polycross.png" alt="polycross"/></p><h2 id="Stored-paths"><a class="docs-heading-anchor" href="#Stored-paths">Stored paths</a><a id="Stored-paths-1"></a><a class="docs-heading-anchor-permalink" href="#Stored-paths" title="Permalink"></a></h2><p>It&#39;s possible to store the current path in a Path object. For example, this code:</p><pre><code class="nohighlight hljs">fontsize(160)
fontface(&quot;Bodoni-Poster&quot;)
textpath(&quot;†&quot;, O, halign=:center, valign=:middle)
dagger = storepath()</code></pre><p>stores the instructions to build the current path (which describe the dagger symbol) in <code>dagger</code>.</p><p>The <code>dagger</code> is a Luxor Path type, and contains:</p><pre><code class="nohighlight hljs">PathMove(Point(2.0, 90.5625)),
PathCurve(Point(4.08203125, 68.16015625), Point(11.28125, 45.28125), Point(24.8828125, 26.40234375)),
PathCurve(Point(17.51953125, 22.87890625), Point(2.0, 14.71875), Point(2.0, 5.12109375)),
PathCurve(Point(2.0, 2.5625), Point(3.12109375, 0.640625), Point(5.83984375, 0.640625)),
PathCurve(Point(12.8828125, 0.640625), Point(11.6015625, 14.2421875), Point(26.16015625, 14.2421875)),
PathCurve(Point(35.76171875, 14.2421875), Point(42.0, 7.83984375), Point(42.0, -1.59765625)),
PathCurve(Point(42.0, -10.3984375), Point(34.9609375, -17.4375), Point(26.16015625, -17.4375)),
PathCurve(Point(10.9609375, -17.4375), Point(13.04296875, -3.6796875), Point(6.48046875, -3.6796875)),
PathCurve(Point(3.6015625, -3.6796875), Point(1.83984375, -6.3984375), Point(1.83984375, -9.12109375)),
PathCurve(Point(1.83984375, -14.3984375), Point(12.2421875, -23.6796875), Point(15.44140625, -26.87890625)),
PathCurve(Point(18.640625, -30.078125), Point(19.76171875, -34.3984375), Point(19.76171875, -38.71875)),
PathCurve(Point(19.76171875, -49.7578125), Point(10.9609375, -56.640625), Point(0.40234375, -56.640625)),
PathCurve(Point(-11.1171875, -56.640625), Point(-19.91796875, -49.7578125), Point(-19.91796875, -38.71875)),
PathCurve(Point(-19.91796875, -34.3984375), Point(-18.80078125, -30.078125), Point(-15.59765625, -26.87890625)),
PathCurve(Point(-12.3984375, -23.6796875), Point(-2.0, -14.3984375), Point(-2.0, -9.12109375)),
PathCurve(Point(-2.0, -6.3984375), Point(-3.7578125, -3.6796875), Point(-6.640625, -3.6796875)),
PathCurve(Point(-13.19921875, -3.6796875), Point(-11.1171875, -17.4375), Point(-26.3203125, -17.4375)),
PathCurve(Point(-35.1171875, -17.4375), Point(-42.16015625, -10.3984375), Point(-42.16015625, -1.59765625)),
PathCurve(Point(-42.16015625, 7.83984375), Point(-35.91796875, 14.2421875), Point(-26.3203125, 14.2421875)),
PathCurve(Point(-11.7578125, 14.2421875), Point(-13.0390625, 0.640625), Point(-6.0, 0.640625)),
PathCurve(Point(-3.27734375, 0.640625), Point(-2.16015625, 2.5625), Point(-2.16015625, 5.12109375)),
PathCurve(Point(-2.16015625, 14.71875), Point(-17.6796875, 22.87890625), Point(-25.0390625, 26.40234375)),
PathCurve(Point(-11.4375, 45.28125), Point(-4.23828125, 68.16015625), Point(-2.16015625, 90.5625)),
PathClose(),
PathMove(Point(48.87890625, 56.640625))</code></pre><p>You can draw this later:</p><pre><code class="language-julia hljs">for θ in range(0, step=2π/10, length=10)
    @layer begin
        rotate(θ)
        translate(150, 0)
        rotate(π/2)
        drawpath(dagger, action = :fill)
    end
end</code></pre><img src="aadb1684.svg" alt="Example block output"/><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>After you&#39;ve stored the current path, it&#39;s still active. You might want to use <code>newpath()</code> before starting the next one. The <code>drawpath()</code> function will by default start a new path but there is an option to continue drawing the current one.</p></div></div><p>Other functions for working with stored paths include:</p><ul><li><p><a href="../../reference/api/#Luxor.drawpath-Tuple{Path, Real}"><code>drawpath</code></a> draw all or part of a stored path using the current graphics state</p></li><li><p><a href="../../reference/api/#Luxor.pathsample-Tuple{Path, Any}"><code>pathsample</code></a> resample the stored path</p></li><li><p><a href="../../reference/api/#Luxor.pathlength-Tuple{Path}"><code>pathlength</code></a> find the length of a stored path</p></li><li><p><a href="../../reference/api/#Luxor.BoundingBox-Tuple{AbstractString}"><code>BoundingBox</code></a> find the bounding box of a stored path</p></li></ul><h2 id="Julia-logos"><a class="docs-heading-anchor" href="#Julia-logos">Julia logos</a><a id="Julia-logos-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-logos" title="Permalink"></a></h2><p>A couple of functions, <a href="../../reference/api/#Luxor.julialogo-Tuple{}"><code>julialogo</code></a> and <a href="../../reference/api/#Luxor.juliacircles"><code>juliacircles</code></a>, provide you with instant access to the Julia logo and the three colored circles/dots:</p><pre><code class="language-julia hljs">cells = Table([300], [350, 350])

@layer begin
    translate(cells[1])
    translate(-165, -114)
    rulers()
    julialogo()
end

@layer begin
    translate(cells[2])
    translate(-165, -114)
    rulers()
    julialogo(action=:clip)
    for i in 1:500
        @layer begin
            translate(rand(0:400), rand(0:250))
            juliacircles(10)
        end
    end
    clipreset()
    end</code></pre><p><img src="../../assets/figures/julia-logo.png" alt="julia logo and circles"/></p><p>There are various options for <code>julialogo()</code> to control coloring and positioning.</p><p>The four standard Julia colors are available as RGB tuples as <code>Luxor.julia_blue</code>, <code>Luxor.julia_green</code>, <code>Luxor.julia_purple</code>,  <code>Luxor.julia_red</code>:</p><pre><code class="language-julia hljs">julia&gt; Luxor.julia_red
(0.796, 0.235, 0.2)</code></pre><h2 id="Hypotrochoids"><a class="docs-heading-anchor" href="#Hypotrochoids">Hypotrochoids</a><a id="Hypotrochoids-1"></a><a class="docs-heading-anchor-permalink" href="#Hypotrochoids" title="Permalink"></a></h2><p><a href="../../reference/api/#Luxor.hypotrochoid-Tuple{Any, Any, Any}"><code>hypotrochoid</code></a> makes hypotrochoids. The result is a polygon. You can either draw it directly, or pass it on for further polygon fun, as here, which uses <a href="../../reference/api/#Luxor.offsetpoly-Tuple{Any, Function}"><code>offsetpoly</code></a> to trace round it a few times.</p><pre><code class="language-julia hljs">origin()
background(&quot;grey15&quot;)
sethue(&quot;antiquewhite&quot;)
setline(1)
p = hypotrochoid(100, 25, 55, action = :stroke, stepby=0.01, vertices=true)
for i in 0:3:15
    poly(offsetpoly(p, i), action = :stroke, close=true)
end</code></pre><p><img src="../../assets/figures/hypotrochoid.png" alt="hypotrochoid"/></p><p>There&#39;s a matching <a href="../../reference/api/#Luxor.epitrochoid-Tuple{Any, Any, Any}"><code>epitrochoid</code></a> function.</p><h2 id="Ticks"><a class="docs-heading-anchor" href="#Ticks">Ticks</a><a id="Ticks-1"></a><a class="docs-heading-anchor-permalink" href="#Ticks" title="Permalink"></a></h2><p>The <a href="../../reference/api/#Luxor.tickline-Tuple{Any, Any}"><code>tickline</code></a> function lets you divide the space between two points by drawing ‘ticks’, short parallel lines positioned equidistant between the two points.</p><p>In its simplest form the function can used to draw basic number lines, complete with automatic text labels.</p><pre><code class="language-julia hljs">background(&quot;antiquewhite&quot;)

# major defaults to 1
tickline(Point(-350, -100), Point(350, -100))

# three major ticks inserted
tickline(Point(-350, 0), Point(350, 0),
    major=3,
    startnumber=0, finishnumber=100)

# four minor ticks inserted between each major
tickline(Point(-350, 100), Point(350, 100), major=3, minor=4)</code></pre><img src="b3490ef3.svg" alt="Example block output"/><p>The function returns the positions of the generated ticks in two arrays of points - the locations of the major and minor ticks.</p><p>The spaced positions (linear or logarithmic) are useful even when you switch off the display of text using <code>vertices=true</code>, which just returns vertices.</p><pre><code class="language-julia hljs"># no axis
tickline(Point(-350, -100), Point(350, -100), minor=9, axis=false)

# logarithmic
majticks, minticks = tickline(Point(-350, 0), Point(350, 0),
    major=9,
    startnumber=1,
    finishnumber=10,
    log=true,
    vertices=false)

# just the vertices
majticks, minticks = tickline(Point(-350, 100), Point(350, 100),
    major=9,
    minor=4,
    log=true,
    axis=false,
    vertices=true)
circle.(majticks, 5, action = :fill)
box.(minticks, 1, 25, action = :fill)</code></pre><img src="4e73dce6.svg" alt="Example block output"/><p>You can pass a function that generates custom graphics and text for each tick.</p><pre><code class="language-julia hljs">function color_temp(n, pos;
          startnumber  = 0,
          finishnumber = 1,
          nticks = 1)
    k = rescale(n, 0, nticks - 1, startnumber, finishnumber)
    sethue(RGB(colormatch(k)))
    circle(pos, 20, action = :fillpreserve)
    sethue(&quot;white&quot;)
    strokepath()
    text(&quot;$(convert(Int, floor(k))) nm&quot;, pos - (0, 30), halign=:left, angle=-π/4)
end

tickline(Point(-350, 0), Point(350, 0),
    startnumber=350,
    finishnumber=750,
    major=10,
    major_tick_function=color_temp)</code></pre><img src="bd1cae37.svg" alt="Example block output"/><p>Sometimes you just want a sequence of spaced points.</p><pre><code class="language-julia hljs">_, minticks = tickline(Point(-400, 0), Point(260, 0),
        major=0, minor=40,
        log=true,
        axis=false,
        vertices=true)

for (n, pt) in enumerate(minticks)
    k = rescale(n, 1, length(minticks), 0, 1)
    sethue(LCHab(60, 100, 360k))
    setline(1/k)
    wave = [pt + Point(120k * sin(y), 600/2π * y) for y in -π:π/20:π]
    poly(wave, action = :stroke)
end</code></pre><img src="7edc8b54.svg" alt="Example block output"/><h2 id="Cropmarks"><a class="docs-heading-anchor" href="#Cropmarks">Cropmarks</a><a id="Cropmarks-1"></a><a class="docs-heading-anchor-permalink" href="#Cropmarks" title="Permalink"></a></h2><p>If you want cropmarks (aka trim marks), use the <a href="../../reference/api/#Luxor.cropmarks-Tuple{Any, Any, Any}"><code>cropmarks</code></a> function, supplying the centerpoint, followed by the width and height:</p><pre><code class="nohighlight hljs">cropmarks(O, 1200, 1600)
cropmarks(O, paper_sizes[&quot;A0&quot;]...)</code></pre><pre><code class="language-julia hljs">sethue(&quot;red&quot;)
box(O, 150, 150, action = :stroke)
cropmarks(O, 150, 150)</code></pre><p><img src="../../assets/figures/cropmarks.png" alt="cropmarks"/></p><h2 id="Dimensioning"><a class="docs-heading-anchor" href="#Dimensioning">Dimensioning</a><a id="Dimensioning-1"></a><a class="docs-heading-anchor-permalink" href="#Dimensioning" title="Permalink"></a></h2><p>Simple dimensioning graphics can be generated with <a href="../../reference/api/#Luxor.dimension-Tuple{Point, Point}"><code>dimension</code></a>. To convert from the default unit (PostScript points), or to modify the dimensioning text, supply a function to the <code>format</code> keyword argument.</p><p><img src="../../assets/figures/dimensioning.svg" alt="dimensioning"/></p><pre><code class="language-julia hljs">setline(0.75)
sethue(&quot;purple&quot;)
pentagon = ngonside(O, 120, 5, vertices=true)
poly(pentagon, action = :stroke, close=true)
circle.(pentagon, 2, action = :fill)
fontsize(6)
label.(split(&quot;12345&quot;, &quot;&quot;), :NE, pentagon)
fontface(&quot;Menlo&quot;)
fontsize(10)
sethue(&quot;grey30&quot;)

dimension(O, pentagon[4],
    fromextension = [0, 0])

dimension(pentagon[1], pentagon[2],
    offset        = -60,
    fromextension = [20, 50],
    toextension   = [20, 50],
    textrotation  = 2π/5,
    textgap       = 20,
    format        = (d) -&gt; string(round(d, digits=4), &quot;pts&quot;))

dimension(pentagon[2], pentagon[3],
     offset        = -40,
     format        =  string)

dimension(pentagon[5], Point(pentagon[5].x, pentagon[4].y),
    offset        = 60,
    format        = (d) -&gt; string(&quot;approximately &quot;,round(d, digits=4)),
    fromextension = [5, 5],
    toextension   = [80, 5])

dimension(pentagon[1], midpoint(pentagon[1], pentagon[5]),
    offset               = 70,
    fromextension        = [65, -5],
    toextension          = [65, -5],
    texthorizontaloffset = -5,
    arrowheadlength      = 5,
    format               = (d) -&gt;
        begin
            if isapprox(d, 60.0)
                string(&quot;exactly &quot;, round(d, digits=4), &quot;pts&quot;)
            else
                string(&quot;≈ &quot;, round(d, digits=4), &quot;pts&quot;)
            end
        end)

dimension(pentagon[1], pentagon[5],
    offset               = 120,
    fromextension        = [5, 5],
    toextension          = [115, 5],
    textverticaloffset   = 0.5,
    texthorizontaloffset = 0,
    textgap              = 5)</code></pre><h2 id="Barcharts"><a class="docs-heading-anchor" href="#Barcharts">Barcharts</a><a id="Barcharts-1"></a><a class="docs-heading-anchor-permalink" href="#Barcharts" title="Permalink"></a></h2><p>For simple barcharts, use the <a href="../../reference/api/#Luxor.barchart-Tuple{Any}"><code>barchart</code></a> function, supplying an array of numbers:</p><pre><code class="language-julia hljs">fontsize(7)
sethue(&quot;black&quot;)
v = rand(-100:100, 25)
barchart(v, labels=true)</code></pre><p><img src="../../assets/figures/bars.png" alt="bars"/></p><p>To change the way the bars and labels are drawn, define some functions and pass them as keyword arguments:</p><pre><code class="language-julia hljs">function mybarfunction(values, i, low, high, barwidth, scaledvalue)
    @layer begin
        extremes = extrema(values)
        sethue(Colors.HSB(rescale(values[i], extremes[1], extremes[2], 0, 360), 1.0, 0.5))
        csize = rescale(values[i], extremes[1], extremes[2], 5, 15)
        circle(high, csize, action = :fill)
        setline(1)
        sethue(&quot;blue&quot;)
        line(low, high, action = :stroke)
        sethue(&quot;white&quot;)
        text(string(values[i]), high, halign=:center, valign=:middle)
    end
end

function mylabelfunction(values, i, low, high, barwidth, scaledvalue)
    @layer begin
        translate(low)
        text(string(values[i]), O + (0, 10), halign=:center, valign=:middle)
    end
end

v = rand(1:100, 15)

bbox = BoundingBox() * 0.8
box(bbox, action = :clip)
p = barchart(v, boundingbox=bbox, barfunction=mybarfunction, labelfunction=mylabelfunction)

rule(p[1])</code></pre><p><img src="../../assets/figures/bars1.png" alt="bars 1"/></p><h2 id="Box-maps"><a class="docs-heading-anchor" href="#Box-maps">Box maps</a><a id="Box-maps-1"></a><a class="docs-heading-anchor-permalink" href="#Box-maps" title="Permalink"></a></h2><p>The <a href="../../reference/api/#Luxor.boxmap-Tuple{Array, Point, Any, Any}"><code>boxmap</code></a> function divides a rectangular area into a sorted arrangement of smaller boxes or tiles based on the values of elements in an array.</p><p>This example uses the Fibonacci sequence to determine the area of the boxes. Notice that the values are sorted in reverse, and are scaled to fit in the available area.</p><p>You specify the top left corner of the graphic, the width, and the height.</p><pre><code class="language-julia hljs">fib = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]

# make a boxmap and store the tiles
tiles = boxmap(fib, BoundingBox()[1], 800, 450)

for (n, t) in enumerate(tiles)
    randomhue()
    bb = BoundingBox(t)
    sethue(&quot;black&quot;)
    box(bb - 5, action = :stroke)

    randomhue()
    box(bb - 8, action = :fill)

    # text labels
    sethue(&quot;white&quot;)

    # rescale text to fit better
    fontsize(boxwidth(bb) &gt; boxheight(bb) ? boxheight(bb)/4 : boxwidth(bb)/4)
    text(string(sort(fib, rev=true)[n]),
        midpoint(bb[1], bb[2]),
        halign=:center,
            valign=:middle)
end</code></pre><p><img src="../../assets/figures/boxmap.png" alt="boxmap"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../createdrawings/">« Create drawings</a><a class="docs-footer-nextpage" href="../geometrytools/">Use geometry tools »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Sunday 14 January 2024 10:14">Sunday 14 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
