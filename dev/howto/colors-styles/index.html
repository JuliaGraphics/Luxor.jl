<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Use colors and styles · Luxor</title><meta name="title" content="Use colors and styles · Luxor"/><meta property="og:title" content="Use colors and styles · Luxor"/><meta property="twitter:title" content="Use colors and styles · Luxor"/><meta name="description" content="Documentation for Luxor."/><meta property="og:description" content="Documentation for Luxor."/><meta property="twitter:description" content="Documentation for Luxor."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/luxor-docs.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Luxor logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Luxor</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction to Luxor</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorial/helloworld/">Hello World</a></li><li><a class="tocitem" href="../../tutorial/basicpath/">Basic path building</a></li><li><a class="tocitem" href="../../tutorial/quickstart/">Design a logo</a></li><li><a class="tocitem" href="../../tutorial/basictutorial/">Geometry tutorial</a></li><li><a class="tocitem" href="../../tutorial/pixels/">Playing with pixels</a></li><li><a class="tocitem" href="../../tutorial/simple-animation/">Simple animation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../example/examples/">Simple examples</a></li><li><a class="tocitem" href="../../example/moreexamples/">More examples</a></li><li><a class="tocitem" href="../../example/gallery/">Gallery</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">How to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../createdrawings/">Create drawings</a></li><li><a class="tocitem" href="../simplegraphics/">Draw simple shapes</a></li><li><a class="tocitem" href="../geometrytools/">Use geometry tools</a></li><li><a class="tocitem" href="../tables-grids/">Work with tables and grids</a></li><li class="is-active"><a class="tocitem" href>Use colors and styles</a><ul class="internal"><li><a class="tocitem" href="#Color-and-opacity"><span>Color and opacity</span></a></li><li><a class="tocitem" href="#Line-styles"><span>Line styles</span></a></li><li><a class="tocitem" href="#Gradient-blends"><span>Gradient blends</span></a></li><li><a class="tocitem" href="#Compositing-operators"><span>Compositing operators</span></a></li><li><a class="tocitem" href="#Meshes"><span>Meshes</span></a></li><li><a class="tocitem" href="#Masks"><span>Masks</span></a></li></ul></li><li><a class="tocitem" href="../polygons/">Work with polygons</a></li><li><a class="tocitem" href="../text/">Add text</a></li><li><a class="tocitem" href="../clipping/">Clip graphics</a></li><li><a class="tocitem" href="../images/">Placing images</a></li><li><a class="tocitem" href="../turtle/">Turtle graphics</a></li><li><a class="tocitem" href="../animation/">Make animations</a></li><li><a class="tocitem" href="../snapshots/">Snapshots</a></li><li><a class="tocitem" href="../livegraphics/">Interactive graphics and Threads</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Explanations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../explanation/basics/">Basic concepts</a></li><li><a class="tocitem" href="../../explanation/pathspolygons/">Paths vs Polygon</a></li><li><a class="tocitem" href="../../explanation/perfectpixels/">Perfect pixels and antialising</a></li><li><a class="tocitem" href="../../explanation/transforms/">Transforms and matrices</a></li><li><a class="tocitem" href="../../explanation/imagematrix/">Image matrix</a></li><li><a class="tocitem" href="../../explanation/fonts/">Fonts on Linux</a></li><li><a class="tocitem" href="../../explanation/luxorcairo/">Luxor and Cairo</a></li><li><a class="tocitem" href="../../explanation/strokepathdispatch/">Customize strokepath/fillpath</a></li><li><a class="tocitem" href="../../explanation/contributing/">Contributing</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/functionindex/">Alphabetical function list</a></li><li><a class="tocitem" href="../../reference/api/">Function reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">How to guides</a></li><li class="is-active"><a href>Use colors and styles</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Use colors and styles</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGraphics/Luxor.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGraphics/Luxor.jl/blob/master/docs/src/howto/colors-styles.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Colors-and-styles"><a class="docs-heading-anchor" href="#Colors-and-styles">Colors and styles</a><a id="Colors-and-styles-1"></a><a class="docs-heading-anchor-permalink" href="#Colors-and-styles" title="Permalink"></a></h1><h2 id="Color-and-opacity"><a class="docs-heading-anchor" href="#Color-and-opacity">Color and opacity</a><a id="Color-and-opacity-1"></a><a class="docs-heading-anchor-permalink" href="#Color-and-opacity" title="Permalink"></a></h2><p>For color definitions and conversions, you can use <a href="https://github.com/JuliaGraphics/Colors.jl">Colors.jl</a>.</p><p><a href="../../reference/api/#Luxor.setcolor-Tuple{AbstractString}"><code>setcolor</code></a> and <a href="../../reference/api/#Luxor.sethue-Tuple{AbstractString}"><code>sethue</code></a> will apply a single color to all new graphics.</p><p><a href="../../reference/api/#Luxor.setblend-Tuple{Cairo.CairoPattern}"><code>setblend</code></a> will apply a smooth transition between two or more colors to all new graphics.</p><p><a href="../../reference/api/#Luxor.setmesh-Tuple{Cairo.CairoPattern}"><code>setmesh</code></a> will apply a color mesh to all new graphics.</p><p>The difference between the <a href="../../reference/api/#Luxor.setcolor-Tuple{AbstractString}"><code>setcolor</code></a> and <a href="../../reference/api/#Luxor.sethue-Tuple{AbstractString}"><code>sethue</code></a> functions is that <a href="../../reference/api/#Luxor.sethue-Tuple{AbstractString}"><code>sethue</code></a> doesn&#39;t change the current alpha opacity (transparency), so you can change the current color without changing the current alpha opacity (transparency) value.</p><p>Named colors, such as &quot;gold&quot;, or &quot;lavender&quot;, can be found in <code>Colors.color_names</code> dictionary.</p><pre><code class="language-julia hljs">fontsize(8)
cols = sort(collect(Colors.color_names))
ncols = 15
nrows = convert(Int, ceil(length(cols) / ncols))
table = Table(nrows, ncols, 800/ncols, 800/nrows)
gamma = 2.2
for n in 1:length(cols)
    col = cols[n][1]
    r, g, b = sethue(col)
    box(table[n], table.colwidths[1], table.rowheights[1], action=:fill)
    luminance = 0.2126 * r^gamma + 0.7152 * g^gamma + 0.0722 * b^gamma
    (luminance &gt; 0.5^gamma) ? sethue(&quot;black&quot;) : sethue(&quot;white&quot;)
    text(string(cols[n][1]), table[n], halign=:center, valign=:middle)
end</code></pre><p><img src="../../assets/figures/colors.svg" alt="line endings"/></p><p>(To make the label stand out against the background, the luminance is calculated, then used to choose the label&#39;s color.)</p><h2 id="Line-styles"><a class="docs-heading-anchor" href="#Line-styles">Line styles</a><a id="Line-styles-1"></a><a class="docs-heading-anchor-permalink" href="#Line-styles" title="Permalink"></a></h2><p>There are <code>set-</code> functions for controlling subsequent lines&#39; width, end shape, join behavior, and dash pattern:</p><pre><code class="language-julia hljs">for l in 1:3
    sethue(&quot;black&quot;)
    setline(20)
    setlinecap([&quot;butt&quot;, &quot;square&quot;, &quot;round&quot;][l])
    textcentred([&quot;butt&quot;, &quot;square&quot;, &quot;round&quot;][l], 80l, 80)
    setlinejoin([&quot;round&quot;, &quot;miter&quot;, &quot;bevel&quot;][l])
    textcentred([&quot;round&quot;, &quot;miter&quot;, &quot;bevel&quot;][l], 80l, 120)
    poly(ngon(Point(80l, 0), 20, 3, 0, vertices=true), action=:strokepreserve, close=false)
    sethue(&quot;white&quot;)
    setline(1)
    strokepath()
end</code></pre><p><img src="../../assets/figures/line-ends.png" alt="line endings"/></p><pre><code class="language-julia hljs">patterns = [&quot;solid&quot;, &quot;dotted&quot;, &quot;dot&quot;, &quot;dotdashed&quot;, &quot;longdashed&quot;,
  &quot;shortdashed&quot;, &quot;dash&quot;, &quot;dashed&quot;, &quot;dotdotdashed&quot;, &quot;dotdotdotdashed&quot;]
setline(12)

table = Table(fill(20, length(patterns)), [50, 300])
text.(patterns, table[:, 1], halign=:right, valign=:middle)

for p in 1:length(patterns)
    setdash(patterns[p])
    pt = table[p, 2]
    line(pt - (150, 0), pt + (150, 0), :stroke)
end</code></pre><p><img src="../../assets/figures/dashes.png" alt="dashes"/></p><p>To define more complicated dash patterns, pass a vector to <a href="../../reference/api/#Luxor.setdash"><code>setdash</code></a>.</p><pre><code class="language-julia hljs">dashes = [50.0,  # ink
          10.0,  # skip
          10.0,  # ink
          10.0   # skip
          ]
setdash(dashes)</code></pre><pre><code class="language-julia hljs">function dashing()
    setline(8)
    setlinecap(&quot;butt&quot;)
    patterns = [10, 4, 50, 25, 14, 100]
    table = Table(fill(20, length(patterns)), [40, 325])
    for p in 1:length(patterns)
        setdash(patterns)
        pt = table[p, 2]
        text(string(patterns), table[p, 1], halign=:right, valign=:middle)
        line(pt - (150, 0), pt + (200, 0), :stroke)
        patterns = circshift(patterns, 1)
        pop!(patterns)
    end
end

dashing()</code></pre><p><img src="../../assets/figures/moredashes.svg" alt="more dashes"/></p><p>Notice that odd-numbered patterns flip the ink and skip values each time through.</p><h2 id="Gradient-blends"><a class="docs-heading-anchor" href="#Gradient-blends">Gradient blends</a><a id="Gradient-blends-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient-blends" title="Permalink"></a></h2><p>In Luxor, a blend is a smoothly changing color gradient.</p><p>Use <a href="../../reference/api/#Luxor.setblend-Tuple{Cairo.CairoPattern}"><code>setblend</code></a> to select a blend in the same way that you&#39;d use <a href="../../reference/api/#Luxor.setcolor-Tuple{AbstractString}"><code>setcolor</code></a> and <a href="../../reference/api/#Luxor.sethue-Tuple{AbstractString}"><code>sethue</code></a> to select a solid color.</p><p>You can make linear or radial blends. Use <a href="../../reference/api/#Luxor.blend-Tuple{Point, Any, Point, Any, Any, Any}"><code>blend</code></a> in either case.</p><p>After <code>setblend()</code>, the current blend affects all subsequent stroked and filled graphics.</p><p>To create a simple linear blend between two colors, supply two points and two colors to <a href="../../reference/api/#Luxor.blend-Tuple{Point, Any, Point, Any, Any, Any}"><code>blend</code></a>:</p><pre><code class="language-julia hljs">orangeblue = blend(Point(-200, 0), Point(200, 0), &quot;orange&quot;, &quot;blue&quot;)
setblend(orangeblue)
box(O, 400, 100, action = :fill)
rulers()

translate(0, -70)
rule(O) # stroked line</code></pre><p><img src="../../assets/figures/color-blends-basic.png" alt="linear blend"/></p><p>And for a radial blend, provide two point/radius pairs and two colors:</p><pre><code class="language-julia hljs">greenmagenta = blend(Point(0, 0), 5, Point(0, 0), 150, &quot;green&quot;, &quot;magenta&quot;)
setblend(greenmagenta)
box(O, 400, 200, action = :fill)
rulers()</code></pre><p><img src="../../assets/figures/color-blends-radial.png" alt="radial blends"/></p><p>You can also use <a href="../../reference/api/#Luxor.blend-Tuple{Point, Any, Point, Any, Any, Any}"><code>blend</code></a> to create an empty blend. Then you use <a href="../../reference/api/#Luxor.addstop-Tuple{Cairo.CairoPattern, Any, ColorTypes.Colorant}"><code>addstop</code></a> to define the locations of specific colors along the blend, where <code>0</code> is the start, and <code>1</code> is the end.</p><pre><code class="language-julia hljs">goldblend = blend(Point(-200, 0), Point(200, 0))
addstop(goldblend, 0.0,  &quot;gold4&quot;)
addstop(goldblend, 0.25, &quot;gold1&quot;)
addstop(goldblend, 0.5,  &quot;gold3&quot;)
addstop(goldblend, 0.75, &quot;darkgoldenrod4&quot;)
addstop(goldblend, 1.0,  &quot;gold2&quot;)
setblend(goldblend)
box(O, 400, 200, action = :fill)
rulers()</code></pre><p><img src="../../assets/figures/color-blends-scratch.png" alt="blends from scratch"/></p><p>When you define blends, the location of the x/y axes (eg the current workspace as defined by <a href="../../reference/api/#Luxor.translate-Tuple{Real, Real}"><code>translate</code></a>, etc.), is important. In the first of the two following examples, the blend is selected before the axes are moved with <code>translate(pos)</code>. The blend &#39;samples&#39; the original location of the blend&#39;s definition.</p><pre><code class="language-julia hljs">goldblend = blend(Point(0, 0), Point(200, 0))
addstop(goldblend, 0.0,  &quot;gold4&quot;)
addstop(goldblend, 0.25, &quot;gold1&quot;)
addstop(goldblend, 0.5,  &quot;gold3&quot;)
addstop(goldblend, 0.75, &quot;darkgoldenrod4&quot;)
addstop(goldblend, 1.0,  &quot;gold2&quot;)
setblend(goldblend)
tiles = Tiler(600, 200, 1, 5, margin=10)
for (pos, n) in tiles
    gsave()
    setblend(goldblend)
    translate(pos)
    ellipse(O, tiles.tilewidth, tiles.tilewidth, action = :fill)
    grestore()
end</code></pre><p><img src="../../assets/figures/color-blends-translate-1.png" alt="blends 1"/></p><p>By default, outside the range of the original blend&#39;s definition, the same color is used, no matter how far away from the origin you go. But in the next example, the blend is relocated to the current axes, which have just been moved to the center of the tile. The blend refers to <code>0/0</code> each time, which is at the center of shape.</p><pre><code class="language-julia hljs">goldblend = blend(Point(0, 0), Point(200, 0))
addstop(goldblend, 0.0,  &quot;gold4&quot;)
addstop(goldblend, 0.25, &quot;gold1&quot;)
addstop(goldblend, 0.5,  &quot;gold3&quot;)
addstop(goldblend, 0.75, &quot;darkgoldenrod4&quot;)
addstop(goldblend, 1.0,  &quot;gold2&quot;)
setblend(goldblend)
tiles = Tiler(600, 200, 1, 5, margin=10)
for (pos, n) in tiles
    gsave()
    translate(pos)
    setblend(goldblend)
    ellipse(O, tiles.tilewidth, tiles.tilewidth, action = :fill)
    grestore()
end</code></pre><p><img src="../../assets/figures/color-blends-translate-2.png" alt="blends 2"/></p><h3 id="Using-[blendadjust](@ref)"><a class="docs-heading-anchor" href="#Using-[blendadjust](@ref)">Using <a href="../../reference/api/#Luxor.blendadjust"><code>blendadjust</code></a></a><a id="Using-[blendadjust](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Using-[blendadjust](@ref)" title="Permalink"></a></h3><p>You can use <a href="../../reference/api/#Luxor.blendadjust"><code>blendadjust</code></a> to modify the blend so that objects scaled and positioned after the blend was defined are rendered correctly.</p><pre><code class="language-julia hljs">setline(20)

# first line
blendgoldmagenta = blend(Point(-100, 0), Point(100, 0), &quot;gold&quot;, &quot;magenta&quot;)
setblend(blendgoldmagenta)
line(Point(-100, -50), Point(100, -50))
strokepath()

# second line
blendadjust(blendgoldmagenta, Point(50, 0), 0.5, 0.5)
line(O, Point(100, 0))
strokepath()

# third line
blendadjust(blendgoldmagenta, Point(-50, 50), 0.5, 0.5)
line(Point(-100, 50), Point(0, 50))
strokepath()

# fourth line
gsave()
translate(0, 100)
scale(0.5, 0.5)
setblend(blendgoldmagenta)
line(Point(-100, 0), Point(100, 0))
strokepath()
grestore()</code></pre><p><img src="../../assets/figures/blend-adjust.png" alt="blends adjust"/></p><p>The blend is defined to span 200 units, horizontally centered at 0/0. The top line is also 200 units long and centered horizontally at 0/0, so the blend is rendered exactly as you&#39;d hope.</p><p>The second line is only half as long, at 100 units, centered at 50/0, so <a href="../../reference/api/#Luxor.blendadjust"><code>blendadjust</code></a> is used to relocate the blend&#39;s center to the point 50/0 and scale it by 0.5 (<code>100/200</code>).</p><p>The third line is also 100 units long, centered at -50/0, so again <a href="../../reference/api/#Luxor.blendadjust"><code>blendadjust</code></a> is used to relocate the blend&#39;s center and scale it.</p><p>The fourth line shows that you can translate and scale the axes instead of adjusting the blend, if you use <a href="../../reference/api/#Luxor.setblend-Tuple{Cairo.CairoPattern}"><code>setblend</code></a> again in the new scene.</p><h3 id="Blend-extensions"><a class="docs-heading-anchor" href="#Blend-extensions">Blend extensions</a><a id="Blend-extensions-1"></a><a class="docs-heading-anchor-permalink" href="#Blend-extensions" title="Permalink"></a></h3><p>Use <code>setblendextend()</code> to control what happens when the shape you&#39;re drawing occupies an area larger than the blend you&#39;re using. In this example, the four possible modes are used to draw the same 150 unit radius circle using a much smaller 30 unit radial blend that starts at orange, and passes through green, to blue. If the blend is smaller than the shape, then a mode of &quot;none&quot; won&#39;t fill the entire shape, just the area inside the boundary of the blend.</p><pre><code class="language-julia hljs">function drawcircle_with_mode(extendmode)
    setdash(&quot;dot&quot;)
    circle(O, 150, :stroke)
    a_blend = blend(O, 0,  O, 30, &quot;orange&quot;, &quot;midnightblue&quot;)
    addstop(a_blend, 0.5, &quot;green&quot;)
    setblend(a_blend)
    setblendextend(a_blend, extendmode)
    circle(O, 150, action = :fill)
    sethue(&quot;black&quot;)
    text(string(extendmode), Point(0, -tiles.tileheight/2), halign=:center)
end


@layer begin
    translate(first(tiles[1]))
    drawcircle_with_mode(&quot;none&quot;)
end

@layer begin
    translate(first(tiles[2]))
    drawcircle_with_mode(&quot;repeat&quot;)
end

@layer begin
    translate(first(tiles[3]))
    drawcircle_with_mode(&quot;reflect&quot;)
end

@layer begin
    translate(first(tiles[4]))
    drawcircle_with_mode(&quot;pad&quot;)
end</code></pre><img src="79daedb5.png" alt="Example block output"/><h2 id="Compositing-operators"><a class="docs-heading-anchor" href="#Compositing-operators">Compositing operators</a><a id="Compositing-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Compositing-operators" title="Permalink"></a></h2><p>Graphics software provides ways to modify how the virtual &quot;ink&quot; is applied to previously-drawn graphic elements. In PhotoShop and other software, the compositing process is done using what are called <a href="https://en.wikipedia.org/wiki/Blend_modes">blend modes</a>.</p><p>Use <a href="../../reference/api/#Luxor.setmode-Tuple{AbstractString}"><code>setmode</code></a> to set the blending/compositing mode of subsequent graphics.</p><p>The following examples place a blue circle with 0.7 opacity on top of a red circle.</p><pre><code class="language-julia hljs">origin()
# transparent, no background
fontsize(15)
setline(1)
tiles = Tiler(600, 600, 4, 5, margin=30)
modes = length(Luxor.blendingmodes)
setcolor(&quot;black&quot;)
for (pos, n) in tiles
    n &gt; modes &amp;&amp; break
    gsave()
    translate(pos)
    box(O, tiles.tilewidth-10, tiles.tileheight-10, :clip)

    # calculate points for circles
    diag = (Point(-tiles.tilewidth/2, -tiles.tileheight/2),
            Point(tiles.tilewidth/2,  tiles.tileheight/2))
    upper = between(diag, 0.45)
    lower = between(diag, 0.55)

    # first red shape uses default blend operator
    setcolor(0.7, 0, 0, .7)
    circle(upper, tiles.tilewidth/4, action = :fill)

    # second blue shape shows results of blend operator
    setcolor(0, 0, 0.9, 0.7)
    blendingmode = Luxor.blendingmodes[mod1(n, modes)]
    setmode(blendingmode)
    circle(lower, tiles.tilewidth/4, action = :fill)

    clipreset()
    grestore()

    gsave()
    translate(pos)
    sethue(&quot;antiquewhite&quot;)
    txt = Luxor.blendingmodes[mod1(n, modes)]
    pos = O + (0, tiles.tilewidth/2)
    box(pos, textextents(txt)[3] + 5, 25, action = :fill)
    sethue(&quot;black&quot;)
    text(txt, pos, halign=:center, valign=:middle)
    grestore()
end</code></pre><img src="663e7cee.png" alt="Example block output"/><p>Notice in this example that clipping was used to restrict the area affected by the blending process.</p><p>In Cairo, these blend modes are called <em>operators</em>. For a more detailed explanation, refer to <a href="https://www.cairographics.org/operators/">the Cairo documentation</a>.</p><p>You can access the list of modes with the unexported symbol <code>Luxor.blendingmodes</code>.</p><h2 id="Meshes"><a class="docs-heading-anchor" href="#Meshes">Meshes</a><a id="Meshes-1"></a><a class="docs-heading-anchor-permalink" href="#Meshes" title="Permalink"></a></h2><p>A mesh provides smooth shading between three or four colors across a region defined by lines or curves.</p><p>To create a mesh, use the <a href="../../reference/api/#Luxor.mesh"><code>mesh</code></a> function and assign the resulting mesh object to a variable. To use a mesh, pass the mesh object variable to the <a href="../../reference/api/#Luxor.setmesh-Tuple{Cairo.CairoPattern}"><code>setmesh</code></a> function.</p><p>The <a href="../../reference/api/#Luxor.mesh"><code>mesh</code></a> function accepts either an array of Bézier paths or a polygon.</p><p>This basic example obtains a polygon from the drawing area using <code>box(BoundingBox()...</code> and uses the four corners of the mesh and the four colors in the array to build the mesh. The <a href="../../reference/api/#Luxor.paint-Tuple{}"><code>paint</code></a> function fills the drawing.</p><pre><code class="language-julia hljs">garishmesh = mesh(
    box(BoundingBox(), vertices=true),
    [&quot;purple&quot;, &quot;green&quot;, &quot;yellow&quot;, &quot;red&quot;])

setmesh(garishmesh)

paint()

setline(2)
sethue(&quot;white&quot;)
hypotrochoid(180, 81, 130, :stroke)</code></pre><p><img src="../../assets/figures/mesh-basic.png" alt="mesh 1"/></p><p>The next example uses a Bézier path conversion of a square as the outline of the mesh. Because the box to be filled is larger than the mesh&#39;s outlines, not all the box is filled.</p><pre><code class="language-julia hljs">setcolor(&quot;grey50&quot;)
circle.([Point(x, y) for x in -200:25:200, y in -200:25:200], 10, action = :fill)

bp = makebezierpath(box(O, 300, 300, vertices=true), smoothing=.4)
setline(3)
sethue(&quot;black&quot;)

drawbezierpath(bp, :stroke)
mesh1 = mesh(bp, [
    Colors.RGBA(1, 0, 0, 1),   # bottom left, red
    Colors.RGBA(1, 1, 1, 0.0), # top left, transparent
    Colors.RGB(0, 0, 1),       # top right, blue
    Colors.RGB(1, 0, 1)        # bottom right, purple
    ])
setmesh(mesh1)
box(O, 500, 500, action = :fillpreserve)
sethue(&quot;grey50&quot;)
strokepath()</code></pre><p><img src="../../assets/figures/mesh1.png" alt="mesh 1"/></p><p>The second example uses a polygon defined by <a href="../../reference/api/#Luxor.ngon"><code>ngon</code></a> as the outline of the mesh. The mesh is drawn when the path is stroked.</p><pre><code class="language-julia hljs">pl = ngon(O, 250, 3, π/6, vertices=true)
mesh1 = mesh(pl, [
    &quot;purple&quot;,
    &quot;green&quot;,
    &quot;yellow&quot;
    ])
setmesh(mesh1)
setline(180)
poly(pl, :strokepreserve, close=true)
setline(5)
sethue(&quot;black&quot;)
strokepath()</code></pre><p><img src="../../assets/figures/mesh2.png" alt="mesh 2"/></p><p>So far these meshes have contained a single defined area - a single &#39;patch&#39;. It&#39;s possible to construct a mesh that consists of more than one patch. The following example uses <a href="../../reference/api/#Luxor.add_mesh_patch"><code>add_mesh_patch</code></a> to build a single mesh consisting of 100 smaller patches, which are placed next to each other but don&#39;t always define the same colors at identical control points.</p><pre><code class="language-julia hljs">tiles = Tiler(500, 500, 10, 10, margin=0)

the_mesh = mesh(rect(first(tiles[1]), 10, 10), [&quot;red&quot;])

col1 = RGB(rand(), rand(), rand())
col2 = RGB(rand(), rand(), rand())
col3 = RGB(rand(), rand(), rand())
col4 = RGB(rand(), rand(), rand())
for (pos, n) in tiles
    bx = box(
        pos - (tiles.tilewidth/2, tiles.tileheight/2),
        pos + (tiles.tilewidth/2, tiles.tileheight/2),
        vertices = true)
    add_mesh_patch(the_mesh, bx,
        Random.shuffle!([col1, col2, col3, col4]))
end
setmesh(the_mesh)
paint()</code></pre><img src="0bdcd1f5.png" alt="Example block output"/><p>The next example constructs a conical mesh from many triangular patches, where each patch shows a different area of the HSB color space. Any graphic drawn after <code>setmesh()</code>, such as the hypotrochoid, is drawn using the mesh.</p><pre><code class="language-julia hljs">using Luxor, Colors

@drawsvg begin
    radius = 300
    L = 300
    mesh1 = mesh([Point(0, 0), polar(radius, 0), polar(radius, 2π/100)], [RGBA(0, 0, 0, 0)])
    sethue(&quot;red&quot;)
    for θ in range(0, 2π, length=L)
        t = [O, O + polar(radius, θ), O + polar(radius, θ + 2π/L)]
        add_mesh_patch(mesh1, t,
            [
            HSB(rescale(θ, 0, 2π, 0, 360), 0.9, 1),
            HSB(rescale(θ, 0, 2π, 0, 360), 0.9, 1),
            HSB(rescale(θ, 0, 2π, 0, 360), 0.9, 1),
            ])
    end
    setmesh(mesh1)
    hypotrochoid(350, 155, 100, :stroke)
end</code></pre><img src="d374251e.svg" alt="Example block output"/><h2 id="Masks"><a class="docs-heading-anchor" href="#Masks">Masks</a><a id="Masks-1"></a><a class="docs-heading-anchor-permalink" href="#Masks" title="Permalink"></a></h2><p>A simple mask function lets you use a circular or rectangular shape to control graphics that are drawn over it. <a href="../../reference/api/#Luxor.mask-Tuple{Point, Point, Any, Any}"><code>mask</code></a> takes a position and a shape, and returns a value between 0 and 1 for that position, depending on its position relative to the shape.</p><p>In the first example, the gray color of each tile is determined by its location relative to the center of the masking circle <code>(O, bw/2)</code>; the value is <code>1.0</code> at the center, and <code>0.0</code> at the circumference. The value could be used to control opacity, shape, or anything else that is relevant to graphics at a particular position.</p><pre><code class="language-julia hljs">tiles = Tiler(600, 600, 15, 15, margin=0)
bw = boxwidth(BoundingBox())
for (pos, n) in tiles
    setgray(mask(pos, O, bw/2))
    box(pos, tiles.tilewidth, tiles.tileheight, action = :fillstroke)
end

sethue(&quot;white&quot;)
circle(O, bw/2, :stroke)</code></pre><p><img src="../../assets/figures/mask.png" alt="mask"/></p><p>The second example uses the distance of each tile relative to the rectangle <code>O, bw, bw</code> to determine the gray color.</p><pre><code class="language-julia hljs">tiles = Tiler(600, 600, 30, 30)

bw = boxwidth(BoundingBox())
bh = boxheight(BoundingBox())
for (pos, n) in tiles
    mv = mask(pos, O, bw, bh, easingfunction=easeinoutcubic)
    setgray(mv)
    box(pos, tiles.tilewidth, tiles.tileheight, action = :fillstroke)
end</code></pre><p><img src="../../assets/figures/mask1.png" alt="mask1"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tables-grids/">« Work with tables and grids</a><a class="docs-footer-nextpage" href="../polygons/">Work with polygons »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Sunday 14 January 2024 10:15">Sunday 14 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
