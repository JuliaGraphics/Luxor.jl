<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Work with polygons · Luxor</title><meta name="title" content="Work with polygons · Luxor"/><meta property="og:title" content="Work with polygons · Luxor"/><meta property="twitter:title" content="Work with polygons · Luxor"/><meta name="description" content="Documentation for Luxor."/><meta property="og:description" content="Documentation for Luxor."/><meta property="twitter:description" content="Documentation for Luxor."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/luxor-docs.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Luxor logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Luxor</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction to Luxor</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorial/helloworld/">Hello World</a></li><li><a class="tocitem" href="../../tutorial/basicpath/">Basic path building</a></li><li><a class="tocitem" href="../../tutorial/quickstart/">Design a logo</a></li><li><a class="tocitem" href="../../tutorial/basictutorial/">Geometry tutorial</a></li><li><a class="tocitem" href="../../tutorial/pixels/">Playing with pixels</a></li><li><a class="tocitem" href="../../tutorial/simple-animation/">Simple animation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../example/examples/">Simple examples</a></li><li><a class="tocitem" href="../../example/moreexamples/">More examples</a></li><li><a class="tocitem" href="../../example/gallery/">Gallery</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">How to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../createdrawings/">Create drawings</a></li><li><a class="tocitem" href="../simplegraphics/">Draw simple shapes</a></li><li><a class="tocitem" href="../geometrytools/">Use geometry tools</a></li><li><a class="tocitem" href="../tables-grids/">Work with tables and grids</a></li><li><a class="tocitem" href="../colors-styles/">Use colors and styles</a></li><li class="is-active"><a class="tocitem" href>Work with polygons</a><ul class="internal"><li><a class="tocitem" href="#Regular-polygons-(&quot;ngons&quot;)"><span>Regular polygons (&quot;ngons&quot;)</span></a></li><li><a class="tocitem" href="#Polygons"><span>Polygons</span></a></li><li><a class="tocitem" href="#Offsetting-polygons"><span>Offsetting polygons</span></a></li><li><a class="tocitem" href="#Converting-paths-to-polygons"><span>Converting paths to polygons</span></a></li><li><a class="tocitem" href="#Bezigons"><span>Bezigons</span></a></li><li><a class="tocitem" href="#Polygons-to-Bézier-paths-and-back-again"><span>Polygons to Bézier paths and back again</span></a></li><li><a class="tocitem" href="#Brush-strokes"><span>Brush strokes</span></a></li><li><a class="tocitem" href="#Polygon-information"><span>Polygon information</span></a></li><li><a class="tocitem" href="#Polygon-selection-and-modification"><span>Polygon selection and modification</span></a></li><li><a class="tocitem" href="#Morphing-polygons"><span>Morphing polygons</span></a></li><li><a class="tocitem" href="#Other-polygon-operations"><span>Other polygon operations</span></a></li><li><a class="tocitem" href="#Polygon/line-Intersections"><span>Polygon/line Intersections</span></a></li><li><a class="tocitem" href="#Polygon-intersections"><span>Polygon intersections</span></a></li><li><a class="tocitem" href="#Triangulation"><span>Triangulation</span></a></li></ul></li><li><a class="tocitem" href="../text/">Add text</a></li><li><a class="tocitem" href="../clipping/">Clip graphics</a></li><li><a class="tocitem" href="../images/">Placing images</a></li><li><a class="tocitem" href="../turtle/">Turtle graphics</a></li><li><a class="tocitem" href="../animation/">Make animations</a></li><li><a class="tocitem" href="../snapshots/">Snapshots</a></li><li><a class="tocitem" href="../livegraphics/">Interactive graphics and Threads</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Explanations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../explanation/basics/">Basic concepts</a></li><li><a class="tocitem" href="../../explanation/pathspolygons/">Paths vs Polygon</a></li><li><a class="tocitem" href="../../explanation/perfectpixels/">Perfect pixels and antialising</a></li><li><a class="tocitem" href="../../explanation/transforms/">Transforms and matrices</a></li><li><a class="tocitem" href="../../explanation/imagematrix/">Image matrix</a></li><li><a class="tocitem" href="../../explanation/fonts/">Fonts on Linux</a></li><li><a class="tocitem" href="../../explanation/luxorcairo/">Luxor and Cairo</a></li><li><a class="tocitem" href="../../explanation/strokepathdispatch/">Customize strokepath/fillpath</a></li><li><a class="tocitem" href="../../explanation/contributing/">Contributing</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/functionindex/">Alphabetical function list</a></li><li><a class="tocitem" href="../../reference/api/">Function reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">How to guides</a></li><li class="is-active"><a href>Work with polygons</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Work with polygons</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGraphics/Luxor.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGraphics/Luxor.jl/blob/master/docs/src/howto/polygons.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Polygons-and-paths"><a class="docs-heading-anchor" href="#Polygons-and-paths">Polygons and paths</a><a id="Polygons-and-paths-1"></a><a class="docs-heading-anchor-permalink" href="#Polygons-and-paths" title="Permalink"></a></h1><p>For drawing shapes, Luxor provides polygons and paths.</p><p>A polygon is an ordered collection of Points stored in an array. To draw a polygon, you can use the <a href="../../reference/api/#Luxor.poly"><code>poly()</code></a> function, which converts the points to a path.</p><p>A path is a sequence of one or more straight and curved (circular arc or Bézier curve) segments. Paths can consist of subpaths. Luxor maintains a &#39;current path&#39;, to which you can add lines and curves until you finish with a stroke or fill instruction.</p><p>You can store a path in a Path type, which contains path elements.</p><p>Luxor also provides a BezierPath type, which is an array of four-point tuples, each of which is a Bézier cubic curve section.</p><table><tr><th style="text-align: left">create</th><th style="text-align: left">convert</th><th style="text-align: left">draw</th><th style="text-align: left">info</th><th style="text-align: left">edit</th></tr><tr><td style="text-align: left"><em>polygons</em></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="../../reference/api/#Luxor.ngon"><code>ngon</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.polysmooth-Tuple{Vector{Point}, Any, Symbol}"><code>polysmooth</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.poly"><code>poly</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.isinside-Tuple{Point, BoundingBox}"><code>isinside</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.simplify"><code>simplify</code></a></td></tr><tr><td style="text-align: left"><a href="../../reference/api/#Luxor.ngonside"><code>ngonside</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.polytopath-Tuple{Vector{Point}}"><code>polytopath</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.prettypoly"><code>prettypoly</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.polyperimeter-Tuple{Vector{Point}}"><code>polyperimeter</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.polysplit-Tuple{Vector{Point}, Point, Point}"><code>polysplit</code></a></td></tr><tr><td style="text-align: left"><a href="../../reference/api/#Luxor.star"><code>star</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.polyintersect-Tuple{AbstractVector{Point}, AbstractVector{Point}}"><code>polyintersect</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.polysmooth-Tuple{Vector{Point}, Any, Symbol}"><code>polysmooth</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.polyarea-Tuple{Vector{Point}}"><code>polyarea</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.polyportion"><code>polyportion</code></a></td></tr><tr><td style="text-align: left"><a href="../../reference/api/#Luxor.polycross"><code>polycross</code></a></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><a href="../../reference/api/#Luxor.polycentroid-Tuple{Vector{Point}}"><code>polycentroid</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.polyremainder"><code>polyremainder</code></a></td></tr><tr><td style="text-align: left"><a href="../../reference/api/#Luxor.offsetpoly-Tuple{Any, Function}"><code>offsetpoly</code></a></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><a href="../../reference/api/#Luxor.BoundingBox-Tuple{AbstractString}"><code>BoundingBox</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.polysortbyangle"><code>polysortbyangle</code></a></td></tr><tr><td style="text-align: left"><a href="../../reference/api/#Luxor.hypotrochoid-Tuple{Any, Any, Any}"><code>hypotrochoid</code></a></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><a href="../../reference/api/#Luxor.ispolyclockwise-Tuple{Vector{Point}}"><code>ispolyclockwise</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.polysortbydistance-Tuple{Vector{Point}, Point}"><code>polysortbydistance</code></a></td></tr><tr><td style="text-align: left"><a href="../../reference/api/#Luxor.epitrochoid-Tuple{Any, Any, Any}"><code>epitrochoid</code></a></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><a href="../../reference/api/#Luxor.ispolyconvex-Tuple{Any}"><code>ispolyconvex</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.polyclip-Tuple{Vector{Point}, Vector{Point}}"><code>polyclip</code></a></td></tr><tr><td style="text-align: left"><a href="../../reference/api/#Luxor.polyrotate!-Tuple{Any, Any}"><code>polyrotate!</code></a></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><a href="../../reference/api/#Luxor.ispointonpoly-Tuple{Point, Vector{Point}}"><code>ispointonpoly</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.polymove!-Tuple{Any, Point, Point}"><code>polymove!</code></a></td></tr><tr><td style="text-align: left"><a href="../../reference/api/#Luxor.polyfit"><code>polyfit</code></a></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><a href="../../reference/api/#Luxor.polyscale!-Tuple{Any, Any, Any}"><code>polyscale!</code></a></td></tr><tr><td style="text-align: left"><a href="../../reference/api/#Luxor.polyhull-Tuple{Vector{Point}}"><code>polyhull</code></a></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="../../reference/api/#Luxor.polysuper"><code>polysuper</code></a></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><a href="../../reference/api/#Luxor.polyreflect!"><code>polyreflect!</code></a></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><a href="../../reference/api/#Luxor.polysample-Tuple{Vector{Point}, Integer}"><code>polysample</code></a></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><a href="../../reference/api/#Luxor.polytriangulate-Tuple{Vector{Point}}"><code>polytriangulate</code></a></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><a href="../../reference/api/#Luxor.insertvertices!-Tuple{Any}"><code>insertvertices!</code></a></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><a href="../../reference/api/#Luxor.polymorph-Tuple{Array{Vector{Point}}, Array{Vector{Point}}, Any}"><code>polymorph</code></a></td></tr><tr><td style="text-align: left"><em>paths</em></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="../../reference/api/#Luxor.storepath-Tuple{}"><code>storepath</code></a></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="../../reference/api/#Luxor.getpath-Tuple{}"><code>getpath</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.pathtopoly-Tuple{}"><code>pathtopoly</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.drawpath-Tuple{Path, Real}"><code>drawpath</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.pathlength-Tuple{Path}"><code>pathlength</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.pathsample-Tuple{Path, Any}"><code>pathsample</code></a></td></tr><tr><td style="text-align: left"><a href="../../reference/api/#Luxor.getpathflat-Tuple{}"><code>getpathflat</code></a></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><em>Bezier paths</em></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="../../reference/api/#Luxor.makebezierpath-Tuple{Vector{Point}}"><code>makebezierpath</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.pathtobezierpaths-Tuple{}"><code>pathtobezierpaths</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.drawbezierpath-Tuple{BezierPath, Any}"><code>drawbezierpath</code></a></td><td style="text-align: left"></td><td style="text-align: left"><a href="../../reference/api/#Luxor.trimbezier-Tuple{BezierPathSegment, Any, Any}"><code>trimbezier</code></a></td></tr><tr><td style="text-align: left"><a href="../../reference/api/#Luxor.pathtobezierpaths-Tuple{}"><code>pathtobezierpaths</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.bezierpathtopoly-Tuple{BezierPath}"><code>bezierpathtopoly</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.brush"><code>brush</code></a></td><td style="text-align: left"></td><td style="text-align: left"><a href="../../reference/api/#Luxor.splitbezier-Tuple{BezierPathSegment, Any}"><code>splitbezier</code></a></td></tr><tr><td style="text-align: left"><code>BezierPath</code></td><td style="text-align: left"><a href="../../reference/api/#Luxor.bezierpathtopath-Tuple{BezierPath}"><code>bezierpathtopath</code></a></td><td style="text-align: left"><a href="../../reference/api/#Luxor.bezigon-Tuple{Vector{Point}, Any}"><code>bezigon</code></a></td><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>BezierPathSegment</code></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="../../reference/api/#Luxor.beziersegmentangles-Tuple{Any, Any}"><code>beziersegmentangles</code></a></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr></table><h2 id="Regular-polygons-(&quot;ngons&quot;)"><a class="docs-heading-anchor" href="#Regular-polygons-(&quot;ngons&quot;)">Regular polygons (&quot;ngons&quot;)</a><a id="Regular-polygons-(&quot;ngons&quot;)-1"></a><a class="docs-heading-anchor-permalink" href="#Regular-polygons-(&quot;ngons&quot;)" title="Permalink"></a></h2><p>A polygon is an array of points. The points can be joined with straight lines.</p><p>You can make regular polygons — from triangles, pentagons, hexagons, septagons, heptagons, octagons, nonagons, decagons, and on-and-on-agons — with <a href="../../reference/api/#Luxor.ngon"><code>ngon</code></a>.</p><pre><code class="language-julia hljs">cols = distinguishable_colors(10)
setline(2)
fontsize(12)
tiles = Tiler(700, 600, 3, 3)

for (pos, n) in tiles
    @layer begin
        translate(pos)

        p = ngon(Point(0, 0), 80, n, vertices=true)

        sethue(cols[n])

        poly(p, action = :fill, close=true)
        sethue(&quot;grey10&quot;)
        poly(p, action = :stroke, close=true)

        circle(Point(0, 0), 4, action = :fill)

        label.([string(i) for i in 1:n], slope.(O, p), p, offset=5)
    end
end</code></pre><p>The initial orientation of the polygon defaults to 0.</p><p><img src="../../assets/figures/n-gon.png" alt="n-gons"/></p><p>If you want to specify the side length rather than the circumradius, use <a href="../../reference/api/#Luxor.ngonside"><code>ngonside</code></a>.</p><pre><code class="language-julia hljs">for i in 20:-1:3
    sethue(i/20, 0.5, 0.7)
    ngonside(Point(0, 0), 75, i, 0, action = :fill)
    sethue(&quot;grey10&quot;)
    ngonside(Point(0, 0), 75, i, 0, action = :stroke)
end</code></pre><p><img src="../../assets/figures/ngonside.png" alt="stars"/></p><p>The functions return the vertices, or you can use the <code>vertices=true</code> option.</p><pre><code class="language-julia hljs">ngon(Point(0, 0), 10, 5)</code></pre><pre><code class="language-5-element hljs"> Point(3.0901699437494745, 9.510565162951535)
 Point(-8.090169943749473, 5.877852522924733)
 Point(-8.090169943749475, -5.87785252292473)
 Point(3.0901699437494723, -9.510565162951536)
 Point(10.0, -2.4492935982947065e-15)</code></pre><h2 id="Polygons"><a class="docs-heading-anchor" href="#Polygons">Polygons</a><a id="Polygons-1"></a><a class="docs-heading-anchor-permalink" href="#Polygons" title="Permalink"></a></h2><p>Use <a href="../../reference/api/#Luxor.poly"><code>poly</code></a> to draw lines connecting the points and/or just fill the area:</p><pre><code class="language-julia hljs">tiles = Tiler(600, 250, 1, 2, margin=20)
tile1, tile2 = collect(tiles)

randompoints = [Point(rand(-100:100), rand(-100:100)) for i in 1:10]

gsave()
translate(tile1[1])
poly(randompoints, action = :stroke)
grestore()

gsave()
translate(tile2[1])
poly(randompoints, action = :fill)
grestore()</code></pre><p><img src="../../assets/figures/simplepoly.png" alt="simple poly"/></p><h3 id="Holes"><a class="docs-heading-anchor" href="#Holes">Holes</a><a id="Holes-1"></a><a class="docs-heading-anchor-permalink" href="#Holes" title="Permalink"></a></h3><p>To form a hole in a polygon, you reverse the direction of the hole compared to the outer shape. When converted to paths (which happens as part of the drawing process), the reversed polygon forms a hole when drawn.</p><p>In this example, the first nut is made by reversing the list of points, the second by using the keyword argument when constructing the shape, and the third when drawing the polygon as a path.</p><pre><code class="language-julia hljs"># nut 1

translate(-100, 0)

nut = ngon(O, 120, 6, vertices=true)
hole = reverse(ngon(O, 70, 6, vertices=true))

poly.((nut, hole), action = :path)
fillpath()

# nut 2

translate(100, 0)

sethue(&quot;purple&quot;)
nut = ngon(O, 120, 6, vertices=true)
hole = ngon(O, 70, 6, reversepath=true, vertices=true)

poly(nut, action = :path)
poly(hole, action = :path)
fillpath()

# nut 3

translate(100, 0)

sethue(&quot;orange&quot;)
nut = ngon(O, 120, 6, vertices=true)
hole = ngon(O, 70, 6, vertices=true)

poly(nut, action = :path)
newsubpath()
poly(hole, reversepath=true, action = :path)
fillpath()</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="600pt" height="300pt" viewBox="0 0 600 300" version="1.1">
<g id="surface957">
<rect x="0" y="0" width="600" height="300" style="fill:rgb(98.039216%25,92.156863%25,84.313725%25);fill-opacity:1;stroke:none;"/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(0%25,0%25,0%25);fill-opacity:1;" d="M 260 253.921875 L 140 253.921875 L 80 150 L 140 46.078125 L 260 46.078125 L 320 150 M 270 150 L 235 89.378906 L 165 89.378906 L 130 150 L 165 210.621094 L 235 210.621094 "/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(50.196078%25,0%25,50.196078%25);fill-opacity:1;" d="M 360 253.921875 L 240 253.921875 L 180 150 L 240 46.078125 L 360 46.078125 L 420 150 M 370 150 L 335 89.378906 L 265 89.378906 L 230 150 L 265 210.621094 L 335 210.621094 "/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(100%25,64.705882%25,0%25);fill-opacity:1;" d="M 460 253.921875 L 340 253.921875 L 280 150 L 340 46.078125 L 460 46.078125 L 520 150 M 470 150 L 435 89.378906 L 365 89.378906 L 330 150 L 365 210.621094 L 435 210.621094 "/>
</g>
</svg>
'/><h3 id="Fill-rule"><a class="docs-heading-anchor" href="#Fill-rule">Fill rule</a><a id="Fill-rule-1"></a><a class="docs-heading-anchor-permalink" href="#Fill-rule" title="Permalink"></a></h3><p>You can have more control over the hole business by using the <code>setfillrule()</code> function. This allows you to set the fill rule for subpaths to either <code>:winding</code> or <code>:even_odd</code>. The fill rule is used to select how paths that contain subpaths are filled. The default rule (which determines the behaviour we usually see for the current drawing) is <code>:winding</code>.</p><p>See the wikipedia entry for <a href="https://en.wikipedia.org/wiki/Even–odd_rule">Even–odd_rule</a> for more details.</p><p>In the following example, the default <code>:winding</code> rule is shown in cyan, on the left, and the <code>reverse</code> flag controls whether the subpath is reversed or not. Without it, the boxes would just be drawn on top of each other and you&#39;d just see a big cyan box.</p><p>The <code>:even_odd</code> rule is shown in operation in magenta, on the right. The results are the same, but the code can be simpler, because <code>reverse</code>-ing every other subpath is not required.</p><pre><code class="language-julia hljs">fontsize(69)
panes = Tiler(800, 400, 1, 2)

setfillrule(:winding)
sethue(&quot;cyan&quot;)

@layer begin
    translate(first(panes[1]))
    let
        reverse = false
        for s in 300:-20:30
            box(O, s, s, reversepath=reverse, :path)
            reverse = !reverse
        end
    end
    fillpath()
end

setfillrule(:even_odd)
sethue(&quot;magenta&quot;)

@layer begin
    translate(first(panes[2]))
    for s in 300:-20:30
        box(O, s, s, :path)
    end
    fillpath()
end</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="800pt" height="400pt" viewBox="0 0 800 400" version="1.1">
<g id="surface962">
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(0%25,100%25,100%25);fill-opacity:1;" d="M 55 350 L 55 50 L 355 50 L 355 350 Z M 65 340 L 345 340 L 345 60 L 65 60 Z M 75 330 L 75 70 L 335 70 L 335 330 Z M 85 320 L 325 320 L 325 80 L 85 80 Z M 95 310 L 95 90 L 315 90 L 315 310 Z M 105 300 L 305 300 L 305 100 L 105 100 Z M 115 290 L 115 110 L 295 110 L 295 290 Z M 125 280 L 285 280 L 285 120 L 125 120 Z M 135 270 L 135 130 L 275 130 L 275 270 Z M 145 260 L 265 260 L 265 140 L 145 140 Z M 155 250 L 155 150 L 255 150 L 255 250 Z M 165 240 L 245 240 L 245 160 L 165 160 Z M 175 230 L 175 170 L 235 170 L 235 230 Z M 185 220 L 225 220 L 225 180 L 185 180 Z M 185 220 "/>
<path style=" stroke:none;fill-rule:evenodd;fill:rgb(100%25,0%25,100%25);fill-opacity:1;" d="M 445 350 L 445 50 L 745 50 L 745 350 Z M 455 340 L 455 60 L 735 60 L 735 340 Z M 465 330 L 465 70 L 725 70 L 725 330 Z M 475 320 L 475 80 L 715 80 L 715 320 Z M 485 310 L 485 90 L 705 90 L 705 310 Z M 495 300 L 495 100 L 695 100 L 695 300 Z M 505 290 L 505 110 L 685 110 L 685 290 Z M 515 280 L 515 120 L 675 120 L 675 280 Z M 525 270 L 525 130 L 665 130 L 665 270 Z M 535 260 L 535 140 L 655 140 L 655 260 Z M 545 250 L 545 150 L 645 150 L 645 250 Z M 555 240 L 555 160 L 635 160 L 635 240 Z M 565 230 L 565 170 L 625 170 L 625 230 Z M 575 220 L 575 180 L 615 180 L 615 220 Z M 575 220 "/>
</g>
</svg>
'/><h3 id="Pretty-polygons"><a class="docs-heading-anchor" href="#Pretty-polygons">Pretty polygons</a><a id="Pretty-polygons-1"></a><a class="docs-heading-anchor-permalink" href="#Pretty-polygons" title="Permalink"></a></h3><p>The <a href="../../reference/api/#Luxor.prettypoly"><code>prettypoly</code></a> function can place graphics at each vertex of a polygon. After the polygon action, the supplied <code>vertexfunction</code> function is evaluated at each vertex. For example, to mark each vertex of a polygon with a randomly-colored circle:</p><pre><code class="language-julia hljs">apoly = star(O, 70, 7, 0.6, 0, vertices=true)
prettypoly(apoly, action=:fill, () -&gt;
        begin
            randomhue()
            circle(O, 10, action=:fill)
        end,
    close=true)</code></pre><p><img src="../../assets/figures/prettypolybasic.png" alt="prettypoly"/></p><p>An optional keyword argument <code>vertexlabels</code> lets you pass a function that can number each vertex. The function can use two arguments, the current vertex number, and the total number of points in the polygon:</p><pre><code class="language-julia hljs">apoly = star(O, 80, 5, 0.6, 0, vertices=true)
prettypoly(apoly,
    :stroke,
    vertexlabels = (n, l) -&gt; (text(string(n, &quot; of &quot;, l), halign=:center)),
    close=true)</code></pre><p><img src="../../assets/figures/prettypolyvertex.png" alt="prettypoly"/></p><p>Recursive decoration is possible:</p><pre><code class="language-julia hljs">decorate(pos, p, level) = begin
    if level &lt; 4
        randomhue()
        scale(0.25, 0.25)
        prettypoly(p, action = :fill, () -&gt; decorate(pos, p, level+1), close=true)
    end
end

apoly = star(O, 100, 7, 0.6, 0, vertices=true)
prettypoly(apoly, action = :fill, () -&gt; decorate(O, apoly, 1), close=true)</code></pre><p><img src="../../assets/figures/prettypolyrecursive.png" alt="prettypoly"/></p><p>Polygons can be simplified using the Douglas-Peucker algorithm (non-recursive version), via <a href="../../reference/api/#Luxor.simplify"><code>simplify</code></a>.</p><pre><code class="language-julia hljs">sincurve = [Point(6x, 80sin(x)) for x in -5π:π/20:5π]
prettypoly(collect(sincurve), action = :stroke,
    () -&gt; begin
            sethue(&quot;red&quot;)
            circle(O, 3, action = :fill)
          end)
text(string(&quot;number of points: &quot;, length(collect(sincurve))), 0, 100)
translate(0, 200)
simplercurve = simplify(collect(sincurve), 0.5)
prettypoly(simplercurve, action = :stroke,
    () -&gt; begin
            sethue(&quot;red&quot;)
            circle(O, 3, action = :fill)
          end)
text(string(&quot;number of points: &quot;, length(simplercurve)), 0, 100)</code></pre><p><img src="../../assets/figures/simplify.png" alt="simplify"/></p><h3 id="Quickly-changing-polygons"><a class="docs-heading-anchor" href="#Quickly-changing-polygons">Quickly changing polygons</a><a id="Quickly-changing-polygons-1"></a><a class="docs-heading-anchor-permalink" href="#Quickly-changing-polygons" title="Permalink"></a></h3><p>If you want to quickly and permanently modify a polygon, there&#39;s <a href="../../reference/api/#Luxor.polymove!-Tuple{Any, Point, Point}"><code>polymove!</code></a>, <a href="../../reference/api/#Luxor.polyscale!-Tuple{Any, Any, Any}"><code>polyscale!</code></a>, <a href="../../reference/api/#Luxor.polyreflect!"><code>polyreflect!</code></a>, and <a href="../../reference/api/#Luxor.polyrotate!-Tuple{Any, Any}"><code>polyrotate!</code></a>.</p><pre><code class="language-julia hljs">shape = star(O, 10, 5, 0.5, 0, vertices=true)

circle(O, 3, action = :stroke)

polymove!(shape, O, O + (0, 50))

poly(shape, action = :stroke, close=true)

for i in 1:20
    poly(polyrotate!(shape, π/5), action = :fill, close=true)
    polyscale!(shape, 19//18)
end</code></pre><p>The polygon is continually modified (notice the <code>!</code> in the function names).</p><p><img src="../../assets/figures/polychange.png" alt="poly changing"/></p><pre><code class="language-julia hljs">pgon = randompointarray(BoundingBox()/2 ..., 10)
polymove!(pgon, O, Point(-80, 0))
poly(pgon, action = :fill, close=true)
# reflect in y axis:
polyreflect!(pgon, Point(0, 0), Point(0, 100))
sethue(&quot;blue&quot;)
poly(pgon, action = :fill, close=true)</code></pre><p><img src="../../assets/figures/polyreflect.png" alt="poly reflect"/></p><h3 id="Other-functions"><a class="docs-heading-anchor" href="#Other-functions">Other functions</a><a id="Other-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-functions" title="Permalink"></a></h3><p>There are a number of experimental polygon functions. These won&#39;t work well for polygons that aren&#39;t simple or where the sides intersect each other, but they sometimes do a reasonable job. For example, here&#39;s <a href="../../reference/api/#Luxor.polysplit-Tuple{Vector{Point}, Point, Point}"><code>polysplit</code></a>:</p><pre><code class="language-julia hljs">s = squircle(O, 60, 60, vertices=true)
pt1 = Point(0, -120)
pt2 = Point(0, 120)
line(pt1, pt2, action = :stroke)
poly1, poly2 = polysplit(s, pt1, pt2)
randomhue()
poly(poly1, action = :fill)
randomhue()
poly(poly2, action = :fill)</code></pre><p><img src="../../assets/figures/polysplit.png" alt="polysplit"/></p><h3 id="Smoothing-polygons"><a class="docs-heading-anchor" href="#Smoothing-polygons">Smoothing polygons</a><a id="Smoothing-polygons-1"></a><a class="docs-heading-anchor-permalink" href="#Smoothing-polygons" title="Permalink"></a></h3><p>Because polygons can have sharp corners, the experimental <a href="../../reference/api/#Luxor.polysmooth-Tuple{Vector{Point}, Any, Symbol}"><code>polysmooth</code></a> function attempts to insert arcs at the corners and draw the result.</p><p>The original polygon is shown in red; the smoothed polygon is shown on top:</p><pre><code class="language-julia hljs">tiles = Tiler(600, 250, 1, 5, margin=10)
for (pos, n) in tiles
    p = star(pos, tiles.tilewidth/2 - 2, 5, 0.3, 0, vertices=true)
    sethue(&quot;red&quot;)
    poly(p, close=true, action = :stroke)
    sethue(&quot;grey10&quot;)
    polysmooth(p, n * 2, action = :fill)
end</code></pre><p><img src="../../assets/figures/polysmooth.svg" alt="polysmooth"/></p><p>The final polygon shows that you can get unexpected results if you attempt to smooth corners by more than the possible amount. The <code>debug=true</code> option draws the circles if you want to find out what&#39;s going wrong, or if you want to explore the effect in more detail.</p><pre><code class="language-julia hljs">p = star(O, 60, 5, 0.35, 0, vertices=true)
setdash(&quot;dot&quot;)
sethue(&quot;red&quot;)
prettypoly(p, close=true, action = :stroke)
setdash(&quot;solid&quot;)
sethue(&quot;grey10&quot;)
polysmooth(p, 40, action = :fill, debug=true)</code></pre><p><img src="../../assets/figures/polysmooth-pathological.svg" alt="polysmooth"/></p><h2 id="Offsetting-polygons"><a class="docs-heading-anchor" href="#Offsetting-polygons">Offsetting polygons</a><a id="Offsetting-polygons-1"></a><a class="docs-heading-anchor-permalink" href="#Offsetting-polygons" title="Permalink"></a></h2><p>There are three methods for <a href="../../reference/api/#Luxor.offsetpoly-Tuple{Any, Function}"><code>offsetpoly</code></a>, a function which constructs a new polygon that&#39;s offset from an existing one.</p><ul><li><p><code>offsetpoly(plist, d)</code> treats the <code>plist</code> of points as a polygon  with <code>n</code> vertices joined by <code>n</code> lines with offset <code>d</code> on both  sides.</p></li><li><p><code>offsetpoly(plist, startoffset=d1, endoffset=d2)</code> treats the <code>plist</code> of points as a polyline with <code>n</code> vertices joined by <code>n-1</code> lines, where the offset varies from <code>startoffset</code> to <code>endoffset</code>.</p></li><li><p><code>offsetpoly(plist, f::function)</code> applies a function f at each vertex of the polyline to determine the width of the offset polygon at that point.</p></li></ul><p>The first method is good for making closed shapes larger or smaller. The other methods are useful for building shapes around an open linear spine.</p><h4 id="1:-n-vertices-joined-by-n-lines"><a class="docs-heading-anchor" href="#1:-n-vertices-joined-by-n-lines">1: <code>n</code> vertices joined by <code>n</code> lines</a><a id="1:-n-vertices-joined-by-n-lines-1"></a><a class="docs-heading-anchor-permalink" href="#1:-n-vertices-joined-by-n-lines" title="Permalink"></a></h4><p>The <code>offsetpoly(plist, d)</code> method constructs a closed polygon outside or inside an existing polygon, at distance <code>d</code>.  The last vertex in <code>plist</code> as assumed to be be connected to the first.</p><p>In the following example, the dotted red polygon is the original, the black polygons have positive offsets and surround the original, the cyan polygons have negative offsets and run inside the original. Use <a href="../../reference/api/#Luxor.poly"><code>poly</code></a> to draw the result.</p><pre><code class="language-julia hljs">p = star(O, 45, 5, 0.5, 0, vertices=true)
sethue(&quot;red&quot;)
setdash(&quot;dot&quot;)
poly(p, action = :stroke, close=true)
setdash(&quot;solid&quot;)
sethue(&quot;black&quot;)

poly(offsetpoly(p, 20), action = :stroke, close=true)
poly(offsetpoly(p, 25), action = :stroke, close=true)
poly(offsetpoly(p, 30), action = :stroke, close=true)
poly(offsetpoly(p, 35), action = :stroke, close=true)

sethue(&quot;darkcyan&quot;)

poly(offsetpoly(p, -10), action = :stroke, close=true)
poly(offsetpoly(p, -15), action = :stroke, close=true)
poly(offsetpoly(p, -20), action = :stroke, close=true)</code></pre><p><img src="../../assets/figures/polyoffset-simple.png" alt="offset poly 2"/></p><p>The function is intended for simple cases, and it can go wrong if pushed too far. Sometimes the offset distances can be larger than the polygon segments, and things will start to go wrong. In this example, the offset goes so far negative that the polygon overshoots the origin, becomes inverted and starts getting larger again.</p><p><img src="../../assets/figures/polygon-offset.gif" alt="offset poly problem"/></p><h4 id="2-n-vertices-joined-by-n-1-lines"><a class="docs-heading-anchor" href="#2-n-vertices-joined-by-n-1-lines">2 <code>n</code> vertices joined by <code>n-1</code> lines</a><a id="2-n-vertices-joined-by-n-1-lines-1"></a><a class="docs-heading-anchor-permalink" href="#2-n-vertices-joined-by-n-1-lines" title="Permalink"></a></h4><p>The <code>offsetpoly(plist)</code> method constructs a polygon around a line joining the lines in <code>plist</code>. At the start of the line, the polygon will be <code>startoffset</code> units on each side; by the end of the line, the polygon will be <code>endoffset</code> units on each side. The last vertex isn&#39;t joined to the first, hence <code>n-1</code>.</p><p>In the following example, the original spine is drawn in orange, on top of the black polygon that&#39;s constructed to be offset 2 units on each side at the start and 30 units on each side at the end.</p><pre><code class="language-julia hljs">spine = [Point(20 + 40x, 15sin(2x)) for x in 0:.1:4π]

for θ in range(0, 2π, step=π/12)
    @layer begin
        sethue(&quot;black&quot;)
        rotate(θ)
        poly(offsetpoly(spine, startoffset=1, endoffset=30), action = :fill)
        sethue(&quot;orange&quot;)
        poly(spine, action = :stroke)
    end
end</code></pre><p><img src="../../assets/figures/polyoffset-open.png" alt="offset poly open"/></p><h5 id="Using-an-offset-control-function"><a class="docs-heading-anchor" href="#Using-an-offset-control-function">Using an offset-control function</a><a id="Using-an-offset-control-function-1"></a><a class="docs-heading-anchor-permalink" href="#Using-an-offset-control-function" title="Permalink"></a></h5><p>This method accepts a keyword argument that allows you to control the way the offsets are applied, using the easing functionality built in to Luxor (see <a href="../animation/#Animation-helper-functions">Animation helper functions</a>).</p><p>By default the function is <code>lineartween</code>, so the offset changes linearly between the <code>startoffset</code> and the <code>endoffset</code> values. With other easing functions, this change is modulated. For example, the <code>easeinoutquad</code> function moves between start and end values using a quadratic motion.</p><pre><code class="language-julia hljs">spine = between.(O - (200, 0), O + (200, 0), 0:0.025:1)

sethue(&quot;red&quot;)
prettypoly(spine, action = :stroke)

sethue(&quot;black&quot;)
pg = offsetpoly(spine, startoffset=0, endoffset=200, easingfunction=easeinoutquad)
prettypoly(pg, action = :stroke, close=true)</code></pre><p><img src="../../assets/figures/polyoffset-easing.png" alt="offset poly easing"/></p><p>But in the next example, the function <code>f(t, b, c, d)</code> (the Luxor standard four-argument easing function) is defined to run from 0 to 2 and back again as <code>t</code> goes from  0 to 1, so the initial and final offsets are &#39;eased&#39; to 0, and at the middle of the polygon the offsets at that location are &#39;eased&#39; to 2 × the offset value at that point.</p><pre><code class="language-julia hljs">spine = [Point(20x, 15sin(x)) for x in -4π:pi/24:4pi]

f(t, b, c, d) = 2sin(t * π)

pg = offsetpoly(spine, startoffset=1, endoffset=10, easingfunction=f)
sethue(&quot;black&quot;)
poly(pg, action = :fill)

sethue(&quot;white&quot;)
poly(spine, action = :stroke)</code></pre><p><img src="../../assets/figures/polyoffset-easing1.png" alt="offset poly easing 1"/></p><h4 id="3:-Applying-a-function"><a class="docs-heading-anchor" href="#3:-Applying-a-function">3: Applying a function</a><a id="3:-Applying-a-function-1"></a><a class="docs-heading-anchor-permalink" href="#3:-Applying-a-function" title="Permalink"></a></h4><p>This method generates offset widths using the supplied function. The value of the supplied function <code>f</code> at <code>f(0, θ)</code> determines the start offset on each side, and <code>f(1, θ)</code> determines the finishing offset on each side. The width at the middle vertex will be <code>f(0.5, θ)</code> (on each side). <code>θ</code> is provided as the current slope of the polyline at that point.</p><p>This example uses a simple sine curve in <code>f()</code> to vary the width of the spiral from beginning to end.</p><pre><code class="language-julia hljs">f(x, θ) =  10 + 40sin(x * π)

@drawsvg begin # hide

spine = spiral(30, 1.3, vertices=true)
ps = polysample(spine, 250, include_first=true, closed=false)
pgon = offsetpoly(ps, f)
poly(pgon, action = :stroke)

setmesh(mesh(box(BoundingBox(pgon)),
    [
    RGB(Luxor.julia_red...),
    RGB(Luxor.julia_blue...),
    RGB(Luxor.julia_green...),
    RGB(Luxor.julia_purple...),
    ]))
poly(pgon, action = :fill)</code></pre><img src="ad18d67f.svg" alt="Example block output"/><h3 id="Fitting-splines"><a class="docs-heading-anchor" href="#Fitting-splines">Fitting splines</a><a id="Fitting-splines-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-splines" title="Permalink"></a></h3><p>The experimental <a href="../../reference/api/#Luxor.polyfit"><code>polyfit</code></a> function constructs a B-spline that follows the points approximately.</p><pre><code class="language-julia hljs">pts = [Point(x, rand(-100:100)) for x in -280:30:280]
setopacity(0.7)
sethue(&quot;red&quot;)
prettypoly(pts, () -&gt; circle(O, 5, action = :fill))
sethue(&quot;darkmagenta&quot;)
poly(polyfit(pts, 200), action = :stroke)</code></pre><p><img src="../../assets/figures/polyfit.png" alt="offset poly"/></p><h2 id="Converting-paths-to-polygons"><a class="docs-heading-anchor" href="#Converting-paths-to-polygons">Converting paths to polygons</a><a id="Converting-paths-to-polygons-1"></a><a class="docs-heading-anchor-permalink" href="#Converting-paths-to-polygons" title="Permalink"></a></h2><p>You can convert the current path to an array of polygons, using <a href="../../reference/api/#Luxor.pathtopoly-Tuple{}"><code>pathtopoly</code></a>.</p><p>In the next example, the path consists of a number of paths, some of which are subpaths, which form the holes.</p><pre><code class="language-julia hljs">textpath(&quot;get polygons from paths&quot;)
plist = pathtopoly()
for (n, pgon) in enumerate(plist)
    randomhue()
    prettypoly(pgon, action = :stroke, close=true)
    gsave()
    translate(0, 100)
    poly(polysortbyangle(pgon, polycentroid(pgon)), action = :stroke, close=true)
    grestore()
end</code></pre><p><img src="../../assets/figures/path-to-poly.png" alt="path to polygon"/></p><p>The <a href="../../reference/api/#Luxor.pathtopoly-Tuple{}"><code>pathtopoly</code></a> function calls <a href="../../reference/api/#Luxor.getpathflat-Tuple{}"><code>getpathflat</code></a> to convert the current path to an array of polygons, with each curved section flattened to line segments.</p><p>The <a href="../../reference/api/#Luxor.getpath-Tuple{}"><code>getpath</code></a> function gets the current path as an array of elements, lines, and unflattened curves.</p><h2 id="Bezigons"><a class="docs-heading-anchor" href="#Bezigons">Bezigons</a><a id="Bezigons-1"></a><a class="docs-heading-anchor-permalink" href="#Bezigons" title="Permalink"></a></h2><p>A bezigon is like a polygon, but the sides can be Bézier paths instead of straight lines. Supply the corners and sides to the <a href="../../reference/api/#Luxor.bezigon-Tuple{Vector{Point}, Any}"><code>bezigon</code></a> function.</p><pre><code class="language-julia hljs">corners = [Point(10, 0), Point(200, 0)]
sides = [
    [Point(70, -40), Point(150, -50)],
    [Point(150, 50), Point(70, 40)],
]
for i in 1:10
    sethue(HSV(36i, .7, .7))
    rotate(2π / 10)
    bezigon(corners, sides, :fill)
end
sethue(&quot;white&quot;)
circle.([corners..., sides[1]..., sides[2]...], 7, :fill)</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="600pt" height="400pt" viewBox="0 0 600 400" version="1.1">
<g id="surface1028">
<rect x="0" y="0" width="600" height="400" style="fill:rgb(10.196078%25,10.196078%25,10.196078%25);fill-opacity:1;stroke:none;"/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(70%25,50.4%25,21%25);fill-opacity:1;" d="M 308.089844 205.878906 C 380.144531 208.785156 450.742188 247.71875 461.804688 317.558594 C 391.964844 328.617188 333.121094 273.503906 308.089844 205.878906 "/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(60.2%25,70%25,21%25);fill-opacity:1;" d="M 303.089844 209.511719 C 359.671875 254.214844 393.90625 327.207031 361.804688 390.210938 C 298.800781 358.109375 283.589844 278.933594 303.089844 209.511719 "/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(30.8%25,70%25,21%25);fill-opacity:1;" d="M 296.910156 209.511719 C 316.410156 278.933594 301.199219 358.109375 238.195312 390.210938 C 206.09375 327.207031 240.328125 254.214844 296.910156 209.511719 "/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(21%25,70%25,40.6%25);fill-opacity:1;" d="M 291.910156 205.878906 C 266.878906 273.503906 208.035156 328.617188 138.195312 317.558594 C 149.257812 247.71875 219.855469 208.785156 291.910156 205.878906 "/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(21%25,70%25,70%25);fill-opacity:1;" d="M 290 200 C 230 240 150 250 100 200 C 150 150 230 160 290 200 "/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(21%25,40.6%25,70%25);fill-opacity:1;" d="M 291.910156 194.121094 C 219.855469 191.214844 149.257812 152.28125 138.195312 82.441406 C 208.035156 71.382812 266.878906 126.496094 291.910156 194.121094 "/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(30.8%25,21%25,70%25);fill-opacity:1;" d="M 296.910156 190.488281 C 240.328125 145.785156 206.09375 72.792969 238.195312 9.789062 C 301.199219 41.890625 316.410156 121.066406 296.910156 190.488281 "/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(60.2%25,21%25,70%25);fill-opacity:1;" d="M 303.089844 190.488281 C 283.589844 121.066406 298.800781 41.890625 361.804688 9.789062 C 393.90625 72.792969 359.671875 145.785156 303.089844 190.488281 "/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(70%25,21%25,50.4%25);fill-opacity:1;" d="M 308.089844 194.121094 C 333.121094 126.496094 391.964844 71.382812 461.804688 82.441406 C 450.742188 152.28125 380.144531 191.214844 308.089844 194.121094 "/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(70%25,21%25,21%25);fill-opacity:1;" d="M 310 200 C 370 160 450 150 500 200 C 450 250 370 240 310 200 "/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(100%25,100%25,100%25);fill-opacity:1;" d="M 317 200 C 317 203.867188 313.867188 207 310 207 C 306.132812 207 303 203.867188 303 200 C 303 196.132812 306.132812 193 310 193 C 313.867188 193 317 196.132812 317 200 Z M 317 200 "/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(100%25,100%25,100%25);fill-opacity:1;" d="M 507 200 C 507 203.867188 503.867188 207 500 207 C 496.132812 207 493 203.867188 493 200 C 493 196.132812 496.132812 193 500 193 C 503.867188 193 507 196.132812 507 200 Z M 507 200 "/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(100%25,100%25,100%25);fill-opacity:1;" d="M 377 160 C 377 163.867188 373.867188 167 370 167 C 366.132812 167 363 163.867188 363 160 C 363 156.132812 366.132812 153 370 153 C 373.867188 153 377 156.132812 377 160 Z M 377 160 "/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(100%25,100%25,100%25);fill-opacity:1;" d="M 457 150 C 457 153.867188 453.867188 157 450 157 C 446.132812 157 443 153.867188 443 150 C 443 146.132812 446.132812 143 450 143 C 453.867188 143 457 146.132812 457 150 Z M 457 150 "/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(100%25,100%25,100%25);fill-opacity:1;" d="M 457 250 C 457 253.867188 453.867188 257 450 257 C 446.132812 257 443 253.867188 443 250 C 443 246.132812 446.132812 243 450 243 C 453.867188 243 457 246.132812 457 250 Z M 457 250 "/>
<path style=" stroke:none;fill-rule:nonzero;fill:rgb(100%25,100%25,100%25);fill-opacity:1;" d="M 377 240 C 377 243.867188 373.867188 247 370 247 C 366.132812 247 363 243.867188 363 240 C 363 236.132812 366.132812 233 370 233 C 373.867188 233 377 236.132812 377 240 Z M 377 240 "/>
</g>
</svg>
'/><h2 id="Polygons-to-Bézier-paths-and-back-again"><a class="docs-heading-anchor" href="#Polygons-to-Bézier-paths-and-back-again">Polygons to Bézier paths and back again</a><a id="Polygons-to-Bézier-paths-and-back-again-1"></a><a class="docs-heading-anchor-permalink" href="#Polygons-to-Bézier-paths-and-back-again" title="Permalink"></a></h2><p>Use the <a href="../../reference/api/#Luxor.makebezierpath-Tuple{Vector{Point}}"><code>makebezierpath</code></a> and <a href="../../reference/api/#Luxor.drawbezierpath-Tuple{BezierPath, Any}"><code>drawbezierpath</code></a> functions to make and draw Bézier paths, and <a href="../../reference/api/#Luxor.pathtobezierpaths-Tuple{}"><code>pathtobezierpaths</code></a> to convert the current path to an array of Bézier paths.  </p><p>A BezierPath type contains a sequence of <code>BezierPathSegment</code>s; each curve segment is defined by four points: two end points and their control points.</p><pre><code class="language-julia hljs">    (Point(-129.904, 75.0),        # start point
     Point(-162.38, 18.75),        # ^ control point
     Point(-64.9519, -150.0),      # v control point
     Point(-2.75546e-14, -150.0)), # end point
    (Point(-2.75546e-14, -150.0),
     Point(64.9519, -150.0),
     Point(162.38, 18.75),
     Point(129.904, 75.0)),
    (Point(129.904, 75.0),
     Point(97.4279, 131.25),
     Point(-97.4279, 131.25),
     Point(-129.904, 75.0)
     ),
     ...</code></pre><p>Bézier paths are different from ordinary paths in that they don&#39;t usually contain straight line segments. However, by setting the two control points to be the same as their matching start/end points, you create straight line sections.</p><p><a href="../../reference/api/#Luxor.makebezierpath-Tuple{Vector{Point}}"><code>makebezierpath</code></a> takes the points in a polygon and converts each line segment into one Bézier curve. <a href="../../reference/api/#Luxor.drawbezierpath-Tuple{BezierPath, Any}"><code>drawbezierpath</code></a> draws the resulting sequence.</p><pre><code class="language-julia hljs">pts = ngon(O, 150, 3, pi/6, vertices=true)
bezpath = makebezierpath(pts)
poly(pts, action = :stroke)
for (p1, c1, c2, p2) in bezpath[1:end-1]
    circle.([p1, p2], 4, action = :stroke)
    circle.([c1, c2], 2, action = :fill)
    line(p1, c1, action = :stroke)
    line(p2, c2, action = :stroke)
end
sethue(&quot;black&quot;)
setline(3)
drawbezierpath(bezpath, action = :stroke, close=false)</code></pre><p><img src="../../assets/figures/abezierpath.png" alt="path to polygon"/></p><pre><code class="language-julia hljs">tiles = Tiler(600, 300, 1, 4, margin=20)
for (pos, n) in tiles
    @layer begin
        translate(pos)
        pts = polysortbyangle(
                randompointarray(
                    Point(-tiles.tilewidth/2, -tiles.tilewidth/2),
                    Point(tiles.tilewidth/2, tiles.tilewidth/2),
                    4))
        setopacity(0.7)
        sethue(&quot;black&quot;)
        prettypoly(pts, action = :stroke, close=true)
        randomhue()
        drawbezierpath(makebezierpath(pts), action = :fill)
    end
end</code></pre><p><img src="../../assets/figures/bezierpaths.png" alt="path to polygon"/></p><p>You can convert a Bézier path to a polygon (an array of points), using the <a href="../../reference/api/#Luxor.bezierpathtopoly-Tuple{BezierPath}"><code>bezierpathtopoly</code></a> function. This chops up the curves into a series of straight line segments. An optional <code>steps</code> keyword lets you specify how many line segments are used to approximate each Bézier segment.</p><p>In this example, the original star is drawn in a dotted gray line, then converted to a Bézier path (drawn in orange), then the Bézier path is converted (with low resolution) to a polygon but offset by 20 units before being drawn (in blue).</p><pre><code class="language-julia hljs">pgon = star(O, 250, 5, 0.6, 0, vertices=true)

@layer begin
    setgrey(0.5)
    setdash(&quot;dot&quot;)
    poly(pgon, action = :stroke, close=true)
    setline(5)
end

setline(4)

sethue(&quot;orangered&quot;)

np = makebezierpath(pgon)
drawbezierpath(np, action = :stroke)

sethue(&quot;steelblue&quot;)
p = bezierpathtopoly(np, steps=3)

q1 = offsetpoly(p, 20)
prettypoly(q1, action = :stroke, close=true)</code></pre><p><img src="../../assets/figures/bezierpathtopoly.png" alt="path to polygon"/></p><p>You can convert the current path to an array of BezierPaths using the <a href="../../reference/api/#Luxor.pathtobezierpaths-Tuple{}"><code>pathtobezierpaths</code></a> function.</p><p>In the next example, the letter &quot;a&quot; is placed at the current position (set by <a href="../../reference/api/#Luxor.move-Tuple{Any, Any}"><code>move</code></a>) and then converted to an array of Bézier paths. Each Bézier path is drawn first of all in gray, then the control points of segment are drawn (in orange) showing how they affect the curvature.</p><pre><code class="language-julia hljs">st = &quot;a&quot;
thefontsize = 500
fontsize(thefontsize)
sethue(&quot;red&quot;)
tex = textextents(st)
move(-tex[3]/2, tex[4]/2)
textpath(st)
nbps = pathtobezierpaths()
setline(1.5)
for nbp in nbps
    sethue(&quot;grey80&quot;)
    drawbezierpath(nbp, action = :stroke)
    for p in nbp
        sethue(&quot;darkorange&quot;)
        circle(p[2], 2.0, action = :fill)
        circle(p[3], 2.0, action = :fill)
        line(p[2], p[1], action = :stroke)
        line(p[3], p[4], action = :stroke)
        if p[1] != p[4]
            sethue(&quot;black&quot;)
            circle(p[1], 2.0, action = :fill)
            circle(p[4], 2.0, action = :fill)
        end
    end
end</code></pre><p><img src="../../assets/figures/pathtobezierpaths.png" alt="path to polygon"/></p><p><a href="../../reference/api/#Luxor.beziersegmentangles-Tuple{Any, Any}"><code>beziersegmentangles</code></a> lets you define a Bézier path segment by specifying the angles the control handles make with the base line.</p><pre><code class="language-julia hljs">setline(.5)

@layer begin
    rule.(O, (0, (π/2)))
end

P = O
Q = O + (200, 0)
sethue(&quot;black&quot;)

pts = beziersegmentangles(P, Q,
    out = deg2rad(60),
    in  = 2π - deg2rad(45))

@layer begin
    setline(2)
    sethue(&quot;purple&quot;)
    drawbezierpath(pts, action = :stroke)
end

sethue(&quot;grey50&quot;)
line(O, pts[2], action = :stroke)
line(Q, pts[3], action = :stroke)
fontsize(15)
circle.((P, pts[2], pts[3], Q), 5, action = :fill)
label.((&quot;P&quot;, &quot;Q&quot;), :ne, (P, Q))
text(&quot;60°&quot;, P + (40, 20))
text(&quot;135°&quot;, Q + (10, 20))</code></pre><p><img src="../../assets/figures/beziersegmentangles.svg" alt="bezier segment angles"/></p><p>There are some functions that can modify Bezier path segments. For example, <a href="../../reference/api/#Luxor.trimbezier-Tuple{BezierPathSegment, Any, Any}"><code>trimbezier</code></a> chops portions off each end:</p><pre><code class="language-julia hljs">setline(2)

bez  = BezierPathSegment(ngon(O, 150, 4, vertices=true)...)
drawbezierpath(bez, action = :stroke)

setopacity(0.4)
sethue(&quot;red&quot;)
setline(20)
trimbez = trimbezier(bez, 0.2, 0.8)
drawbezierpath(trimbez, action = :stroke)

setline(40)
sethue(&quot;purple&quot;)
trimbez = trimbezier(trimbez, 0.2, 0.8)
drawbezierpath(trimbez, action = :stroke)</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="600pt" height="400pt" viewBox="0 0 600 400" version="1.1">
<g id="surface1042">
<rect x="0" y="0" width="600" height="400" style="fill:rgb(100%25,100%25,94.117647%25);fill-opacity:1;stroke:none;"/>
<path style="fill:none;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(0%25,0%25,0%25);stroke-opacity:1;stroke-miterlimit:10;" d="M 300 350 C 150 200 300 50 450 200 "/>
<path style="fill:none;stroke-width:20;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(100%25,0%25,0%25);stroke-opacity:0.4;stroke-miterlimit:10;" d="M 243.601562 262.398438 C 216.71875 174.078125 288.144531 110.335938 379.230469 149.8125 "/>
<path style="fill:none;stroke-width:40;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(50.196078%25,0%25,50.196078%25);stroke-opacity:0.4;stroke-miterlimit:10;" d="M 238.640625 212.984375 C 244.589844 164.765625 284.359375 133.054688 337.339844 138.46875 "/>
</g>
</svg>
'/><p>When working with Bézier curves it&#39;s usual to consider the curve in terms of a parameter <code>t</code> going from 0.0 to 1.0.  </p><p><a href="../../reference/api/#Luxor.splitbezier-Tuple{BezierPathSegment, Any}"><code>splitbezier</code></a> can split a segment into two shorter segments.</p><h2 id="Brush-strokes"><a class="docs-heading-anchor" href="#Brush-strokes">Brush strokes</a><a id="Brush-strokes-1"></a><a class="docs-heading-anchor-permalink" href="#Brush-strokes" title="Permalink"></a></h2><p>The <a href="../../reference/api/#Luxor.brush"><code>brush</code></a> function builds Bezier paths in a quasi-random fashion, that could look like brush strokes. The optional keyword arguments allow a range of different effects.</p><p>You can pass a function that can adjust various drawing settings before the shapes are drawn.</p><pre><code class="language-julia hljs">brushα(nbpb) = begin
    setline(1)
    setopacity(0.3)
    drawbezierpath(nbpb, action = :stroke)
    sethue(0.2, 0.3, rand(0.3:0.01:0.65))
    return nbpb
end

function numberit(pos, n)
    @layer begin
        sethue(&quot;black&quot;)
        text(string(n), pos)
    end
end

t  = Tiler(800, 700, 5, 1)
sethue(&quot;orange3&quot;)
fontsize(20)
for (pos, n) in t
    start, finish = pos - (200, 0), pos + (200, 0)
    if n == 1
        # five brush strokes
        brush(start, finish, 1)
        numberit(pos, n)
    elseif n == 2
        # minwidth and maxwidth control the, er, width
         brush(start, finish, 5, minwidth = -5, maxwidth = 2)
         numberit(pos, n)
    elseif n == 3
        # dont have to have transparent strokes
         brush(start, finish, 20, minwidth = .2, randomopacity = false)
         numberit(pos, n)
    elseif n == 4
        # twist and adjust handles to taste
         brush(start, finish, minwidth = -.1, maxwidth = .2,
             twist = 2, highhandle = 2, tidystart=false)
         numberit(pos, n)
    elseif n == 5
        # call a function to modify each stroke
        brush(start, finish, 1, minwidth = -2.2, maxwidth = .8,
            lowhandle = -.4, highhandle = 1.5, twist = .5,
            strokefunction = brushα)
        numberit(pos, n)
    end
end</code></pre><p><img src="../../assets/figures/brush1.png" alt="brush 1"/></p><p>For more information (and more than you probably wanted to know) about Luxor&#39;s Bézier paths, visit <a href="https://cormullion.github.io/pages/2018-06-20-bezier/">https://cormullion.github.io/pages/2018-06-20-bezier/</a>.</p><h2 id="Polygon-information"><a class="docs-heading-anchor" href="#Polygon-information">Polygon information</a><a id="Polygon-information-1"></a><a class="docs-heading-anchor-permalink" href="#Polygon-information" title="Permalink"></a></h2><p><code>polyperimeter</code> calculates the length of a polygon&#39;s perimeter.</p><pre><code class="language-julia hljs">p = box(O, 50, 50, vertices=true)
poly(p, action = :stroke)
text(string(round(polyperimeter(p, closed=false))), O.x, O.y + 60)

translate(200, 0)

poly(p, action = :stroke, close=true)
text(string(round(polyperimeter(p, closed=true))), O.x, O.y + 60)</code></pre><p><img src="../../assets/figures/polyperimeter.png" alt="polyperimeter"/></p><p>To find the &quot;left-most&quot; point, ie the point with the lowest x coordinate, you can use built-in <code>extrema()</code> function, to return the left-most and right-most points. (This is because, when you compare points, the x coordinate is tested first.) To find the &quot;lowest&quot; points, ie the points with the lowest y value, you could find the y extrema and use it to find the index:</p><pre><code class="language-julia hljs">findfirst(pt -&gt; isequal(pt.y, first(extrema(pt -&gt; pt.y, pts))), pts)
# 13</code></pre><h3 id="Point-inside-polygon"><a class="docs-heading-anchor" href="#Point-inside-polygon">Point inside polygon</a><a id="Point-inside-polygon-1"></a><a class="docs-heading-anchor-permalink" href="#Point-inside-polygon" title="Permalink"></a></h3><p>The <a href="../../reference/api/#Luxor.isinside-Tuple{Point, BoundingBox}"><code>isinside</code></a> function returns true if a point is inside a polygon.</p><pre><code class="language-julia hljs">apolygon = star(O, 200, 8, 0.5, 0, vertices=true)
for pt in collect(first.(Table(30, 30, 15, 15)))
    sethue(noise(pt.x/600, pt.y/600), noise(pt.x/300, pt.y/300), noise(pt.x/250, pt.y/250))
    isinside(pt, apolygon, allowonedge=true) ?
        circle(pt, 8, action = :fill) : circle(pt, 3, action = :fill)
end</code></pre><p><img src="../../assets/figures/isinside.png" alt="isinside"/></p><h3 id="Convex-hull"><a class="docs-heading-anchor" href="#Convex-hull">Convex hull</a><a id="Convex-hull-1"></a><a class="docs-heading-anchor-permalink" href="#Convex-hull" title="Permalink"></a></h3><p>A convex hull of a polygon is the subset of points such that, when connected with straight lines, the resulting shape contains every point of the polygon.</p><p>Use <a href="../../reference/api/#Luxor.polyhull-Tuple{Vector{Point}}"><code>polyhull</code></a> to find the convex hull of an array of points. </p><p>This code obtains all the points in the Julia logo&#39;s circles, combines them into a single array, and then calculates the convex hull that encloses them all.</p><pre><code class="language-julia hljs">setline(4)

juliacircles(130) # draw in color

# get all the points
juliacircles(130, action=:path)
points = collect(Iterators.flatten(vcat(pathtopoly())))

hull = polyhull(points)

sethue(&quot;gold2&quot;)

prettypoly(hull, close=true, action = :stroke)</code></pre><img src="d7b66a81.svg" alt="Example block output"/><h2 id="Polygon-selection-and-modification"><a class="docs-heading-anchor" href="#Polygon-selection-and-modification">Polygon selection and modification</a><a id="Polygon-selection-and-modification-1"></a><a class="docs-heading-anchor-permalink" href="#Polygon-selection-and-modification" title="Permalink"></a></h2><p>There are Luxor functions to return the first part or last part of a polygon. You can also ask for a resampling of a polygon, choosing either to increase the number of points (which places new points to the &quot;lines&quot; joining the vertices) or decrease them (which changes the shape of the polygon). It&#39;s also possible to insert vertices automatically.</p><p><a href="../../reference/api/#Luxor.polyportion"><code>polyportion</code></a> and <a href="../../reference/api/#Luxor.polyremainder"><code>polyremainder</code></a> return part of a polygon depending on the fraction you supply. For example, <code>polyportion(p, 0.5)</code> returns the first half of polygon <code>p</code>, <code>polyremainder(p, .75)</code> returns the last quarter of it.</p><pre><code class="language-julia hljs">p = ngon(O, 100, 7, 0, vertices=true)
poly(p, action = :stroke, close=true)
setopacity(0.75)

setline(20)
sethue(&quot;red&quot;)
poly(polyportion(p, 0.25), action = :stroke)

setline(10)
sethue(&quot;green&quot;)
poly(polyportion(p, 0.5), action = :stroke)

setline(5)
sethue(&quot;blue&quot;)
poly(polyportion(p, 0.75), action = :stroke)

setline(1)
circle(polyremainder(p, 0.75)[1], 5, action = :stroke) # first point</code></pre><p><img src="../../assets/figures/polyportion.png" alt="polyportion"/></p><p>You can insert vertices in the edges of a polygon with <a href="../../reference/api/#Luxor.insertvertices!-Tuple{Any}"><code>insertvertices!</code></a>. For example, this code inserts a new vertex into each side of a polygon five times. The polygon ends up with 128 vertices.</p><pre><code class="language-julia hljs">pts = box(O, 500, 200, vertices=true)
prettypoly(pts, action = :stroke, close=true)

for i in 1:5
    insertvertices!(pts)
    prettypoly(pts, action = :stroke, close=true)
    fontsize(16)
    label(string(length(pts)), :ne, pts[1], offset=10)
    scale(0.8)
end</code></pre><p><img src="../../assets/figures/insertvertices.png" alt="poly insert vertices"/></p><p>To resample a polygon, use <a href="../../reference/api/#Luxor.polysample-Tuple{Vector{Point}, Integer}"><code>polysample</code></a>. In this example, the same four-sided polygon is resampled at multiples of 4, with different circle radii at each multiple. This adds more points to the new copy of the original polygon.</p><pre><code class="language-julia hljs">pts = ngon(O, 100, 4, vertices=true)
for (n, npoints) in enumerate(reverse([4, 8, 16, 32, 48]))
    prettypoly(polysample(pts, npoints),
        :stroke, close=true,
        () -&gt; begin
                circle(O, 2n, action = :stroke)
              end)
end</code></pre><p><img src="../../assets/figures/polysample.png" alt="polysampling"/></p><p>There is a <code>closed</code> option, which determines whether or not the final edge (the one that would join the final vertex to the first), is included in the sampling. In the following example, the original polygon is drawn in black, then sampled as a closed polygon (in blue), then as a non-closed one (magenta).</p><pre><code class="language-julia hljs"># original polygon

numbervertices(l, n) = label(string(l), :N, O)
drawvertices() = ngon(O, 3, 4, 0, action = :fill)

pts = [Point(30x, 20sin(x)) for x in -2π:π/6:2π]

# 1: drawn as defined

prettypoly(pts, action = :stroke, drawvertices, vertexlabels = numbervertices)

translate(0, 50)


# 2: resampled as closed

npoints = 40

sethue(&quot;cornflowerblue&quot;)
prettypoly(polysample(pts, npoints, closed=true), action = :stroke, drawvertices,
    vertexlabels = numbervertices)

translate(0, 50)

# 3: resampled as open

sethue(&quot;magenta&quot;)
prettypoly(polysample(pts, npoints, closed=false), action = :stroke, drawvertices,
    vertexlabels = numbervertices)</code></pre><p><img src="../../assets/figures/polysample2.png" alt="polysampling 2"/></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In Luxor, you&#39;ll meet <code>close</code> and <code>closed</code> options. <code>close</code> is an instruction to path-drawing functions, that says &quot;join the most recent point to the first point&quot;. Whereas, <code>closed</code> is an indication that the polygons or paths should be treated as being closed rather than open, ie whether that last segment joining the end point to the first is used for calculations.</p></div></div><h3 id="Polygon-side-lengths"><a class="docs-heading-anchor" href="#Polygon-side-lengths">Polygon side lengths</a><a id="Polygon-side-lengths-1"></a><a class="docs-heading-anchor-permalink" href="#Polygon-side-lengths" title="Permalink"></a></h3><p><code>polydistances</code> returns an array of the accumulated side lengths of a polygon.</p><pre><code class="nohighlight hljs">julia&gt; p = ngon(O, 100, 7, 0, vertices=true);
julia&gt; polydistances(p)
8-element Array{Real,1}:
   0.0000
  86.7767
 173.553
 260.33
 347.107
 433.884
 520.66
 607.437</code></pre><p>It&#39;s used by <a href="../../reference/api/#Luxor.polyportion"><code>polyportion</code></a> and <a href="../../reference/api/#Luxor.polyremainder"><code>polyremainder</code></a>, and you can pre-calculate and pass them to these functions via keyword arguments for performance. By default the result includes the final closing segment (<code>closed=true</code>).</p><p>These functions also make use of the <a href="../../reference/api/#Luxor.nearestindex-Tuple{Vector{Float64}, Any}"><code>nearestindex</code></a>, which returns a tuple of: the index of the nearest value in an array of distances to a given value; and the excess value.</p><p>In this example, we want to find a point halfway round the perimeter of a triangle. Use <a href="../../reference/api/#Luxor.nearestindex-Tuple{Vector{Float64}, Any}"><code>nearestindex</code></a> to find the index of the nearest vertex (<code>nidx</code>, 2), and the surplus length, (<code>over</code>, 100).</p><pre><code class="language-julia hljs">p = ngonside(O, 200, 3, vertices=true)
prettypoly(p, action = :stroke, close=true, vertexlabels = (n, l) -&gt; label(string(n), :NW, offset=10))

# distances array
da = polydistances(p)

nidx, over = nearestindex(da, polyperimeter(p)/2)

sethue(&quot;red&quot;)
circle(p[nidx], 5, action = :stroke)

arrow(p[nidx],
      between(p[nidx], p[nidx+1], over/distance(p[nidx], p[nidx+1])),
      linewidth=2)</code></pre><p><img src="../../assets/figures/nearestindex.png" alt="nearestindex"/></p><p>Of course, it&#39;s much easier to do <code>polyportion(p, 0.5)</code>.</p><h3 id="Area-of-polygon"><a class="docs-heading-anchor" href="#Area-of-polygon">Area of polygon</a><a id="Area-of-polygon-1"></a><a class="docs-heading-anchor-permalink" href="#Area-of-polygon" title="Permalink"></a></h3><p>Use <a href="../../reference/api/#Luxor.polyarea-Tuple{Vector{Point}}"><code>polyarea</code></a> to find the area of a polygon. Of course, this only works for simple polygons; polygons that intersect themselves or have holes are not correctly processed.</p><p>This code draws some regular polygons and calculates their area, perimeter, and shows how near the ratio of perimeter over radius approaches 2π.</p><pre><code class="language-julia hljs">fontface(&quot;Georgia&quot;)
sethue(&quot;black&quot;)
setline(0.25)
outerframe = Table([500], [400, 200])
total = 30
properties = Table(fill(15, total), [20, 85, 85], outerframe[1, 2])
radius = 55
sethue(&quot;grey20&quot;)
for i in 3:total
    global radius
    text(string(i), properties[i, 1], halign=:right)
    p = ngon(outerframe[1], radius, i, 0, vertices=true)
    prettypoly(p, action = :stroke, close=true, () -&gt; (sethue(&quot;red&quot;); circle(O, 2, action = :fill)))
    pa = polyarea(p)
    pp = polyperimeter(p)
    ppoverradius = pp/radius
    text(string(Int(round(pa, digits=0))), properties[i, 2], halign=:left)
    text(string(round(ppoverradius, digits=6)), properties[i, 3], halign=:left)
    radius += 5
end

fontsize(10)
[text([&quot;Sides&quot;, &quot;Area&quot;, &quot;Perimeter/Radius&quot;][n], pt, halign=:center)
    for (pt, n) in Table([20], [20, 85, 85], outerframe[2] - (0, 220))]</code></pre><p><img src="../../assets/figures/polyarea.png" alt="poly area"/></p><h2 id="Morphing-polygons"><a class="docs-heading-anchor" href="#Morphing-polygons">Morphing polygons</a><a id="Morphing-polygons-1"></a><a class="docs-heading-anchor-permalink" href="#Morphing-polygons" title="Permalink"></a></h2><p>&quot;morph&quot; means to make one thing turn into another. The experimental <a href="../../reference/api/#Luxor.polymorph-Tuple{Array{Vector{Point}}, Array{Vector{Point}}, Any}"><code>polymorph</code></a> function can gradually turn one polygon into another.</p><p>You supply two polygons and a value between 0 and 1. For example, if the value is 0.5, the shape is about halfway between the two polygons.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>polymorph()</code> always returns an array of polygons. Arguments can be arrays of polygons, or single polygons.</p></div></div><p>By default, the polygons are assumed to be closed, suitable for filling.</p><pre><code class="language-julia hljs">fromshape = ngon(O, 50, 4, vertices=true)
toshape = ngon(O, 350, 4, π/4, vertices=true)

setline(8)
for i in range(0, 1, length=10)
    @show i
    sethue(HSB(360i, 0.8, 0.8))
    morph = polymorph(fromshape, toshape, i)
    for p in morph
        poly(p, close=true, action=:stroke)
    end
end</code></pre><img src="cb761ac9.svg" alt="Example block output"/><p>In the next example, each of the two wavy-line polygons are open rather than closed, so you can pass <code>false</code> values to the <code>closed</code> argument, and the polygons won&#39;t be treated as closed shapes.</p><pre><code class="language-julia hljs">rotate(π/2)
fromshape  = [Point(90x, -230 + 50sin(3x)) for x in range(-π, π, length=250)]
toshape  = [Point(90x, 230 + 50sin(-3x)) for x in range(-π, π, length=250)]
for i in 0:0.03:1
    sethue(1 - i, i/4 + 0.2, 1 - i/4)
    morph = polymorph(fromshape, toshape, i,
        easingfunction=easeinoutcubic,
        closed=(false, false))
    poly(first(morph), action = :stroke)
end</code></pre><img src="c2161828.svg" alt="Example block output"/><p>Sometimes polygons consist of two or more loops - this is how holes work. So <code>polymorph()</code> accepts both simple polygons and arrays of polygons, but always returns an array of polygons.</p><p><code>polymorph()</code> accepts easing functions that determine the &#39;speed&#39; and &#39;acceleration&#39; of the changes. These are the same functions that are described in more detail in the Animation section, <a href="../animation/#Easing-functions">Easing-functions</a>. In the previous example, the <code>easeinoutcubic</code> function made the earlier and later changes small (lines closer together), but the changes at the middle of the morph were larger.</p><p>Here are all the easing functions used to <code>polymorph()</code> between two polygons:</p><pre><code class="language-julia hljs">background(&quot;grey10&quot;)
setline(1)
w, h = 450, 20
a = [[Point(-w / 2, -h / 2), Point(-w / 2, 0), Point(-w / 2, h / 2)]]
b = [[Point(w / 2, -h / 2), Point(w / 2, 0), Point(w / 2, h / 2)]]
translate(boxtopcenter() + (50, 30))
for (i, ef) in enumerate(Luxor.easingfunctions)
    sethue(HSB(12i, .7, .8))
    for i in range(0, 1, length=20)
        pm = polymorph(a, b, i, easingfunction=ef)
        poly(pm[1], :stroke)
    end
    sethue(&quot;white&quot;)
    text(string(ef), Point(-w/2 - 20, 0), halign=:right, valign=:middle)
    translate(0, 22)
end</code></pre><img src="1aa160d6.svg" alt="Example block output"/><p>In the next example, <code>fromshape</code>, the circle, is an array holding a single vector of Points (<code>pathtopoly()</code> returns an array of polygons), and <code>toshape</code>, the line, is a simple vector of points (the minimum of three points). In this case, with just simple polygons, only the first element of the result of the <code>polymorph()</code> function is needed.</p><pre><code class="language-julia hljs">circlepath(O, 200, action = :path)
fromshape = pathtopoly()
toshape = [Point(0, -250), O, Point(0, 250)] # minimum of 3
for i in 0:0.015:1
    sethue(i, 1 - i, i/2 + 0.5)
    morph = polymorph(fromshape, toshape, i, easingfunction=easeinoutsine)
    poly(first(morph), action = :stroke, close=true)
end</code></pre><img src="ddc72101.svg" alt="Example block output"/><p>In the next example, a square morphs into a hexagon.</p><pre><code class="language-julia hljs">pgon1 = ngon(O, 80, 4,  vertices = true)
pgon2 = ngon(O, 270, 6, vertices = true)
sethue(&quot;cyan&quot;)
setline(1)
for i in 0:0.05:1.0
    sethue(i, 1 - i, 0.5)
    poly(first(polymorph(pgon1, pgon2, i)),
        action = :stroke,
        close = true)
end</code></pre><img src="f1294f8b.svg" alt="Example block output"/><p>In the next example, an octagon with a square hole morphs into a square with an octagonal hole.</p><pre><code class="language-julia hljs"># build first polygon
ngon(O + (-350, 0), 40, 8, π, action = :path)
newsubpath()
box(O + (-350, 0), 30, 30, reversepath=true, action = :path)
pgon1 = pathtopoly()

# build second polygon
newpath()
box(O + (350, 0), 60, 60, action = :path)
newsubpath()
ngon(O + (350, 0), 20, 8, π, reversepath=true, action = :path)
pgon2 = pathtopoly()

# draw morphs
sethue(&quot;cyan&quot;)
setline(1)
for i in 0:0.1:1.0
    sethue(i, 1 - i, 0.5)
    poly.(polymorph(pgon1, pgon2, i),
        action=:path,
        close=true)
    fillpath()
end</code></pre><img src="bdebb891.svg" alt="Example block output"/><p>Because both polygons have reversed subpaths (holes), the polygons should be drawn using <code>:path</code> and <code>fillpath()</code>.</p><p>The next example animates a morph between two programming languages.</p><pre><code class="language-julia hljs">using Luxor, Colors

function frame(scene, framenumber)
    background(&quot;grey10&quot;)

    fontface(&quot;JuliaMono&quot;)
    fontsize(120)

    textoutlines(&quot;&quot;, O + (0, 0), halign=:center, valign=:middle)
    python_logo = pathtopoly()

    textoutlines(&quot;&quot;, O + (0, 0), halign=:center, valign=:middle)
    julia_logo = pathtopoly()

    fontface(&quot;WorkSans-Black&quot;)
    fontsize(130)
    textoutlines(&quot;Python&quot;, O + (0, -100), halign=:center, valign=:middle, action = :path)
    fromtext = pathtopoly()

    textoutlines(&quot;Julia&quot;, O + (0, 100), halign=:center, valign=:middle, action = :path)
    totext   = pathtopoly()

    newpath()
    sethue(&quot;cyan&quot;)

    eased_n = scene.easingfunction(framenumber - scene.framerange.start,
      0, 1, scene.framerange.stop - scene.framerange.start)

    i = sin(eased_n * π)
    poly.(polymorph(fromtext, totext, i, easingfunction=easingflat, samples=200),
        action=:path,
        close=true)
    strokepath()

    pm = polymorph(python_logo, julia_logo, i)
    for p in pm
        poly(p, action = :path)
    end
    fillpath()
end

amovie = Movie(600, 400, &quot;p to j&quot;)
animate(amovie,
    Scene(amovie, frame, 1:200,
        easingfunction = easeinoutsine),
    creategif = true,
    pathname = &quot;/tmp/python-julia.gif&quot;)</code></pre><p><img src="../../assets/figures/python-julia.gif" alt="python julia animation"/></p><p>The &quot;Python&quot; path has 9 loops, whereas &quot;Julia&quot; has 8. The <code>polymorph()</code> function tries to work around this - notice how the ninth loop, &quot;n&quot;, morphs down to nothing. If you don&#39;t want this to happen, set the <code>kludge</code> keyword to false. In this particular case, you could increase the number of loops in <code>totext</code> to match by using a lower-case &quot;j&quot;.</p><h2 id="Other-polygon-operations"><a class="docs-heading-anchor" href="#Other-polygon-operations">Other polygon operations</a><a id="Other-polygon-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Other-polygon-operations" title="Permalink"></a></h2><p>These functions are still in development. Expect varying degrees of success when using them.</p><p><a href="../../reference/api/#Luxor.polyclip-Tuple{Vector{Point}, Vector{Point}}"><code>polyclip()</code></a> returns the region of a source polygon that lies inside a clipping polygon. In this example, each intersecting piece is created by clipping one of the &quot;circles&quot; with another (each circle is an 80-sided polygon).</p><pre><code class="language-julia hljs">using Luxor, Colors
@drawsvg begin
    background(&quot;grey10&quot;)

    npoints = 80
    D = 140
    pts = ngon(O, 110, 3, π / 6, vertices=true)

    circle1 = ngon(pts[1], D, npoints, vertices=true)
    circle2 = ngon(pts[2], D, npoints, vertices=true)
    circle3 = ngon(pts[3], D, npoints, vertices=true)

    sethue(&quot;cyan&quot;); poly(circle1, :fill)
    sethue(&quot;magenta&quot;); poly(circle2, :fill)
    sethue(&quot;yellow&quot;); poly(circle3, :fill)

    sethue(&quot;blue&quot;)
    pc1 = polyclip(circle1, circle2)
    poly(pc1, :fill, close=true)

    sethue(&quot;red&quot;)
    pc2 = polyclip(circle1, circle3)
    poly(pc2, :fill, close=true)

    sethue(&quot;green&quot;)
    pc3 = polyclip(circle2, circle3)
    poly(pc3, :fill, close=true)

    pc4 = polyclip(pc1, pc2) # or polyclip(pc1, pc3) ...

    sethue(&quot;white&quot;)
    poly(pc4, :fill, close=true)
end</code></pre><img src="de4f4a08.svg" alt="Example block output"/><h2 id="Polygon/line-Intersections"><a class="docs-heading-anchor" href="#Polygon/line-Intersections">Polygon/line Intersections</a><a id="Polygon/line-Intersections-1"></a><a class="docs-heading-anchor-permalink" href="#Polygon/line-Intersections" title="Permalink"></a></h2><p><code>intersectlinepoly(pt1, pt2, polygon)</code> returns an array containing the points where a line from <code>pt1</code> to <code>pt2</code> crosses the perimeter of the <code>polygon</code>.</p><pre><code class="language-julia hljs">setline(0.3)
sethue(&quot;thistle&quot;)
c = star(O, 120, 7, 0.2, vertices=true)
poly(c, action = :fillstroke, close=true)
for n in 1:15
    pt1 = Point(rand(-250:250, 2)...)
    pt2 = Point(rand(-250:250, 2)...)
    ips = intersectlinepoly(pt1, pt2, c)
    if !isempty(ips)
            sethue(&quot;grey20&quot;)
            line(pt1, pt2, action = :stroke)
            randomhue()
            circle.(ips, 2, action = :fill)
    else
        sethue(&quot;grey80&quot;)
        line(pt1, pt2, action = :stroke)
    end
end</code></pre><p><img src="../../assets/figures/linepolyintersections.png" alt="line/polygon intersections"/></p><h2 id="Polygon-intersections"><a class="docs-heading-anchor" href="#Polygon-intersections">Polygon intersections</a><a id="Polygon-intersections-1"></a><a class="docs-heading-anchor-permalink" href="#Polygon-intersections" title="Permalink"></a></h2><p>Use <a href="../../reference/api/#Luxor.polyintersect-Tuple{AbstractVector{Point}, AbstractVector{Point}}"><code>polyintersect()</code></a> to find the areas where two polygons intersect.</p><p>In the following illustration, the annular sector polygon and a varying rectangular polygon are passed to <code>polyintersect()</code>.</p><p>In each case, the returned result is an array of polygons. The number of polygons in the array depends on how the two polygons intersect - there could be anything from 0 to a lot. Then we iterate through the array, drawing each polygon in different colors. </p><pre><code class="language-julia hljs">@drawsvg begin
    background(&quot;grey10&quot;)

    tiles = Tiler(800, 300, 1, 3)

    for (pos, n) in tiles
        @layer begin
            translate(pos)

            sector(O, 50, 100, 0 + π / 8, 2π - π / 8, :path)
            pg1 = pathtopoly()[1]

            pg2 = box(O,
                    [250, 80, 250][n],
                    [120, 250, 80][n])

            setopacity(0.6)

            sethue(&quot;lightpink&quot;)
            poly(pg1, :fill)

            sethue(&quot;yellowgreen&quot;)
            poly(pg2, :fill)

            pintersection = polyintersect(pg1, pg2)

            for (i, p) in enumerate(pintersection)
                setcolor(HSB([0, 180, 310][i], 0.9, 0.9))
                poly(p, :fill)
                sethue(&quot;grey90&quot;)
                poly(p, :stroke, close=true)
            end
        end
    end
end 800 300</code></pre><img src="a75aead1.svg" alt="Example block output"/><p>In case there&#39;s no intersection, the returned result is empty: <code>Vector{Point}[]</code>.</p><p>The algorithm used is the <a href="https://liorsinai.github.io/mathematics/2023/09/30/polygon-clipping.html">Weiler-Atherton algorithm</a>.</p><h2 id="Triangulation"><a class="docs-heading-anchor" href="#Triangulation">Triangulation</a><a id="Triangulation-1"></a><a class="docs-heading-anchor-permalink" href="#Triangulation" title="Permalink"></a></h2><p>Use <a href="../../reference/api/#Luxor.polytriangulate-Tuple{Vector{Point}}"><code>polytriangulate</code></a> to join the vertices of a polygon to form triangles. It returns an array of triangular polygons.</p><pre><code class="language-julia hljs">pts = ngon(O, 200, 7, vertices=true)
triangles = polytriangulate(pts)

for (n, tri) in enumerate(triangles)
    sethue([Luxor.julia_purple,
            Luxor.julia_blue,
            Luxor.julia_red,
            Luxor.julia_green
            ][mod1(n, end)])
    poly(offsetpoly(tri, -2), action = :fill, close = true)
    sethue(&quot;white&quot;)
    text(string(n), polycentroid(tri), halign=:center)
end

sethue(&quot;red&quot;)
setline(3)
poly(pts, action = :stroke, close=true)</code></pre><p><img src="../../assets/figures/polytriangulate.png" alt="polygon triangulation"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../colors-styles/">« Use colors and styles</a><a class="docs-footer-nextpage" href="../text/">Add text »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Sunday 14 January 2024 10:15">Sunday 14 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
