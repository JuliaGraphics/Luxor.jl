<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Use geometry tools · Luxor</title><meta name="title" content="Use geometry tools · Luxor"/><meta property="og:title" content="Use geometry tools · Luxor"/><meta property="twitter:title" content="Use geometry tools · Luxor"/><meta name="description" content="Documentation for Luxor."/><meta property="og:description" content="Documentation for Luxor."/><meta property="twitter:description" content="Documentation for Luxor."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/luxor-docs.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Luxor logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Luxor</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction to Luxor</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorial/helloworld/">Hello World</a></li><li><a class="tocitem" href="../../tutorial/basicpath/">Basic path building</a></li><li><a class="tocitem" href="../../tutorial/quickstart/">Design a logo</a></li><li><a class="tocitem" href="../../tutorial/basictutorial/">Geometry tutorial</a></li><li><a class="tocitem" href="../../tutorial/pixels/">Playing with pixels</a></li><li><a class="tocitem" href="../../tutorial/simple-animation/">Simple animation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../example/examples/">Simple examples</a></li><li><a class="tocitem" href="../../example/moreexamples/">More examples</a></li><li><a class="tocitem" href="../../example/gallery/">Gallery</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">How to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../createdrawings/">Create drawings</a></li><li><a class="tocitem" href="../simplegraphics/">Draw simple shapes</a></li><li class="is-active"><a class="tocitem" href>Use geometry tools</a><ul class="internal"><li><a class="tocitem" href="#Lines-and-distances"><span>Lines and distances</span></a></li><li><a class="tocitem" href="#Points-and-arcs"><span>Points and arcs</span></a></li><li><a class="tocitem" href="#Triangle-centers"><span>Triangle centers</span></a></li><li><a class="tocitem" href="#Intersections"><span>Intersections</span></a></li><li><a class="tocitem" href="#Bounding-boxes"><span>Bounding boxes</span></a></li><li><a class="tocitem" href="#Random-points"><span>Random points</span></a></li><li><a class="tocitem" href="#Noise"><span>Noise</span></a></li></ul></li><li><a class="tocitem" href="../tables-grids/">Work with tables and grids</a></li><li><a class="tocitem" href="../colors-styles/">Use colors and styles</a></li><li><a class="tocitem" href="../polygons/">Work with polygons</a></li><li><a class="tocitem" href="../text/">Add text</a></li><li><a class="tocitem" href="../clipping/">Clip graphics</a></li><li><a class="tocitem" href="../images/">Placing images</a></li><li><a class="tocitem" href="../turtle/">Turtle graphics</a></li><li><a class="tocitem" href="../animation/">Make animations</a></li><li><a class="tocitem" href="../snapshots/">Snapshots</a></li><li><a class="tocitem" href="../livegraphics/">Interactive graphics and Threads</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Explanations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../explanation/basics/">Basic concepts</a></li><li><a class="tocitem" href="../../explanation/pathspolygons/">Paths vs Polygon</a></li><li><a class="tocitem" href="../../explanation/perfectpixels/">Perfect pixels and antialising</a></li><li><a class="tocitem" href="../../explanation/transforms/">Transforms and matrices</a></li><li><a class="tocitem" href="../../explanation/imagematrix/">Image matrix</a></li><li><a class="tocitem" href="../../explanation/fonts/">Fonts on Linux</a></li><li><a class="tocitem" href="../../explanation/luxorcairo/">Luxor and Cairo</a></li><li><a class="tocitem" href="../../explanation/strokepathdispatch/">Customize strokepath/fillpath</a></li><li><a class="tocitem" href="../../explanation/contributing/">Contributing</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/functionindex/">Alphabetical function list</a></li><li><a class="tocitem" href="../../reference/api/">Function reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">How to guides</a></li><li class="is-active"><a href>Use geometry tools</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Use geometry tools</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGraphics/Luxor.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGraphics/Luxor.jl/blob/master/docs/src/howto/geometrytools.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Geometry-tools"><a class="docs-heading-anchor" href="#Geometry-tools">Geometry tools</a><a id="Geometry-tools-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry-tools" title="Permalink"></a></h1><h2 id="Lines-and-distances"><a class="docs-heading-anchor" href="#Lines-and-distances">Lines and distances</a><a id="Lines-and-distances-1"></a><a class="docs-heading-anchor-permalink" href="#Lines-and-distances" title="Permalink"></a></h2><p>You can find the midpoint between two points using <a href="../../reference/api/#Luxor.midpoint"><code>midpoint</code></a>.</p><p>The following code places a small pentagon (using <a href="../../reference/api/#Luxor.ngon"><code>ngon</code></a>) at the midpoint of each side of a larger pentagon:</p><pre><code class="language-julia hljs">sethue(&quot;red&quot;)
ngon(O, 100, 5, 0, action = :stroke)

sethue(&quot;darkgreen&quot;)
p5 = ngon(O, 100, 5, 0, vertices=true)

for i in eachindex(p5)
    pt1 = p5[mod1(i, 5)]
    pt2 = p5[mod1(i + 1, 5)]
    ngon(midpoint(pt1, pt2), 20, 5, 0, action = :fill)
end</code></pre><p><img src="../../assets/figures/midpoint.png" alt="arc"/></p><p>A more general function, <a href="../../reference/api/#Luxor.between"><code>between</code></a>, finds for a value <code>x</code> between 0 and 1 the corresponding point on a line defined by two points. So <code>midpoint(p1, p2)</code> and <code>between(p1, p2, 0.5)</code> should return the same point.</p><pre><code class="language-julia hljs">sethue(&quot;red&quot;)
p1 = Point(-150, 0)
p2 = Point(150, 40)
line(p1, p2)
strokepath()
for i in -0.5:0.1:1.5
    randomhue()
    circle(between(p1, p2, i), 5, action = :fill)
end</code></pre><p><img src="../../assets/figures/betweenpoint.png" alt="arc"/></p><p>Values less than 0.0 and greater than 1.0 appear to work well too, placing the point on the line if extended.</p><p><a href="../../reference/api/#Luxor.center3pts-Tuple{Point, Point, Point}"><code>center3pts</code></a> finds the radius and center point of a circle passing through three points which you can then use with functions such as <a href="../../reference/api/#Luxor.circle-Tuple{Point, Point, Point}"><code>circle</code></a> or <a href="../../reference/api/#Luxor.arc2r-Tuple{Point, Point, Point}"><code>arc2r</code></a>.</p><p><a href="../../reference/api/#Luxor.perpendicular-Tuple{Point, Point, Any}"><code>perpendicular</code></a> finds the foot of a perpendicular line which lies on a line through two points perpendicular to a another point.</p><pre><code class="language-julia hljs">A, B = Point(-150, 0), Point(150, 50)

sethue(&quot;grey50&quot;)
fontsize(18)
setline(4)

line(A, B, action = :stroke)

# point perpendicular to line
C = Point(-50, -80)
D = perpendicular(A, B, C)

# line perpendicular to line
E, F = perpendicular(A, B)

# point perpendicular to extended line
G = Point(230, -200)
H = perpendicular(A, B, G)

sethue(&quot;grey50&quot;)
label.(string.([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;]),
    :ne, offset=10,
    (A, B, C, D, E, F, G, H))

sethue(&quot;red&quot;)
arrow(C, D)
sethue(&quot;green&quot;)
arrow(E, F)
sethue(&quot;orange&quot;)
arrow(G, H)
sethue(&quot;purple&quot;)
circle.([A, B, C, D, E, F, G, H], 4, action = :fill)</code></pre><img src="209e2132.svg" alt="Example block output"/><h2 id="Points-and-arcs"><a class="docs-heading-anchor" href="#Points-and-arcs">Points and arcs</a><a id="Points-and-arcs-1"></a><a class="docs-heading-anchor-permalink" href="#Points-and-arcs" title="Permalink"></a></h2><p>Use <code>isarcclockwise(c, p1, p2)</code> to check whether an arc centered at <code>c</code> running from <code>p1</code> to <code>p2</code> is clockwise.</p><p>The <a href="../../reference/api/#Luxor.pointinverse-Tuple{Point, Any, Any}"><code>pointinverse</code></a> function finds the inverse of a point relative to a reference circle (centerpoint and radius). In the following example, each vertex on the shape inside the circle is linked by an arrow to its inverse outside the circle.</p><pre><code class="language-julia hljs">d = @drawsvg begin
radius = 60
circle(O, radius + 20, action = :stroke)

points = polycross(O, radius, 7, vertices=true)
poly(points, action = :stroke, close=true)

antipoints = last.(pointinverse.(points, O, radius+20))

for (n, pt) in enumerate(zip(points, antipoints))
    sethue(HSB(length(points) * n, 0.8, 0.8))
    @. circle(pt, distance(O, pt)/6, action = :fill)
    sethue(&quot;black&quot;)
    arrow(pt...)
end
end 800 500</code></pre><img src="298e7cb6.svg" alt="Example block output"/><p>Use <a href="../../reference/api/#Luxor.anglethreepoints-Tuple{Point, Point, Point}"><code>anglethreepoints</code></a> to find the angle formed by two lines connecting three points:</p><pre><code class="language-julia hljs">function showangle(pt1, pt2, pt3)
    θ = anglethreepoints(pt1, pt2, pt3)
    label(string(round(rad2deg(θ), digits=2), &quot;°&quot;), :w, pt2)
    newpath()
    carc(pt2, 50, 0, -θ)
    strokepath()
end

let
    background(&quot;grey20&quot;)
    sethue(&quot;white&quot;)
    fontsize(12)
    tiles = Tiler(800, 800, 4, 4)
    for (pos, n) in tiles
        @layer begin
            translate(pos)
            pg = [polar(50, 0), O, polar(50, n * -2π/16)]
            poly(pg, action = :stroke)
            for n in 1:3
                pt1 = pg[1]
                pt2 = pg[2]
                pt3 = pg[3]
                showangle(pt1, pt2, pt3)
            end
        end
    end
end</code></pre><p><img src="../../assets/figures/anglethreepoints.png" alt="angle three points"/></p><p>Other functions that help with geometry include:</p><ul><li><p><a href="../../reference/api/#Luxor.distance-Tuple{Luxor.Hexagon, Luxor.Hexagon}"><code>distance</code></a> distance between two points</p></li><li><p><a href="../../reference/api/#Luxor.getnearestpointonline-Tuple{Point, Point, Point}"><code>getnearestpointonline</code></a> drop perpendicular </p></li><li><p><a href="../../reference/api/#Luxor.pointlinedistance-Tuple{Point, Point, Point}"><code>pointlinedistance</code></a> distance of point from line between two points</p></li><li><p><a href="../../reference/api/#Luxor.slope-Tuple{Any, Any}"><code>slope</code></a> angle of line between two points</p></li><li><p><a href="../../reference/api/#Luxor.perpendicular-Tuple{Point, Point, Any}"><code>perpendicular</code></a> find perpendicular</p></li><li><p><a href="../../reference/api/#Luxor.dotproduct-Tuple{Point, Point}"><code>dotproduct</code></a> scalar dot product of two points</p></li><li><p><a href="../../reference/api/#Luxor.@polar-Tuple{Any}"><code>@polar</code></a> convert radius and angle to point</p></li><li><p><a href="../../reference/api/#Luxor.polar-Tuple{Any, Any}"><code>polar</code></a> convert radius and angle to point</p></li><li><p><a href="../../reference/api/#Luxor.ispointonline-Tuple{Point, Point, Point}"><code>ispointonline</code></a> true if point lies on line</p></li><li><p><a href="../../reference/api/#Luxor.ispointonpoly-Tuple{Point, Vector{Point}}"><code>ispointonpoly</code></a> true if point lies on any edge of polygon</p></li><li><p><a href="../../reference/api/#Luxor.isarcclockwise-Tuple{Point, Point, Point}"><code>isarcclockwise</code></a> true if arc is clockwise</p></li><li><p><a href="../../reference/api/#Luxor.pointinverse-Tuple{Point, Any, Any}"><code>pointinverse</code></a> inverse of point with respect to circle</p></li><li><p><a href="../../reference/api/#Luxor.anglethreepoints-Tuple{Point, Point, Point}"><code>anglethreepoints</code></a> angle formed by two lines defined by three points</p></li><li><p><a href="../../reference/api/#Luxor.determinant3-Tuple{Point, Point, Point}"><code>determinant3</code></a> find determinant of matrix of 3 points</p></li><li><p><a href="../../reference/api/#Luxor.rotatepoint-Tuple{Point, Any}"><code>rotatepoint</code></a> rotate point around another by angle</p></li></ul><h2 id="Triangle-centers"><a class="docs-heading-anchor" href="#Triangle-centers">Triangle centers</a><a id="Triangle-centers-1"></a><a class="docs-heading-anchor-permalink" href="#Triangle-centers" title="Permalink"></a></h2><p>To find the center of a triangle, use one of:</p><ul><li><p><a href="../../reference/api/#Luxor.trianglecircumcenter-Tuple{Point, Point, Point}"><code>trianglecircumcenter</code></a> center of circumcircle/intersection of the perpendicular bisectors.</p></li><li><p><a href="../../reference/api/#Luxor.triangleincenter-Tuple{Point, Point, Point}"><code>triangleincenter</code></a> intersection of the interior angle bisectors</p></li><li><p><a href="../../reference/api/#Luxor.trianglecenter-Tuple{Point, Point, Point}"><code>trianglecenter</code></a> centroid</p></li><li><p><a href="../../reference/api/#Luxor.triangleorthocenter-Tuple{Point, Point, Point}"><code>triangleorthocenter</code></a> intersection of the altitudes</p></li></ul><pre><code class="language-julia hljs">▲ = Point[Point(-100.0, 0.0), Point(110.0, 30.0), Point(65.0, 90.0)]

@layer begin
    sethue(&quot;red&quot;)
    setline(2)
    poly(▲,  :stroke, close=true)
end

# circumcenter
circle(▲..., action = :stroke)
cp = trianglecircumcenter(▲...)
circle(cp, 2, action = :fill)
label(&quot;circumcenter&quot;, :N, cp)

# incenter
cp = triangleincenter(▲...)
circle(cp, 2, action = :fill)
pt1 = getnearestpointonline(▲[1], ▲[2], cp)
@layer begin
    sethue(&quot;black&quot;)
    circle(cp, distance(cp, pt1), action = :stroke)
    label(&quot;incenter&quot;, :S, cp)
end

# center
cp = trianglecenter(▲...)
circle(cp, 2, action = :fill)
label(&quot;center&quot;, :w, cp)

# orthocenter
cp = triangleorthocenter(▲...)
circle(cp, 2, action = :fill)
label(&quot;orthocenter&quot;, :e, cp)</code></pre><p><img src="../../assets/figures/trianglecenters.svg" alt="triangle centers"/></p><h2 id="Intersections"><a class="docs-heading-anchor" href="#Intersections">Intersections</a><a id="Intersections-1"></a><a class="docs-heading-anchor-permalink" href="#Intersections" title="Permalink"></a></h2><p><a href="../../reference/api/#Luxor.intersectionlines-NTuple{4, Point}"><code>intersectionlines</code></a> finds the intersection of two lines.</p><pre><code class="language-julia hljs">sethue(&quot;black&quot;)
P1, P2, P3, P4 = ngon(O, 100, 5, vertices=true)
label.([&quot;P1&quot;, &quot;P2&quot;, &quot;P3&quot;, &quot;P4&quot;], :N, [P1, P2, P3, P4])
line(P1, P2, action = :stroke)
line(P4, P3, action = :stroke)

flag, ip =  intersectionlines(P1, P2, P4, P3)
if flag
    circle(ip, 5, action = :fill)
end</code></pre><p><img src="../../assets/figures/intersection.png" alt="arc"/></p><p><a href="../../reference/api/#Luxor.intersectionlinecircle-Tuple{Point, Point, Point, Any}"><code>intersectionlinecircle</code></a> finds the intersection of a line and a circle. There can be 0, 1, or 2 intersection points.</p><pre><code class="language-julia hljs">l1 = Point(-100.0, -75.0)
l2 = Point(300.0, 100.0)
rad = 100
cpoint = Point(0, 0)
line(l1, l2, action = :stroke)
circle(cpoint, rad, action = :stroke)
nints, ip1, ip2 =  intersectionlinecircle(l1, l2, cpoint, rad)
sethue(&quot;black&quot;)
if nints == 2
    circle(ip1, 8, action = :stroke)
    circle(ip2, 8, action = :stroke)
end</code></pre><p><img src="../../assets/figures/intersection_line_circle.png" alt="arc"/></p><p><a href="../../reference/api/#Luxor.intersection2circles-NTuple{4, Any}"><code>intersection2circles</code></a> finds the area of the intersection of two circles, and <a href="../../reference/api/#Luxor.intersectioncirclecircle-NTuple{4, Any}"><code>intersectioncirclecircle</code></a> finds the points where they cross.</p><p>This example shows the areas of two circles, and the area of their intersection.</p><pre><code class="language-julia hljs">c1 = (O, 150)
c2 = (O + (100, 0), 150)

circle(c1... , action = :stroke)
circle(c2... , action = :stroke)

sethue(&quot;purple&quot;)
circle(c1... , action = :clip)
circle(c2... , action = :fill)
clipreset()

sethue(&quot;black&quot;)

text(string(150^2 * π |&gt; round), c1[1] - (125, 0))
text(string(150^2 * π |&gt; round), c2[1] + (100, 0))
sethue(&quot;white&quot;)
text(string(intersection2circles(c1..., c2...) |&gt; round),
     midpoint(c1[1], c2[1]), halign=:center)

sethue(&quot;red&quot;)
flag, C, D = intersectioncirclecircle(c1..., c2...)
if flag
    circle.([C, D], 5, action = :fill)
end</code></pre><p><img src="../../assets/figures/intersection2circles.png" alt="intersection of two circles"/></p><h2 id="Bounding-boxes"><a class="docs-heading-anchor" href="#Bounding-boxes">Bounding boxes</a><a id="Bounding-boxes-1"></a><a class="docs-heading-anchor-permalink" href="#Bounding-boxes" title="Permalink"></a></h2><p>The <code>BoundingBox</code> type allows you to use rectangular extents to organize and interact with the 2D drawing area. A <code>BoundingBox</code> holds two points, the opposite corners of a bounding box.</p><p>You can make a BoundingBox from:</p><ul><li>the current drawing</li><li>two points</li><li>a text string</li><li>an existing polygon</li><li>a stored path</li><li>a table or table cell</li></ul><p>and by modifying an existing bounding box, or using the results of functions such as <code>circle()</code> or <code>box()</code>.</p><p><a href="../../reference/api/#Luxor.BoundingBox-Tuple{AbstractString}"><code>BoundingBox</code></a> without arguments defines an extent that encloses the drawing (assuming that the origin is at the center of the drawing—see <a href="../../reference/api/#Luxor.origin-Tuple{Any}"><code>origin</code></a>). Use <code>centered=false</code> if the drawing origin is still at the top left corner.</p><p>This example draws circles at three points: at two of the drawing&#39;s corners and at the midway point between them:</p><pre><code class="language-julia hljs">origin()

bb = BoundingBox()
setline(10)
sethue(&quot;orange&quot;)

circle(bb[1], 150, action = :stroke) # first corner

circle(bb[2], 150, action = :stroke) # second corner

circle(midpoint(bb...), 150, action = :stroke) # midpoint

sethue(&quot;blue&quot;)
circle.([bb[1], midpoint(bb[1:2]), bb[2]], 130, action = :fill)

sethue(&quot;red&quot;)
circle.([first(bb), midpoint(bb...), last(bb)], 100, action = :fill)</code></pre><p><img src="../../assets/figures/bbox.png" alt="bounding box"/></p><p>You can make a bounding box from a polygon:</p><pre><code class="language-julia hljs">p = star(O, 100, 5, 0.1, π/3.3, vertices=true)
sethue(&quot;antiquewhite&quot;)
box(BoundingBox(p), action = :fill)

sethue(&quot;black&quot;)
poly(p, action = :stroke, close=true)</code></pre><p><img src="../../assets/figures/bboxpoly.png" alt="bounding box of polygon"/></p><p>The resulting bounding boxes can be passed to <a href="../../reference/api/#Luxor.box-Tuple{Array, Symbol}"><code>box</code></a> or <a href="../../reference/api/#Luxor.poly"><code>poly</code></a> to be drawn.</p><p>To convert a bounding box <code>b</code> into a box, use <code>box(b, vertices=true)</code> or <code>convert(Vector{Point}, BoundingBox())</code>.</p><p>To obtain the coordinates of the corners or key points on the bounding box, use the functions with names combining <code>box</code> and <code>top|middle|bottom</code> and <code>left|center|right</code>. So <code>boxtopleft(bbox)</code> finds the top left corner of the bounding box <code>bbox</code>.</p><p>You can also do some arithmetic on bounding boxes. In the next example, the bounding box is created from the text &quot;good afternoon&quot;. The bounding box is filled with purple, then increased by 40 units on all sides (blue), also scaled by 1.3 (green), and also shifted by <code>(0, 100)</code> (orange).</p><pre><code class="language-julia hljs">translate(-130,0)
fontsize(40)
str = &quot;good afternoon&quot;
sethue(&quot;purple&quot;)
box(BoundingBox(str), action = :fill)
sethue(&quot;white&quot;)
text(str)

sethue(&quot;blue&quot;)
modbox = BoundingBox(str) + 40 # add 40 units to all sides
poly(modbox, action = :stroke, close=true)

sethue(&quot;green&quot;)
modbox = BoundingBox(str) * 1.3
poly(modbox, action = :stroke, close=true)

sethue(&quot;orange&quot;)
modbox = BoundingBox(str) + (0, 100)
poly(modbox, action = :fill, close=true)</code></pre><p><img src="../../assets/figures/bbox2.png" alt="bounding boxes 2"/></p><p>You can find the union and intersection of BoundingBoxes, and also find whether a point lies inside one. The following code creates, shrinks, and shifts two bounding boxes (colored yellow and pink), and then draws: their union (a bounding box that includes both), in black outline; and their intersection (a bounding box of their common areas), in red. Then some random points are created (you can pass a bounding box to <code>rand()</code> to get a random point inside the box) and drawn differently depending on whether they&#39;re inside the intersection or outside.</p><pre><code class="language-julia hljs">origin()
setopacity(0.75)
setline(8)

bbox1 = BoundingBox()/2 - (50, 30)
sethue(&quot;yellow&quot;)
box(bbox1, action = :fill)

bbox2 = BoundingBox()/2  + (50, 30)
sethue(&quot;pink&quot;)
box(bbox2, action = :fill)

sethue(&quot;black&quot;)
box(bbox1 + bbox2, action = :stroke)

sethue(&quot;red&quot;)
bothboxes = intersectboundingboxes(bbox1, bbox2)
box(bothboxes, action = :fill)

for i in 1:500
    pt = rand(bbox1 + bbox2)
    if isinside(pt, bothboxes)
        sethue(&quot;white&quot;)
        circle(pt, 3, action = :fill)
    else
        sethue(&quot;black&quot;)
        circle(pt, 2, action = :fill)
    end
end</code></pre><p><img src="../../assets/figures/bbox3.png" alt="intersecting bounding boxes"/></p><p>To find out where a line starting at the center of a bounding box passing through a point crosses or would cross the edges of the box, use <a href="../../reference/api/#Luxor.pointcrossesboundingbox-Tuple{Any, BoundingBox}"><code>pointcrossesboundingbox</code></a>.</p><pre><code class="language-julia hljs">bx = BoundingBox(box(O, 200, 200))
setline(1)
box(bx, action = :stroke)
for i in 1:10
    pt = randompoint((1.5bx)...)
    pt2 = pointcrossesboundingbox(pt, bx)

    sethue(&quot;grey50&quot;)
    arrow(O, pt)
    sethue(&quot;red&quot;)
    circle(pt2, 3, action = :stroke)
end</code></pre><p><img src="../../assets/figures/bbox4.png" alt="point crosses bounding box"/></p><h2 id="Random-points"><a class="docs-heading-anchor" href="#Random-points">Random points</a><a id="Random-points-1"></a><a class="docs-heading-anchor-permalink" href="#Random-points" title="Permalink"></a></h2><p>You can use <a href="../../reference/api/#Luxor.randompointarray-NTuple{5, Any}"><code>randompointarray</code></a> to create an array of randomly placed points.</p><p>The <code>randompointarray(boundingbox, distance)</code> method fills the boundingbox with random points up to <code>distance</code> units apart using a Poisson Disk sampling method.</p><pre><code class="language-julia hljs">background(&quot;black&quot;)
b = blend(
        boxtopleft(BoundingBox()),
        boxbottomright(BoundingBox()),
        &quot;red&quot;,
        &quot;green&quot;)

addstop(b, 0.3, &quot;orange&quot;)
addstop(b, 0.4, &quot;magenta&quot;)
addstop(b, 0.5, &quot;cyan&quot;)
addstop(b, 0.7, &quot;yellow&quot;)
setblend(b)

for pt in randompointarray(BoundingBox() * 0.9, 15)
    d = rescale(distance(pt, O), 0, sqrt(800 * 500), 1, 0)
    circle(pt, 1 + 7d, action = :fill)
end</code></pre><img src="f9e1ea6c.svg" alt="Example block output"/><p>The <code>randompointarray(point1, point2, n)</code> method generates <code>n</code> random points in the area bounded by two points, using Julia&#39;s random number generator.</p><pre><code class="language-julia hljs">pt1 = Point(-300, -150)
pt2 = Point(300, 150)

sethue(&quot;purple&quot;)
map(pt -&gt; circle(pt, 6, action = :fill), (pt1, pt2))
box(pt1, pt2, action = :stroke)

sethue(&quot;blue&quot;)
map(pt -&gt; circle(pt, 4, action = :fill), randompointarray(pt1, pt2, 200))</code></pre><img src="48b6e5fd.svg" alt="Example block output"/><p>Use <code>rand(BoundingBox())</code> to return a single point somewhere inside a bounding box.</p><h2 id="Noise"><a class="docs-heading-anchor" href="#Noise">Noise</a><a id="Noise-1"></a><a class="docs-heading-anchor-permalink" href="#Noise" title="Permalink"></a></h2><p>For artistic graphics you might prefer noisy input values to purely random ones. Use the <a href="../../reference/api/#Luxor.noise-Union{Tuple{Any}, Tuple{T}} where T&lt;:Integer"><code>noise</code></a> function to obtain smoothly changing random values corresponding to input coordinates. The returned values wander slowly rather than jump about everywhere.</p><p>In this example, the gray value varies gradually as the <a href="../../reference/api/#Luxor.noise-Union{Tuple{Any}, Tuple{T}} where T&lt;:Integer"><code>noise</code></a> function returns values between 0 and 1 depending on the location of the two input values <code>pos.x</code> and <code>pos.y</code>.</p><p>The top two quadrants use a lower value for the <code>detail</code> keyword argument, an integer ()&gt;= 1) specifying how many &quot;octaves&quot; of noise you want.</p><p>The left two quadrants use a lower value for the <code>persistence</code> keyword argument, a floating point number specifying how the amplitude diminishes for each successive level of detail. There is more fine detail when the persistence is higher, particularly when the <code>detail</code> setting is also high.</p><pre><code class="language-julia hljs">tiles = Tiler(800, 400, 200, 200)
sethue(&quot;black&quot;)
for (pos, n) in tiles
    freq = 0.05
    pos.y &lt; 0 ? d = 1      : d = 4
    pos.x &lt; 0 ? pers = 0.3 : pers = 1.0
    ns = noise(freq * pos.x, freq * pos.y,
        detail=d,
        persistence=pers)
    setgray(ns)
    box(pos, tiles.tilewidth, tiles.tileheight, action = :fillstroke)
end</code></pre><p><img src="../../assets/figures/noise.png" alt="noise"/></p><p>Use <a href="../../reference/api/#Luxor.initnoise-Tuple{Any}"><code>initnoise</code></a> to initialize the noise behaviour.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../simplegraphics/">« Draw simple shapes</a><a class="docs-footer-nextpage" href="../tables-grids/">Work with tables and grids »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Sunday 14 January 2024 10:15">Sunday 14 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
