<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Simple shapes · Luxor</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Luxor logo"/></a><div class="docs-package-name"><span class="docs-autofit">Luxor</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction to Luxor</a></li><li><a class="tocitem" href="../examples/">A few examples</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../basics/">Basic concepts</a></li><li class="is-active"><a class="tocitem" href>Simple shapes</a><ul class="internal"><li><a class="tocitem" href="#Rectangles-and-boxes"><span>Rectangles and boxes</span></a></li><li><a class="tocitem" href="#Circles-and-ellipses"><span>Circles and ellipses</span></a></li><li><a class="tocitem" href="#Circles-and-tangents"><span>Circles and tangents</span></a></li><li><a class="tocitem" href="#Paths-and-positions"><span>Paths and positions</span></a></li><li><a class="tocitem" href="#Lines"><span>Lines</span></a></li><li><a class="tocitem" href="#Arrows"><span>Arrows</span></a></li><li><a class="tocitem" href="#Arcs-and-curves"><span>Arcs and curves</span></a></li><li><a class="tocitem" href="#More-curved-shapes:-sectors,-spirals,-and-squircles"><span>More curved shapes: sectors, spirals, and squircles</span></a></li></ul></li><li><a class="tocitem" href="../moregraphics/">More graphics</a></li><li><a class="tocitem" href="../geometrytools/">Geometry tools</a></li><li><a class="tocitem" href="../tables-grids/">Tables and grids</a></li><li><a class="tocitem" href="../colors-styles/">Colors and styles</a></li><li><a class="tocitem" href="../polygons/">Polygons and paths</a></li><li><a class="tocitem" href="../text/">Text</a></li><li><a class="tocitem" href="../transforms/">Transforms and matrices</a></li><li><a class="tocitem" href="../clipping/">Clipping</a></li><li><a class="tocitem" href="../images/">Images</a></li><li><a class="tocitem" href="../turtle/">Turtle graphics</a></li><li><a class="tocitem" href="../animation/">Animation</a></li><li><a class="tocitem" href="../moreexamples/">More examples</a></li><li><a class="tocitem" href="../functionindex/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Simple shapes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Simple shapes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGraphics/Luxor.jl/blob/master/docs/src/simplegraphics.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Simple-graphics"><a class="docs-heading-anchor" href="#Simple-graphics">Simple graphics</a><a id="Simple-graphics-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-graphics" title="Permalink"></a></h1><p>In Luxor, there are different ways of working with graphical items. You can either draw them immediately (ie place them on the drawing, and they&#39;re then fixed). Or you can construct geometric objects as lists of points for further processing. Watch out for a <code>vertices=true</code> option, which returns coordinate data rather than draws a shape.</p><h2 id="Rectangles-and-boxes"><a class="docs-heading-anchor" href="#Rectangles-and-boxes">Rectangles and boxes</a><a id="Rectangles-and-boxes-1"></a><a class="docs-heading-anchor-permalink" href="#Rectangles-and-boxes" title="Permalink"></a></h2><p>The simple rectangle and box shapes can be made in different ways.</p><pre><code class="language-julia">rulers()
sethue(&quot;red&quot;)
rect(O, 100, 100, :stroke)
sethue(&quot;blue&quot;)
box(O, 100, 100, :stroke)</code></pre><p><img src="../assets/figures/basicrects.png" alt="rect vs box"/></p><p><code>rect()</code> rectangles are positioned by a corner, but a box made with <code>box()</code> can either be defined by its center and dimensions, or by two opposite corners.</p><p><img src="../assets/figures/rects.png" alt="rects"/></p><p>If you want the coordinates of the corners of a box, rather than draw one immediately, use:</p><pre><code class="language-julia">box(centerpoint, width, height, vertices=true)</code></pre><p>or</p><pre><code class="language-julia">box(corner1,  corner2, vertices=true)</code></pre><p><code>box</code> is also able to draw some of the other Luxor objects, such as BoundingBoxes and Table cells.</p><article class="docstring"><header><a class="docstring-binding" id="Luxor.rect" href="#Luxor.rect"><code>Luxor.rect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rect(xmin, ymin, w, h, action)</code></pre><p>Create a rectangle with one corner at (<code>xmin</code>/<code>ymin</code>) with width <code>w</code> and height <code>h</code> and then do an action.</p><p>See <code>box()</code> for more ways to do similar things, such as supplying two opposite corners, placing by centerpoint and dimensions.</p></div></section><section><div><pre><code class="language-none">rect(cornerpoint, w, h, action;
    vertices=false)</code></pre><p>Create a rectangle with one corner at <code>cornerpoint</code> with width <code>w</code> and height <code>h</code> and do an action.</p><p>Use <code>vertices=true</code> to return an array of the four corner points: bottom left, top left, top right, bottom right.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.box" href="#Luxor.box"><code>Luxor.box</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">box(cornerpoint1, cornerpoint2, action=:none;
    vertices=false)</code></pre><p>Create a box (rectangle) between two points and do an action.</p><p>Use <code>vertices=true</code> to return an array of the four corner points: bottom left, top left, top right, bottom right.</p></div></section><section><div><pre><code class="language-none">box(points::Array, action=:none)</code></pre><p>Create a box/rectangle using the first two points of an array of Points to defined opposite corners.</p><p>Use <code>vertices=true</code> to return an array of the four corner points: bottom left, top left, top right, bottom right.</p></div></section><section><div><pre><code class="language-none">box(pt::Point, width, height, action=:none; vertices=false)</code></pre><p>Create a box/rectangle centered at point <code>pt</code> with width and height. Use <code>vertices=true</code> to return an array of the four corner points rather than draw the box.</p></div></section><section><div><pre><code class="language-none">box(x, y, width, height, action=:none)</code></pre><p>Create a box/rectangle centered at point <code>x/y</code> with width and height.</p></div></section><section><div><pre><code class="language-none">box(pt, width, height, cornerradius, action=:none)</code></pre><p>Draw a box/rectangle centered at point <code>pt</code> with <code>width</code> and <code>height</code> and round each corner by <code>cornerradius</code>.</p></div></section><section><div><pre><code class="language-none">box(bbox::BoundingBox, :action;
        vertices=false)</code></pre><p>Make a box using the bounds in <code>bbox</code>.</p><p>Use <code>vertices=true</code> to return an array of the four corner points: bottom left, top left, top right, bottom right.</p></div></section><section><div><pre><code class="language-none">box(tiles::Tiler, n::T where T &lt;: Integer, action::Symbol=:none;
    vertices=false)</code></pre><p>Draw a box in tile <code>n</code> of tiles <code>tiles</code>.</p></div></section><section><div><pre><code class="language-none">box(t::Table, r::T, c::T, action::Symbol=:none) where T &lt;: Integer</code></pre><p>Draw a box in table <code>t</code> at row <code>r</code> and column <code>c</code>.</p></div></section><section><div><pre><code class="language-none">box(t::Table, cellnumber::Int, action::Symbol=:none; vertices=false)</code></pre><p>Draw box <code>cellnumber</code> in table <code>t</code>.</p></div></section><section><div><pre><code class="language-none">box(tile::BoxmapTile, action::Symbol=:none; vertices=false)</code></pre><p>Use a Boxmaptile to make or draw a rectangular box. Use <code>vertices=true</code> to obtain the coordinates.</p><p>Create boxmaps using <code>boxmap()</code>.</p></div></section></article><p><code>box()</code> also returns the coordinates of the corners.</p><pre><code class="language-julia">box(O, 100, 100, :none)</code></pre><pre><code class="language-none">4-element Array{Point,1}:
 Point(-50.0, 50.0)
 Point(-50.0, -50.0)
 Point(50.0, -50.0)
 Point(50.0, 50.0)</code></pre><p>For regular polygons, triangles, pentagons, and so on, see the next section on Polygons.</p><h2 id="Circles-and-ellipses"><a class="docs-heading-anchor" href="#Circles-and-ellipses">Circles and ellipses</a><a id="Circles-and-ellipses-1"></a><a class="docs-heading-anchor-permalink" href="#Circles-and-ellipses" title="Permalink"></a></h2><p>There are various ways to make circles, including by center and radius, or passing through two or three points:</p><pre><code class="language-julia">sethue(&quot;black&quot;)
p1 = Point(0, -50)
p2 = Point(100, 0)
p3 = Point(0, 65)
map(p -&gt; circle(p, 4, :fill), [p1, p2, p3])
sethue(&quot;orange&quot;)
circle(center3pts(p1, p2, p3)..., :stroke)

sethue(&quot;red&quot;)
p1 = Point(0, 30)
p2 = Point(20, -40)
p3 = Point(50, 5)
circle.((p1, p2, p3), 3, :stroke)
circle(p1, p2, p3, :stroke)</code></pre><p><img src="../assets/figures/circles.png" alt="circles"/></p><p>The <code>center3pts()</code> function returns the center position and radius of a circle passing through three points:</p><pre><code class="language-julia">sethue(&quot;black&quot;)
p1 = Point(0, -50)
p2 = Point(100, 0)
p3 = Point(0, 65)
map(p -&gt; circle(p, 4, :fill), [p1, p2, p3])
sethue(&quot;orange&quot;)
circle(center3pts(p1, p2, p3)..., :stroke)</code></pre><p><img src="../assets/figures/center3.png" alt="center and radius of 3 points"/></p><article class="docstring"><header><a class="docstring-binding" id="Luxor.circle" href="#Luxor.circle"><code>Luxor.circle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">circle(x, y, r, action=:none)</code></pre><p>Make a circle of radius <code>r</code> centered at <code>x</code>/<code>y</code>.</p><p><code>action</code> is one of the actions applied by <code>do_action</code>, defaulting to <code>:none</code>. You can also use <code>ellipse()</code> to draw circles and place them by their centerpoint.</p></div></section><section><div><pre><code class="language-none">circle(pt, r, action=:none)</code></pre><p>Make a circle centered at <code>pt</code>.</p></div></section><section><div><pre><code class="language-none">circle(pt1::Point, pt2::Point, action=:none)</code></pre><p>Make a circle that passes through two points that define the diameter:</p></div></section><section><div><pre><code class="language-none">circle(pt1::Point, pt2::Point, pt3::Point, action=:none)</code></pre><p>Make a circle that passes through three points.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.center3pts" href="#Luxor.center3pts"><code>Luxor.center3pts</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">center3pts(a::Point, b::Point, c::Point)</code></pre><p>Find the radius and center point for three points lying on a circle.</p><p>returns <code>(centerpoint, radius)</code> of a circle.</p><p>If there&#39;s no such circle, the function returns <code>(Point(0, 0), 0)</code>.</p></div></section></article><p>With <code>ellipse()</code> you can place ellipses and circles by defining the center point and the width and height.</p><pre><code class="language-julia">tiles = Tiler(500, 300, 5, 5)
width = 20
height = 25
for (pos, n) in tiles
    global width, height
    randomhue()
    ellipse(pos, width, height, :fill)
    sethue(&quot;black&quot;)
    label = string(round(width/height, digits=2))
    textcentered(label, pos.x, pos.y + 25)
    width += 2
end</code></pre><p><img src="../assets/figures/ellipses.png" alt="ellipses"/></p><p><code>ellipse()</code> can also construct polygons that are approximations to ellipses. You supply two focal points and a length which is the sum of the distances of a point on the perimeter to the two focii.</p><pre><code class="language-julia">fontface(&quot;Menlo&quot;)

f1 = Point(-100, 0)
f2 = Point(100, 0)

circle.([f1, f2], 3, :fill)

epoly = ellipse(f1, f2, 250, vertices=true)
poly(epoly, :stroke,  close=true)

pt = epoly[rand(1:end)]

poly([f1, pt, f2], :stroke)

label(&quot;f1&quot;, :W, f1, offset=10)
label(&quot;f2&quot;, :E, f2, offset=10)

label(string(round(distance(f1, pt), digits=1)), :SE, midpoint(f1, pt))
label(string(round(distance(pt, f2), digits=1)), :SW, midpoint(pt, f2))

label(&quot;ellipse(f1, f2, 250)&quot;, :S, Point(0, 75))</code></pre><p><img src="../assets/figures/ellipses_1.png" alt="more ellipses"/></p><p>The advantage of this method is that there&#39;s a <code>vertices=true</code> option, allowing further scope for polygon manipulation.</p><pre><code class="language-julia">f1 = Point(-100, 0)
f2 = Point(100, 0)
ellipsepoly = ellipse(f1, f2, 170, :none, vertices=true)
[ begin
    setgray(rescale(c, 150, 1, 0, 1))
    poly(offsetpoly(ellipsepoly, c), close=true, :fill);
    rotate(π/20)
  end
     for c in 150:-10:1 ]</code></pre><p><img src="../assets/figures/ellipses_2.png" alt="even more ellipses"/></p><article class="docstring"><header><a class="docstring-binding" id="Luxor.ellipse" href="#Luxor.ellipse"><code>Luxor.ellipse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ellipse(xc, yc, w, h, action=:none)</code></pre><p>Make an ellipse, centered at <code>xc/yc</code>, fitting in a box of width <code>w</code> and height <code>h</code>.</p></div></section><section><div><pre><code class="language-none">ellipse(cpt, w, h, action=:none)</code></pre><p>Make an ellipse, centered at point <code>c</code>, with width <code>w</code>, and height <code>h</code>.</p></div></section><section><div><pre><code class="language-none">ellipse(focus1::Point, focus2::Point, k, action=:none;
        stepvalue=pi/100,
        vertices=false,
        reversepath=false)</code></pre><p>Build a polygon approximation to an ellipse, given two points and a distance, <code>k</code>, which is the sum of the distances to the focii of any points on the ellipse (or the shortest length of string required to go from one focus to the perimeter and on to the other focus).</p></div></section><section><div><pre><code class="language-none">ellipse(focus1::Point, focus2::Point, pt::Point, action=:none;
        stepvalue=pi/100,
        vertices=false,
        reversepath=false)</code></pre><p>Build a polygon approximation to an ellipse, given two points and a point somewhere on the ellipse.</p></div></section></article><p><code>circlepath()</code> constructs a circular path from Bézier curves, which allows you to use circles as paths.</p><pre><code class="language-julia">setline(4)
tiles = Tiler(600, 250, 1, 5)
for (pos, n) in tiles
    randomhue()
    circlepath(pos, tiles.tilewidth/2, :path)
    newsubpath()
    circlepath(pos, rand(5:tiles.tilewidth/2 - 1), :fill, reversepath=true)
end</code></pre><p><img src="../assets/figures/circle-path.png" alt="circles as paths"/></p><article class="docstring"><header><a class="docstring-binding" id="Luxor.circlepath" href="#Luxor.circlepath"><code>Luxor.circlepath</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">circlepath(center::Point, radius, action=:none;
    reversepath=false,
    kappa = 0.5522847498307936)</code></pre><p>Draw a circle using Bézier curves.</p><p>The magic value, <code>kappa</code>, is <code>4.0 * (sqrt(2.0) - 1.0) / 3.0</code>.</p></div></section></article><h2 id="Circles-and-tangents"><a class="docs-heading-anchor" href="#Circles-and-tangents">Circles and tangents</a><a id="Circles-and-tangents-1"></a><a class="docs-heading-anchor-permalink" href="#Circles-and-tangents" title="Permalink"></a></h2><p>Functions to find tangents to circles include:</p><ul><li><code>pointcircletangent()</code> finds a point on a line joining a point and tangent to a circle</li><li><code>circlecircleoutertangents()</code> finds the points that lie on outer tangents to two circles</li><li><code>circlecircleinnertangents()</code> finds the points that lie on inner tangents to two circles</li><li><code>circletangent2circles()</code> makes circles of a particular radius tangential to two circles</li><li><code>circlepointtangent()</code> makes circles of a particular radius passing through a point and tangential to another circle</li></ul><pre><code class="language-julia">point = Point(-150, 0)
circlecenter = Point(150, 0)
circleradius = 80

circle.((point, circlecenter), 5, :fill)
circle(circlecenter, circleradius, :stroke)
pt1, pt2 = pointcircletangent(point, circlecenter, circleradius)

sethue(&quot;grey65&quot;)
rule(point, slope(point, pt1))
rule(point, slope(point, pt2))</code></pre><p><img src="../assets/figures/point-circle-tangents.png" alt="point circle tangents"/></p><pre><code class="language-julia">circle1center = Point(-150, 0)
circle1radius = 60
circle2center = Point(150, 0)
circle2radius = 80

circle.((circle1center, circle2center), 5, :fill)
circle(circle1center, circle1radius, :stroke)
circle(circle2center, circle2radius, :stroke)

p1, p2, p3, p4 = circlecircleoutertangents(
    circle1center, circle1radius,
    circle2center, circle2radius)

sethue(&quot;orange&quot;)
rule(p1, slope(p1, p2))
rule(p3, slope(p3, p4))</code></pre><p><img src="../assets/figures/circle-circle-outer-tangents.png" alt="circle circle outer tangents"/></p><p>Finding the inner tangents requires a separate function.</p><pre><code class="language-julia">circle1center = Point(-150, 0)
circle1radius = 60
circle2center = Point(150, 0)
circle2radius = 80

circle.((circle1center, circle2center), 5, :fill)
circle(circle1center, circle1radius, :stroke)
circle(circle2center, circle2radius, :stroke)

p1, p2, p3, p4 = circlecircleinnertangents(
    circle1center, circle1radius,
    circle2center, circle2radius)

label.((&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;, &quot;p4&quot;), :n, (p1, p2, p3, p4))
sethue(&quot;orange&quot;)
rule(p1, slope(p1, p2))
rule(p3, slope(p3, p4))

sethue(&quot;purple&quot;)
circle.((p1, p2, p3, p4), 3, :fill)</code></pre><p><img src="../assets/figures/circle-circle-inner-tangents.png" alt="circle circle inner tangents"/></p><p><code>circletangent2circles()</code> takes the required radius and two existing circles:</p><pre><code class="language-julia">circle1 = (Point(-100, 0), 90)
circle(circle1..., :stroke)
circle2 = (Point(100, 0), 90)
circle(circle2..., :stroke)

requiredradius = 25
ncandidates, p1, p2 = circletangent2circles(requiredradius, circle1..., circle2...)

if ncandidates==2
    sethue(&quot;orange&quot;)
    circle(p1, requiredradius, :fill)
    sethue(&quot;green&quot;)
    circle(p2, requiredradius, :fill)
    sethue(&quot;purple&quot;)
    circle(p1, requiredradius, :stroke)
    circle(p2, requiredradius, :stroke)
end

# the circles are 10 apart, so there should be just one circle
# that fits there

requiredradius = 10
ncandidates, p1, p2 = circletangent2circles(requiredradius, circle1..., circle2...)

if ncandidates==1
    sethue(&quot;blue&quot;)
    circle(p1, requiredradius, :fill)
    sethue(&quot;cyan&quot;)
    circle(p1, requiredradius, :stroke)
end</code></pre><p><img src="../assets/figures/circle-tangents.png" alt="circle tangents"/></p><p><code>circlepointtangent()</code> looks for circles of a specified radius that pass through a point and are tangential to a circle. There are usually two candidates.</p><pre><code class="language-julia">circle1 = (Point(-100, 0), 90)
circle(circle1..., :stroke)

requiredradius = 50
requiredpassthrough = O + (80, 0)
ncandidates, p1, p2 = circlepointtangent(requiredpassthrough, requiredradius, circle1...)

if ncandidates==2
    sethue(&quot;orange&quot;)
    circle(p1, requiredradius, :stroke)
    sethue(&quot;green&quot;)
    circle(p2, requiredradius, :stroke)
end

sethue(&quot;black&quot;)
circle(requiredpassthrough, 4, :fill)</code></pre><p><img src="../assets/figures/circle-point-tangent.png" alt="circle tangents 2"/></p><p>These last two functions can return 0, 1, or 2 points (since there are often two solutions to a specific geometric layout).</p><article class="docstring"><header><a class="docstring-binding" id="Luxor.pointcircletangent" href="#Luxor.pointcircletangent"><code>Luxor.pointcircletangent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pointcircletangent(point::Point, circlecenter::Point, circleradius)</code></pre><p>Find the two points on a circle that lie on tangent lines passing through an external point.</p><p>If both points are O, the external point is inside the circle, and the result is <code>(O, O)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.circletangent2circles" href="#Luxor.circletangent2circles"><code>Luxor.circletangent2circles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">circletangent2circles(radius, circle1center::Point, circle1radius, circle2center::Point, circle2radius)</code></pre><p>Find the centers of up to two circles of radius <code>radius</code> that are tangent to the two circles defined by <code>circle1...</code> and <code>circle2...</code>. These two circles can overlap, but one can&#39;t be inside the other.</p><ul><li><p>(0, O, O)      - no such circles exist</p></li><li><p>(1, pt1, O)    - 1 circle exists, centered at pt1</p></li><li><p>(2, pt1, pt2)  - 2 circles exist, with centers at pt1 and pt2</p></li></ul><p>(The O are just dummy points so that three values are always returned.)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.circlepointtangent" href="#Luxor.circlepointtangent"><code>Luxor.circlepointtangent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">circlepointtangent(through::Point, radius, targetcenter::Point, targetradius)</code></pre><p>Find the centers of up to two circles of radius <code>radius</code> that pass through point <code>through</code> and are tangential to a circle that has radius <code>targetradius</code> and center <code>targetcenter</code>.</p><p>This function returns a tuple:</p><ul><li><p>(0, O, O)      - no circles exist</p></li><li><p>(1, pt1, O)    - 1 circle exists, centered at pt1</p></li><li><p>(2, pt1, pt2)  - 2 circles exist, with centers at pt1 and pt2</p></li></ul><p>(The O are just dummy points so that three values are always returned.)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.circlecircleinnertangents" href="#Luxor.circlecircleinnertangents"><code>Luxor.circlecircleinnertangents</code></a> — <span class="docstring-category">Function</span></header><section><div><p>circlecircleinnertangents(circle1center::Point, circle1radius, circle2center::Point, circle2radius)</p><p>Find the inner tangents of two circles. These are tangent lines that cross as they skim past one circle and touch the other.</p><p>Returns the four points: tangentpoint1 on circle 1, tangentpoint1 on circle2, tangentpoint2 on circle 1, tangentpoint2 on circle2.</p><p>Returns <code>(O, O, O, O)</code> if inner tangents can&#39;t be found (eg when the circles overlap).</p><p>Use <code>circlecircleoutertangents()</code> to find the outer tangents.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.circlecircleoutertangents" href="#Luxor.circlecircleoutertangents"><code>Luxor.circlecircleoutertangents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">circlecircleoutertangents(cpt1::Point, r1, cpt2::Point, r2)</code></pre><p>Return four points, <code>p1</code>, <code>p2,</code>p3<code>,</code>p4<code>, where a line through</code>p1<code>and</code>p2<code>, and a line through</code>p3<code>and</code>p4<code>, form the outer tangents to the circles defined by</code>cpt1/r1<code>and</code>cpt2/r2`.</p><p>Returns four identical points (<code>O</code>) if one of the circles lies inside the other.</p></div></section></article><h2 id="Paths-and-positions"><a class="docs-heading-anchor" href="#Paths-and-positions">Paths and positions</a><a id="Paths-and-positions-1"></a><a class="docs-heading-anchor-permalink" href="#Paths-and-positions" title="Permalink"></a></h2><p>A path is a sequence of lines and curves. You can add lines and curves to the current path, then use <code>closepath()</code> to join the last point to the first.</p><p>A path can have subpaths, created with<code>newsubpath()</code>, which can form holes.</p><p>There is a &#39;current position&#39; which you can set with <code>move()</code>, and can use implicitly in functions like <code>line()</code>, <code>rline()</code>, <code>text()</code>, <code>arc()</code> and <code>curve()</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Luxor.move" href="#Luxor.move"><code>Luxor.move</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">move(pt)</code></pre><p>Move to a point.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.rmove" href="#Luxor.rmove"><code>Luxor.rmove</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rmove(pt)</code></pre><p>Move relative to current position by the <code>pt</code>&#39;s x and y:</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.newpath" href="#Luxor.newpath"><code>Luxor.newpath</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">newpath()</code></pre><p>Create a new path. This is Cairo&#39;s <code>new_path()</code> function.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.newsubpath" href="#Luxor.newsubpath"><code>Luxor.newsubpath</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">newsubpath()</code></pre><p>Add a new subpath to the current path. This is Cairo&#39;s <code>new_sub_path()</code> function. It can be used for example to make holes in shapes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.closepath" href="#Luxor.closepath"><code>Luxor.closepath</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">closepath()</code></pre><p>Close the current path. This is Cairo&#39;s <code>close_path()</code> function.</p></div></section></article><h2 id="Lines"><a class="docs-heading-anchor" href="#Lines">Lines</a><a id="Lines-1"></a><a class="docs-heading-anchor-permalink" href="#Lines" title="Permalink"></a></h2><p>Use <code>line()</code> and <code>rline()</code> to draw straight lines. <code>line(pt1, pt2, action)</code> draws a line between two points. <code>line(pt)</code> adds a line to the current path going from the current position to the point. <code>rline(pt)</code> adds a line relative to the current position.</p><article class="docstring"><header><a class="docstring-binding" id="Luxor.line" href="#Luxor.line"><code>Luxor.line</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">line(pt)</code></pre><p>Draw a line from the current position to the <code>pt</code>.</p></div></section><section><div><pre><code class="language-none">line(pt1::Point, pt2::Point, action=:none)</code></pre><p>Make a line between two points, <code>pt1</code> and <code>pt2</code> and do an action.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.rline" href="#Luxor.rline"><code>Luxor.rline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rline(pt)</code></pre><p>Draw a line relative to the current position to the <code>pt</code>.</p></div></section></article><p>You can use <code>rule()</code> to draw a line through a point, optionally at an angle to the current x-axis.</p><pre><code class="language-julia">y = 10
for x in 10 .^ range(0, length=100, stop=3)
    global y
    circle(Point(x, y), 2, :fill)
    rule(Point(x, y), -π/2, boundingbox=BoundingBox(centered=false))
    y += 2
end</code></pre><p><img src="../assets/figures/rule.png" alt="arc"/></p><p>Use the <code>boundingbox</code> keyword argument to crop the ruled lines with a BoundingBox.</p><pre><code class="language-julia">origin()
box(BoundingBox() * 0.9, :stroke)
for x in 10 .^ range(0, length=100, stop=3)
    rule(Point(x, 0), π/2,  boundingbox=BoundingBox() * 0.9)
    rule(Point(-x, 0), π/2, boundingbox=BoundingBox() * 0.9)
end</code></pre><pre><code class="language-none">true</code></pre><p><img src="../assets/figures/rulebbox.png" alt="arc"/></p><article class="docstring"><header><a class="docstring-binding" id="Luxor.rule" href="#Luxor.rule"><code>Luxor.rule</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rule(pos, theta;
    boundingbox=BoundingBox(),
    vertices=false)</code></pre><p>Draw a straight line through <code>pos</code> at an angle <code>theta</code> from the x axis.</p><p>By default, the line spans the entire drawing, but you can supply a BoundingBox to change the extent of the line.</p><pre><code class="language-none">rule(O)       # draws an x axis
rule(O, pi/2) # draws a  y axis</code></pre><p>The function:</p><pre><code class="language-none">rule(O, pi/2, boundingbox=BoundingBox()/2)</code></pre><p>draws a line that spans a bounding box half the width and height of the drawing, and returns a Set of end points. If you just want the vertices and don&#39;t want to draw anything, use <code>vertices=true</code>.</p></div></section></article><h2 id="Arrows"><a class="docs-heading-anchor" href="#Arrows">Arrows</a><a id="Arrows-1"></a><a class="docs-heading-anchor-permalink" href="#Arrows" title="Permalink"></a></h2><p>You can draw lines, arcs, and curves with arrows at the end with <code>arrow()</code>. For straight arrows, supply the start and end points. For arrows as circular arcs, you provide center, radius, and start and finish angles. You can optionally provide dimensions for the <code>arrowheadlength</code> and <code>arrowheadangle</code> of the tip of the arrow (angle in radians between side and center). The default line weight is 1.0, equivalent to <code>setline(1)</code>), but you can specify another.</p><pre><code class="language-julia">arrow(O, Point(0, -65))
arrow(O, Point(100, -65), arrowheadlength=20, arrowheadangle=pi/4, linewidth=.3)
arrow(O, 100, π, π/2, arrowheadlength=25,   arrowheadangle=pi/12, linewidth=1.25)</code></pre><p><img src="../assets/figures/arrow.png" alt="arrows"/></p><p>If you provide four points, you can draw a Bézier curve with optional arrowheads at each end. Use the various options to control their presence and appearance.</p><pre><code class="language-julia">pts = ngon(O, 100, 8, vertices=true)
sethue(&quot;mediumvioletred&quot;)
arrow(pts[2:5]..., :stroke, startarrow=false, finisharrow=true)
sethue(&quot;cyan4&quot;)
arrow(pts[3:6]..., startarrow=true, finisharrow=true)
sethue(&quot;midnightblue&quot;)
arrow(pts[[4, 2, 6, 8]]..., :stroke,
    startarrow=true,
    finisharrow=true,
    arrowheadangle = π/6,
    arrowheadlength = 35,
    linewidth  = 1.5)</code></pre><p><img src="../assets/figures/arrowbezier.png" alt="arrows"/></p><p>The <code>arrow()</code> functions allow you to specify decoration - graphics at a point somewhere along the shaft. For example, say you want to draw a number and a circle at the midpoint of an arrow, define a function that draws text <code>t</code> in a circle of radius <code>r</code> :</p><pre><code class="language-none">function marker(r, t)
    @layer begin
        sethue(&quot;purple&quot;)
        circle(O, r,  :fill)
        sethue(&quot;white&quot;)
        fontsize(30)
        text(string(t), halign=:center, valign=:middle)
    end
end</code></pre><p>and then pass it to the <code>decorate</code> keyword. By default, the graphics origin when the function is called is placed at the midpoint (0.5) of the arrow&#39;s shaft.</p><pre><code class="language-julia">pts = ngon(O, 100, 5, vertices=true)

sethue(&quot;mediumvioletred&quot;)

# using an anonymous function
arrow(pts[1:4]..., decorate = () -&gt; marker(10, 3))

sethue(&quot;olivedrab&quot;)

# no arrow, just a graphic, at 0.75
arrow(pts[1:4]..., decorate = () -&gt; ngon(O, 20, 4, 0, :fill), decoration = 0.75, :none)</code></pre><p><img src="../assets/figures/arrowbezierdecoration.png" alt="arrows with decoration"/></p><p>Use the <code>decoration</code> keyword to specify a location other than the default 0.5.</p><p>The graphics environment provided by the <code>decorate</code> function is centered at the decoration point, and rotated to the slope of the curve at that point.</p><article class="docstring"><header><a class="docstring-binding" id="Luxor.arrow" href="#Luxor.arrow"><code>Luxor.arrow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">arrow(startpoint::Point, endpoint::Point;
    linewidth = 1.0,
    arrowheadlength = 10,
    arrowheadangle = pi/8,
    decoration = 0.5,
    decorate = () -&gt; ())</code></pre><p>Draw a line between two points and add an arrowhead at the end. The arrowhead length will be the length of the side of the arrow&#39;s head, and the arrowhead angle is the angle between the sloping side of the arrowhead and the arrow&#39;s shaft.</p><p>Arrows don&#39;t use the current linewidth setting (<code>setline()</code>), and defaults to 1, but you can specify another value. It doesn&#39;t need stroking/filling, the shaft is stroked and the head filled with the current color.</p><p>The <code>decorate</code> keyword argument accepts a function that can execute code at locations on the arrow&#39;s shaft. The inherited graphic environment is centered at each point on the curve between 0 and 1 given by scalar or vector <code>decoration</code>, and the x-axis is aligned with the direction of the curve at that point.</p></div></section><section><div><pre><code class="language-none">arrow(centerpos::Point, radius, startangle, endangle;
    linewidth = 1.0,
    arrowheadlength = 10,
    arrowheadangle = pi/8,
    decoration = 0.5,
    decorate = () -&gt; ())</code></pre><p>Draw a curved arrow, an arc centered at <code>centerpos</code> starting at <code>startangle</code> and ending at <code>endangle</code> with an arrowhead at the end. Angles are measured clockwise from the positive x-axis.</p><p>Arrows don&#39;t use the current linewidth setting (<code>setline()</code>); you can specify the linewidth.</p><p>The <code>decorate</code> keyword argument accepts a function that can execute code at locations on the arrow&#39;s shaft. The inherited graphic environment is centered at points on the curve between 0 and 1 given by scalar or vector <code>decoration</code>, and the x-axis is aligned with the direction of the curve at that point.</p></div></section><section><div><pre><code class="language-none">arrow(start::Point, C1::Point, C2::Point, finish::Point, action=:stroke;
    linewidth=1.0,
    arrowheadlength=10,
    arrowheadangle=pi/8,
    startarrow=false,
    finisharrow=true,
    decoration = 0.5,
    decorate = () -&gt; ()))</code></pre><p>Draw a Bezier curved arrow, from <code>start</code> to <code>finish</code>, with control points <code>C1</code> and <code>C2</code>. Arrow heads can be added/hidden by changing <code>startarrow</code> and <code>finisharrow</code> options.</p><p>The <code>decorate</code> keyword argument accepts a function that can execute code at locations on the arrow&#39;s shaft. The inherited graphic environment is centered at each point on the curve given by scalar or vector <code>decoration</code>, and the x-axis is aligned with the direction of the curve at that point (TODO - more or less - is it actually correct?).</p></div></section><section><div><pre><code class="language-none">arrow(start::Point, finish::Point, height::Vector, action=:stroke;
    keyword arguments...)</code></pre><p>Draw a Bézier arrow between <code>start</code> and <code>finish</code>, with control points defined to fit in an imaginary box defined by the two supplied <code>height</code> values (see <code>bezierfrompoints()</code>). If the height values are different signs, the arrow will change direction on its way.</p><p>Keyword arguments are the same as <a href="#Luxor.arrow"><code>arrow(pt1, pt2, pt3, pt4)</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-none">arrow(pts[1], pts[end], [15, 15],
    decoration = 0.5,
    decorate = () -&gt; text(string(pts[1])))</code></pre></div></section></article><h2 id="Arcs-and-curves"><a class="docs-heading-anchor" href="#Arcs-and-curves">Arcs and curves</a><a id="Arcs-and-curves-1"></a><a class="docs-heading-anchor-permalink" href="#Arcs-and-curves" title="Permalink"></a></h2><p>There are a few standard arc-drawing commands, such as <code>curve()</code>, <code>arc()</code>, <code>carc()</code>, and <code>arc2r()</code>. Because these are often used when building complex paths, they usually add arc sections to the current path. To construct a sequence of lines and arcs, use the <code>:path</code> action, followed by a final <code>:stroke</code> or similar.</p><p><code>curve()</code> constructs Bézier curves from control points:</p><pre><code class="language-julia">setline(.5)
pt1 = Point(0, -125)
pt2 = Point(200, 125)
pt3 = Point(200, -125)

label.(string.([&quot;O&quot;, &quot;control point 1&quot;, &quot;control point 2&quot;, &quot;control point 3&quot;]),
    :e,
    [O, pt1, pt2, pt3])

sethue(&quot;red&quot;)
map(p -&gt; circle(p, 4, :fill), [O, pt1, pt2, pt3])

line(O, pt1, :stroke)
line(pt2, pt3, :stroke)

sethue(&quot;black&quot;)
setline(3)

# start a path
move(O)
curve(pt1, pt2, pt3) #  add to current path
strokepath()</code></pre><p><img src="../assets/figures/curve.png" alt="curve"/></p><p><code>arc2r()</code> draws a circular arc centered at a point that passes through two other points:</p><pre><code class="language-julia">tiles = Tiler(700, 200, 1, 6)
for (pos, n) in tiles
    c1, pt2, pt3 = ngon(pos, rand(10:50), 3, rand(0:pi/12:2pi), vertices=true)
    sethue(&quot;black&quot;)
    map(pt -&gt; circle(pt, 4, :fill), [c1, pt3])
    sethue(&quot;red&quot;)
    circle(pt2, 4, :fill)
    randomhue()
    arc2r(c1, pt2, pt3, :stroke)
end</code></pre><p><img src="../assets/figures/arc2r.png" alt="arc"/></p><p><code>arc2sagitta()</code> and <code>carc2sagitta()</code> make circular arcs based on two points and the sagitta (the maximum height from the chord).</p><pre><code class="language-julia">pt1 = Point(-100, 0)
pt2 = Point(100, 0)
for n in reverse(range(1, length=7, stop=120))
    sethue(&quot;red&quot;)
    rule(Point(0, -n))
    sethue(LCHab(70, 80, rescale(n, 120, 1, 0, 359)))
    pt, r = arc2sagitta(pt1, pt2, n, :fillpreserve)
    sethue(&quot;black&quot;)
    strokepath()
    text(string(round(n)), O + (120, -n))
end
circle.((pt1, pt2), 5, :fill)</code></pre><p><img src="../assets/figures/arc2sagitta.svg" alt="arc"/></p><article class="docstring"><header><a class="docstring-binding" id="Luxor.arc" href="#Luxor.arc"><code>Luxor.arc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">arc(xc, yc, radius, angle1, angle2, action=:none)</code></pre><p>Add an arc to the current path from <code>angle1</code> to <code>angle2</code> going clockwise, centered at xc, yc.</p><p>Angles are defined relative to the x-axis, positive clockwise.</p></div></section><section><div><pre><code class="language-none">arc(centerpoint::Point, radius, angle1, angle2, action=:none)</code></pre><p>Add an arc to the current path from <code>angle1</code> to <code>angle2</code> going clockwise, centered at <code>centerpoint</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.arc2r" href="#Luxor.arc2r"><code>Luxor.arc2r</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">  arc2r(c1::Point, p2::Point, p3::Point, action=:none)</code></pre><p>Add a circular arc centered at <code>c1</code> that starts at <code>p2</code> and ends at <code>p3</code>, going clockwise, to the current path.</p><p><code>c1</code>-<code>p2</code> really determines the radius. If <code>p3</code> doesn&#39;t lie on the circular path,  it will be used only as an indication of the arc&#39;s length, rather than its position.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.carc" href="#Luxor.carc"><code>Luxor.carc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">carc(xc, yc, radius, angle1, angle2, action=:none)</code></pre><p>Add an arc to the current path from <code>angle1</code> to <code>angle2</code> going counterclockwise, centered at <code>xc</code>/<code>yc</code>.</p><p>Angles are defined relative to the x-axis, positive clockwise.</p></div></section><section><div><pre><code class="language-none">carc(centerpoint::Point, radius, angle1, angle2, action=:none)</code></pre><p>Add an arc centered at <code>centerpoint</code> to the current path from <code>angle1</code> to <code>angle2</code>, going counterclockwise.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.carc2r" href="#Luxor.carc2r"><code>Luxor.carc2r</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">carc2r(c1::Point, p2::Point, p3::Point, action=:none)</code></pre><p>Add a circular arc centered at <code>c1</code> that starts at <code>p2</code> and ends at <code>p3</code>, going counterclockwise, to the current path.</p><p><code>c1</code>-<code>p2</code> really determines the radius. If <code>p3</code> doesn&#39;t lie on the circular path, it will be used only as an indication of the arc&#39;s length, rather than its position.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.arc2sagitta" href="#Luxor.arc2sagitta"><code>Luxor.arc2sagitta</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">arc2sagitta(p1::Point, p2::Point, s, action=:none)</code></pre><p>Make a clockwise arc starting at <code>p1</code> and ending at <code>p2</code> that reaches a height of <code>s</code>, the sagitta, at the middle. Might append to current path...</p><p>Return tuple of the center point and the radius of the arc.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.carc2sagitta" href="#Luxor.carc2sagitta"><code>Luxor.carc2sagitta</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">carc2sagitta(p1::Point, p2::Point, s, action=:none)</code></pre><p>Make a counterclockwise arc starting at <code>p1</code> and ending at <code>p2</code> that reaches a height of <code>s</code>, the sagitta, at the middle. Might append to current path...</p><p>Return tuple of center point and radius of arc.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.curve" href="#Luxor.curve"><code>Luxor.curve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">curve(x1, y1, x2, y2, x3, y3)
curve(p1, p2, p3)</code></pre><p>Add a Bézier curve.</p><p>The spline starts at the current position, finishing at <code>x3/y3</code> (<code>p3</code>), following two control points <code>x1/y1</code> (<code>p1</code>) and <code>x2/y2</code> (<code>p2</code>).</p></div></section></article><h2 id="More-curved-shapes:-sectors,-spirals,-and-squircles"><a class="docs-heading-anchor" href="#More-curved-shapes:-sectors,-spirals,-and-squircles">More curved shapes: sectors, spirals, and squircles</a><a id="More-curved-shapes:-sectors,-spirals,-and-squircles-1"></a><a class="docs-heading-anchor-permalink" href="#More-curved-shapes:-sectors,-spirals,-and-squircles" title="Permalink"></a></h2><p>A sector (technically an &quot;annular sector&quot;) has an inner and outer radius, as well as start and end angles.</p><pre><code class="language-julia">sethue(&quot;tomato&quot;)
sector(50, 90, π/2, 0, :fill)
sethue(&quot;olive&quot;)
sector(Point(O.x + 200, O.y), 50, 90, 0, π/2, :fill)</code></pre><p><img src="../assets/figures/sector.png" alt="sector"/></p><p>You can also supply a value for a corner radius. The same sector is drawn but with rounded corners.</p><pre><code class="language-julia">sethue(&quot;tomato&quot;)
sector(50, 90, π/2, 0, 15, :fill)
sethue(&quot;olive&quot;)
sector(Point(O.x + 200, O.y), 50, 90, 0, π/2, 15, :fill)</code></pre><p><img src="../assets/figures/sectorrounded.png" alt="sector"/></p><article class="docstring"><header><a class="docstring-binding" id="Luxor.sector" href="#Luxor.sector"><code>Luxor.sector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sector(centerpoint::Point, innerradius, outerradius, startangle, endangle, action:none)</code></pre><p>Draw an annular sector centered at <code>centerpoint</code>.</p></div></section><section><div><pre><code class="language-none">sector(innerradius::Real, outerradius::Real, startangle::Real, endangle::Real,
   action::Symbol=:none)</code></pre><p>Draw an annular sector centered at the origin.</p></div></section><section><div><pre><code class="language-none">sector(centerpoint::Point, innerradius, outerradius, startangle, endangle,
    cornerradius, action:none)</code></pre><p>Draw an annular sector with rounded corners, basically a bent sausage shape, centered at <code>centerpoint</code>.</p><p>TODO: The results aren&#39;t 100% accurate at the moment. There are small discontinuities where the curves join.</p><p>The cornerradius is reduced from the supplied value if neceesary to prevent overshoots.</p></div></section><section><div><pre><code class="language-none">sector(innerradius::Real, outerradius::Real, startangle::Real, endangle::Real,
   cornerradius::Real, action::Symbol=:none)</code></pre><p>Draw an annular sector with rounded corners, centered at the current origin.</p></div></section></article><p>A pie (or wedge) has start and end angles.</p><pre><code class="language-julia">pie(0, 0, 100, π/2, π, :fill)</code></pre><p><img src="../assets/figures/pie.png" alt="pie"/></p><article class="docstring"><header><a class="docstring-binding" id="Luxor.pie" href="#Luxor.pie"><code>Luxor.pie</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pie(x, y, radius, startangle, endangle, action=:none)</code></pre><p>Draw a pie shape centered at <code>x</code>/<code>y</code>. Angles start at the positive x-axis and are measured clockwise.</p></div></section><section><div><pre><code class="language-none">pie(centerpoint, radius, startangle, endangle, action=:none)</code></pre><p>Draw a pie shape centered at <code>centerpoint</code>.</p><p>Angles start at the positive x-axis and are measured clockwise.</p></div></section><section><div><pre><code class="language-none">pie(radius, startangle, endangle, action=:none)</code></pre><p>Draw a pie shape centered at the origin</p></div></section></article><p>To construct spirals, use the <code>spiral()</code> function. These can be drawn directly, or used as polygons. The default is to draw Archimedean (non-logarithmic) spirals.</p><pre><code class="language-julia">spiraldata = [
  (-2, &quot;Lituus&quot;,      50),
  (-1, &quot;Hyperbolic&quot;, 100),
  ( 1, &quot;Archimedes&quot;,   1),
  ( 2, &quot;Fermat&quot;,       5)]

grid = GridRect(O - (200, 0), 130, 50)

for aspiral in spiraldata
    @layer begin
        translate(nextgridpoint(grid))
        spiral(last(aspiral), first(aspiral), period=20π, :stroke)
        label(aspiral[2], :S, offset=100)
    end
end</code></pre><p><img src="../assets/figures/spiral.png" alt="spiral"/></p><p>Use the <code>log=true</code> option to draw logarithmic (Bernoulli or Fibonacci) spirals.</p><pre><code class="language-julia">spiraldata = [
    (10,  0.05),
    (4,   0.10),
    (0.5, 0.17)]

grid = GridRect(O - (200, 0), 175, 50)
for aspiral in spiraldata
    @layer begin
        translate(nextgridpoint(grid))
        spiral(first(aspiral), last(aspiral), log=true, period=10π, :stroke)
        label(string(aspiral), :S, offset=100)
    end
end</code></pre><p>Modify the <code>stepby</code> and <code>period</code> parameters to taste, or collect the vertices for further processing.</p><p><img src="../assets/figures/spiral-log.png" alt="spiral log"/></p><article class="docstring"><header><a class="docstring-binding" id="Luxor.spiral" href="#Luxor.spiral"><code>Luxor.spiral</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">spiral(a, b, action::Symbol=:none;
                 stepby = 0.01,
                 period = 4pi,
                 vertices = false,
                 log=false)</code></pre><p>Make a spiral. The two primary parameters <code>a</code> and <code>b</code> determine the start radius, and the tightness.</p><p>For linear spirals (<code>log=false</code>), <code>b</code> values are:</p><pre><code class="language-none">lituus: -2

hyperbolic spiral: -1

Archimedes&#39; spiral: 1

Fermat&#39;s spiral: 2</code></pre><p>For logarithmic spirals (<code>log=true</code>):</p><pre><code class="language-none">golden spiral: b = ln(phi)/ (pi/2) (about 0.30)</code></pre><p>Values of <code>b</code> around 0.1 produce tighter, staircase-like spirals.</p></div></section></article><p>A <em>squircle</em> is a cross between a square and a circle. You can adjust the squariness and circularity of it to taste by supplying a value for the root (keyword <code>rt</code>):</p><pre><code class="language-julia">setline(2)
tiles = Tiler(600, 250, 1, 3)
for (pos, n) in tiles
    sethue(&quot;lavender&quot;)
    squircle(pos, 80, 80, rt=[0.3, 0.5, 0.7][n], :fillpreserve)
    sethue(&quot;grey20&quot;)
    strokepath()
    textcentered(&quot;rt = $([0.3, 0.5, 0.7][n])&quot;, pos)
end</code></pre><p><img src="../assets/figures/squircle.png" alt="squircles"/></p><article class="docstring"><header><a class="docstring-binding" id="Luxor.squircle" href="#Luxor.squircle"><code>Luxor.squircle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">squircle(center::Point, hradius, vradius, action=:none;
    rt = 0.5, stepby = pi/40, vertices=false)</code></pre><p>Make a squircle or superellipse (basically a rectangle with rounded corners). Specify the center position, horizontal radius (distance from center to a side), and vertical radius (distance from center to top or bottom):</p><p>The root (<code>rt</code>) option defaults to 0.5, and gives an intermediate shape. Values less than 0.5 make the shape more rectangular. Values above make the shape more round. The horizontal and vertical radii can be different.</p></div></section></article><p>To draw a simple rounded rectangle, supply a corner radius:</p><pre><code class="language-julia">setline(4)
box(O, 200, 150, 10, :stroke)</code></pre><p><img src="../assets/figures/round-rect-1.png" alt="rounded rect 1"/></p><p>Or you could smooth the corners of a box, like so:</p><pre><code class="language-julia">setline(4)
polysmooth(box(O, 200, 150, vertices=true), 10, :stroke)</code></pre><p><img src="../assets/figures/round-rect.png" alt="rounded rect"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../basics/">« Basic concepts</a><a class="docs-footer-nextpage" href="../moregraphics/">More graphics »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 12 July 2020 17:29">Sunday 12 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
