<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Polygons and paths · Luxor</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="Luxor logo"/></a><h1>Luxor</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction to Luxor</a></li><li><a class="toctext" href="examples.html">A few examples</a></li><li><a class="toctext" href="basics.html">Basic concepts</a></li><li><a class="toctext" href="simplegraphics.html">Simple graphics</a></li><li><a class="toctext" href="colors-styles.html">Colors and styles</a></li><li class="current"><a class="toctext" href="polygons.html">Polygons and paths</a><ul class="internal"><li><a class="toctext" href="#Regular-polygons-(&quot;ngons&quot;)-1">Regular polygons (&quot;ngons&quot;)</a></li><li><a class="toctext" href="#Stars-1">Stars</a></li><li><a class="toctext" href="#Polygons-1">Polygons</a></li><li><a class="toctext" href="#Converting-paths-to-polygons-1">Converting paths to polygons</a></li><li><a class="toctext" href="#Polygons-to-Bézier-paths-and-back-again-1">Polygons to Bézier paths and back again</a></li><li><a class="toctext" href="#Polygon-information-1">Polygon information</a></li></ul></li><li><a class="toctext" href="text.html">Text</a></li><li><a class="toctext" href="transforms.html">Transforms and matrices</a></li><li><a class="toctext" href="clipping.html">Clipping</a></li><li><a class="toctext" href="images.html">Images</a></li><li><a class="toctext" href="turtle.html">Turtle graphics</a></li><li><a class="toctext" href="animation.html">Animation</a></li><li><a class="toctext" href="moreexamples.html">More examples</a></li><li><a class="toctext" href="functionindex.html">Index</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="polygons.html">Polygons and paths</a></li></ul><a class="edit-page" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/docs/src/polygons.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Polygons and paths</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Polygons-and-paths-1" href="#Polygons-and-paths-1">Polygons and paths</a></h1><h2><a class="nav-anchor" id="Regular-polygons-(&quot;ngons&quot;)-1" href="#Regular-polygons-(&quot;ngons&quot;)-1">Regular polygons (&quot;ngons&quot;)</a></h2><p>A polygon is an array of points. The points can be joined with straight lines.</p><p>You can make regular polygons — from triangles, pentagons, hexagons, septagons, heptagons, octagons, nonagons, decagons, and on-and-on-agons — with <code>ngon()</code>.</p><p><img src="assets/figures/n-gon.png" alt="n-gons"/></p><pre><code class="language-julia">using Luxor, Colors
Drawing(1200, 1400)

origin()
cols = diverging_palette(60, 120, 20) # hue 60 to hue 120
background(cols[1])
setopacity(0.7)
setline(2)

# circumradius of 500
ngon(0, 0, 500, 8, 0, :clip)

for y in -500:50:500
    for x in -500:50:500
        setcolor(cols[rand(1:20)])
        ngon(x, y, rand(20:25), rand(3:12), 0, :fill)
        setcolor(cols[rand(1:20)])
        ngon(x, y, rand(10:20), rand(3:12), 0, :stroke)
    end
end

finish()
preview()</code></pre><p>If you want to specify the side length rather than the circumradius, use <code>ngonside()</code>.</p><div><pre><code class="language-julia">for i in 20:-1:3
    sethue(i/20, 0.5, 0.7)
    ngonside(O, 75, i, 0, :fill)
    sethue(&quot;black&quot;)
    ngonside(O, 75, i, 0, :stroke)
end</code></pre></div><p><img src="assets/figures/ngonside.png" alt="stars"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.ngon" href="#Luxor.ngon"><code>Luxor.ngon</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ngon(x, y, radius, sides=5, orientation=0, action=:nothing;
    vertices=false, reversepath=false)</code></pre><p>Find the vertices of a regular n-sided polygon centered at <code>x</code>, <code>y</code> with circumradius <code>radius</code>.</p><p><code>ngon()</code> draws the shapes: if you just want the raw points, use keyword argument <code>vertices=true</code>, which returns the array of points instead. Compare:</p><pre><code class="language-julia">ngon(0, 0, 4, 4, 0, vertices=true) # returns the polygon&#39;s points:

    4-element Array{Luxor.Point,1}:
    Luxor.Point(2.4492935982947064e-16,4.0)
    Luxor.Point(-4.0,4.898587196589413e-16)
    Luxor.Point(-7.347880794884119e-16,-4.0)
    Luxor.Point(4.0,-9.797174393178826e-16)</code></pre><p>whereas</p><pre><code class="language-none">ngon(0, 0, 4, 4, 0, :close) # draws a polygon</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/shapes.jl#L121-L145">source</a><br/><div><pre><code class="language-none">ngon(centerpos, radius, sides=5, orientation=0, action=:nothing;
    vertices=false,
    reversepath=false)</code></pre><p>Draw a regular polygon centered at point <code>centerpos</code>:</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/shapes.jl#L158-L164">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.ngonside" href="#Luxor.ngonside"><code>Luxor.ngonside</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ngonside(centerpoint::Point, sidelength::Real, sides::Int=5, orientation=0,
    action=:nothing; kwargs...)</code></pre><p>Draw a regular polygon centered at <code>centerpoint</code> with <code>sides</code> sides of length <code>sidelength</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/shapes.jl#L169-L174">source</a><br/></section><h2><a class="nav-anchor" id="Stars-1" href="#Stars-1">Stars</a></h2><p>Use <code>star()</code> to make a star. You can draw it immediately, or use the points it can create.</p><div><pre><code class="language-julia">tiles = Tiler(400, 300, 4, 6, margin=5)
for (pos, n) in tiles
    randomhue()
    star(pos, tiles.tilewidth/3, rand(3:8), 0.5, 0, :fill)
end</code></pre></div><p><img src="assets/figures/stars.png" alt="stars"/></p><p>The <code>ratio</code> determines the length of the inner radius compared with the outer.</p><div><pre><code class="language-julia">tiles = Tiler(500, 250, 1, 6, margin=10)
for (pos, n) in tiles
    star(pos, tiles.tilewidth/2, 5, rescale(n, 1, 6, 1, 0), 0, :stroke)
end</code></pre></div><p><img src="assets/figures/star-ratios.png" alt="stars"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.star" href="#Luxor.star"><code>Luxor.star</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">star(xcenter, ycenter, radius, npoints=5, ratio=0.5, orientation=0, action=:nothing;
    vertices = false,
    reversepath=false)</code></pre><p>Make a star. <code>ratio</code> specifies the height of the smaller radius of the star relative to the larger.</p><p>Use <code>vertices=true</code> to return the vertices of a star instead of drawing it.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/shapes.jl#L181-L190">source</a><br/><div><pre><code class="language-none">star(center, radius, npoints=5, ratio=0.5, orientation=0, action=:nothing;
    vertices = false, reversepath=false)</code></pre><p>Draw a star centered at a position:</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/shapes.jl#L214-L219">source</a><br/></section><h2><a class="nav-anchor" id="Polygons-1" href="#Polygons-1">Polygons</a></h2><p>Use <code>poly()</code> to draw lines connecting the points or just fill the area:</p><div><pre><code class="language-julia">tiles = Tiler(600, 250, 1, 2, margin=20)
tile1, tile2 = collect(tiles)

randompoints = [Point(rand(-100:100), rand(-100:100)) for i in 1:10]

gsave()
translate(tile1[1])
poly(randompoints, :stroke)
grestore()

gsave()
translate(tile2[1])
poly(randompoints, :fill)
grestore()</code></pre></div><p><img src="assets/figures/simplepoly.png" alt="simple poly"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.poly" href="#Luxor.poly"><code>Luxor.poly</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Draw a polygon.</p><pre><code class="language-none">poly(pointlist::Array, action = :nothing;
    close=false,
    reversepath=false)</code></pre><p>A polygon is an Array of Points. By default <code>poly()</code> doesn&#39;t close or fill the polygon, to allow for clipping.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/polygons.jl#L3-L12">source</a><br/></section><p>A polygon can contain holes. The <code>reversepath</code> keyword changes the direction of the polygon. The following piece of code uses <code>ngon()</code> to make and draw two paths, the second forming a hole in the first, to make a hexagonal bolt shape:</p><div><pre><code class="language-julia">setline(5)
sethue(&quot;gold&quot;)
line(Point(-200, 0), Point(200, 0), :stroke)
sethue(&quot;orchid4&quot;)
ngon(0, 0, 60, 6, 0, :path)
newsubpath()
ngon(0, 0, 40, 6, 0, :path, reversepath=true)
fillstroke()</code></pre></div><p><img src="assets/figures/holes.png" alt="holes"/></p><p>The <code>prettypoly()</code> function can place graphics at each vertex of a polygon. After the polygon action, the supplied <code>vertexfunction</code> function is evaluated at each vertex. For example, to mark each vertex of a polygon with a randomly-colored circle:</p><div><pre><code class="language-julia">apoly = star(O, 70, 7, 0.6, 0, vertices=true)
prettypoly(apoly, :fill, () -&gt;
        begin
            randomhue()
            circle(O, 10, :fill)
        end,
    close=true)</code></pre></div><p><img src="assets/figures/prettypolybasic.png" alt="prettypoly"/></p><p>An optional keyword argument <code>vertexlabels</code> lets you pass a function that can number each vertex. The function can use two arguments, the current vertex number, and the total number of points in the polygon:</p><div><pre><code class="language-julia">apoly = star(O, 80, 5, 0.6, 0, vertices=true)
prettypoly(apoly,
    :stroke,
    vertexlabels = (n, l) -&gt; (text(string(n, &quot; of &quot;, l), halign=:center)),
    close=true)</code></pre></div><p><img src="assets/figures/prettypolyvertex.png" alt="prettypoly"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.prettypoly" href="#Luxor.prettypoly"><code>Luxor.prettypoly</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">prettypoly(points, action=:nothing, vertexfunction = () -&gt; circle(O, 2, :stroke);
    close=false,
    reversepath=false,
    vertexlabels = (n, l) -&gt; ()
    )</code></pre><p>Draw the polygon defined by <code>points</code>, possibly closing and reversing it, using the current parameters, and then evaluate the <code>vertexfunction</code> function at every vertex of the polygon.</p><p>The default vertexfunction draws a 2 pt radius circle.</p><p>To mark each vertex of a polygon with a randomly colored filled circle:</p><pre><code class="language-none">p = star(O, 70, 7, 0.6, 0, vertices=true)
prettypoly(p, :fill, () -&gt;
    begin
        randomhue()
        circle(O, 10, :fill)
    end,
    close=true)</code></pre><p>The optional keyword argument <code>vertexlabels</code> lets you supply a function with two arguments that can access the current vertex number and the total number of vertices at each vertex. For example, you can label the vertices of a triangle &quot;1 of 3&quot;, &quot;2 of 3&quot;, and &quot;3 of 3&quot; using:</p><pre><code class="language-none">prettypoly(triangle, :stroke,
    vertexlabels = (n, l) -&gt; (text(string(n, &quot; of &quot;, l))))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/polygons.jl#L277-L306">source</a><br/></section><p>Recursive decoration is possible:</p><div><pre><code class="language-julia">decorate(pos, p, level) = begin
    if level &lt; 4
        randomhue();
        scale(0.25, 0.25)
        prettypoly(p, :fill, () -&gt; decorate(pos, p, level+1), close=true)
    end
end

apoly = star(O, 100, 7, 0.6, 0, vertices=true)
prettypoly(apoly, :fill, () -&gt; decorate(O, apoly, 1), close=true)</code></pre></div><p><img src="assets/figures/prettypolyrecursive.png" alt="prettypoly"/></p><p>Polygons can be simplified using the Douglas-Peucker algorithm (non-recursive version), via <code>simplify()</code>.</p><div><pre><code class="language-julia">sincurve = [Point(6x, 80sin(x)) for x in -5pi:pi/20:5pi]
prettypoly(collect(sincurve), :stroke,
    () -&gt; begin
            sethue(&quot;red&quot;)
            circle(O, 3, :fill)
          end)
text(string(&quot;number of points: &quot;, length(collect(sincurve))), 0, 100)
translate(0, 200)
simplercurve = simplify(collect(sincurve), 0.5)
prettypoly(simplercurve, :stroke,
    () -&gt; begin
            sethue(&quot;red&quot;)
            circle(O, 3, :fill)
          end)
text(string(&quot;number of points: &quot;, length(simplercurve)), 0, 100)</code></pre></div><p><img src="assets/figures/simplify.png" alt="simplify"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.simplify" href="#Luxor.simplify"><code>Luxor.simplify</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Simplify a polygon:</p><pre><code class="language-none">simplify(pointlist::Array, detail=0.1)</code></pre><p><code>detail</code> is the smallest permitted distance between two points in pixels.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/polygons.jl#L174-L180">source</a><br/></section><p>The <code>isinside()</code> function returns true if a point is inside a polygon.</p><div><pre><code class="language-julia">setline(0.5)
apolygon = star(O, 100, 5, 0.5, 0, vertices=true)
for n in 1:10000
    apoint = randompoint(Point(-200, -150), Point(200, 150))
    randomhue()
    isinside(apoint, apolygon) ? circle(apoint, 3, :fill) : circle(apoint, .5, :stroke)
end</code></pre></div><p><img src="assets/figures/isinside.png" alt="isinside"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.isinside" href="#Luxor.isinside"><code>Luxor.isinside</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isinside(p, pol)</code></pre><p>Is a point <code>p</code> inside a polygon <code>pol</code>? Returns true or false.</p><p>This is an implementation of the Hormann-Agathos (2001) Point in Polygon algorithm</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/polygons.jl#L185-L191">source</a><br/></section><p>You can use <code>randompoint()</code> and <code>randompointarray()</code> to create a random Point or list of Points.</p><div><pre><code class="language-julia">pt1 = Point(-100, -100)
pt2 = Point(100, 100)

sethue(&quot;gray80&quot;)
map(pt -&gt; circle(pt, 6, :fill), (pt1, pt2))
box(pt1, pt2, :stroke)

sethue(&quot;red&quot;)
circle(randompoint(pt1, pt2), 7, :fill)

sethue(&quot;blue&quot;)
map(pt -&gt; circle(pt, 2, :fill), randompointarray(pt1, pt2, 100))</code></pre></div><p><img src="assets/figures/randompoints.png" alt="isinside"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.randompoint" href="#Luxor.randompoint"><code>Luxor.randompoint</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">randompoint(lowpt, highpt)</code></pre><p>Return a random point somewhere inside the rectangle defined by the two points.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/point.jl#L163-L167">source</a><br/><div><pre><code class="language-none">randompoint(lowx, lowy, highx, highy)</code></pre><p>Return a random point somewhere inside a rectangle defined by the four values.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/point.jl#L172-L176">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.randompointarray" href="#Luxor.randompointarray"><code>Luxor.randompointarray</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">randompointarray(lowpt, highpt, n)</code></pre><p>Return an array of <code>n</code> random points somewhere inside the rectangle defined by two points.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/point.jl#L181-L185">source</a><br/><div><pre><code class="language-none">randompointarray(lowx, lowy, highx, highy, n)</code></pre><p>Return an array of <code>n</code> random points somewhere inside the rectangle defined by the four coordinates.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/point.jl#L194-L198">source</a><br/></section><p>There are some experimental polygon functions. These don&#39;t work well for polygons that aren&#39;t simple or where the sides intersect each other, but they sometimes do a reasonable job. For example, here&#39;s <code>polysplit()</code>:</p><div><pre><code class="language-julia">s = squircle(O, 60, 60, vertices=true)
pt1 = Point(0, -120)
pt2 = Point(0, 120)
line(pt1, pt2, :stroke)
poly1, poly2 = polysplit(s, pt1, pt2)
randomhue()
poly(poly1, :fill)
randomhue()
poly(poly2, :fill)</code></pre></div><p><img src="assets/figures/polysplit.png" alt="polysplit"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.polysplit" href="#Luxor.polysplit"><code>Luxor.polysplit</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">polysplit(p, p1, p2)</code></pre><p>Split a polygon into two where it intersects with a line. It returns two polygons:</p><pre><code class="language-none">(poly1, poly2)</code></pre><p>This doesn&#39;t always work, of course. For example, a polygon the shape of the letter &quot;E&quot; might end up being divided into more than two parts.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/polygons.jl#L230-L239">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.polysortbydistance" href="#Luxor.polysortbydistance"><code>Luxor.polysortbydistance</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Sort a polygon by finding the nearest point to the starting point, then the nearest point to that, and so on.</p><pre><code class="language-none">polysortbydistance(p, starting::Point)</code></pre><p>You can end up with convex (self-intersecting) polygons, unfortunately.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/polygons.jl#L115-L122">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.polysortbyangle" href="#Luxor.polysortbyangle"><code>Luxor.polysortbyangle</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Sort the points of a polygon into order. Points are sorted according to the angle they make with a specified point.</p><pre><code class="language-none">polysortbyangle(pointlist::Array, refpoint=minimum(pointlist))</code></pre><p>The <code>refpoint</code> can be chosen, but the minimum point is usually OK too:</p><pre><code class="language-none">polysortbyangle(parray, polycentroid(parray))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/polygons.jl#L97-L106">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.polycentroid" href="#Luxor.polycentroid"><code>Luxor.polycentroid</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Find the centroid of simple polygon.</p><pre><code class="language-none">polycentroid(pointlist)</code></pre><p>Returns a point. This only works for simple (non-intersecting) polygons.</p><p>You could test the point using <code>isinside()</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/polygons.jl#L49-L57">source</a><br/></section><h3><a class="nav-anchor" id="Smoothing-polygons-1" href="#Smoothing-polygons-1">Smoothing polygons</a></h3><p>Because polygons can have sharp corners, the experimental <code>polysmooth()</code> function attempts to insert arcs at the corners and draw the result.</p><p>The original polygon is shown in red; the smoothed polygon is shown on top:</p><div><pre><code class="language-julia">tiles = Tiler(600, 250, 1, 5, margin=10)
for (pos, n) in tiles
    p = star(pos, tiles.tilewidth/2 - 2, 5, 0.3, 0, vertices=true)
    setdash(&quot;dot&quot;)
    sethue(&quot;red&quot;)
    prettypoly(p, close=true, :stroke)
    setdash(&quot;solid&quot;)
    sethue(&quot;black&quot;)
    polysmooth(p, n * 2, :fill)
end</code></pre></div><p><img src="assets/figures/polysmooth.png" alt="polysmooth"/></p><p>The final polygon shows that you can get unexpected results if you attempt to smooth corners by more than the possible amount. The <code>debug=true</code> option draws the circles if you want to find out what&#39;s going wrong, or if you want to explore the effect in more detail.</p><div><pre><code class="language-julia">p = star(O, 60, 5, 0.35, 0, vertices=true)
setdash(&quot;dot&quot;)
sethue(&quot;red&quot;)
prettypoly(p, close=true, :stroke)
setdash(&quot;solid&quot;)
sethue(&quot;black&quot;)
polysmooth(p, 40, :fill, debug=true)</code></pre></div><p><img src="assets/figures/polysmooth-pathological.png" alt="polysmooth"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.polysmooth" href="#Luxor.polysmooth"><code>Luxor.polysmooth</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">polysmooth(points::Array, radius, action=:action; debug=false)</code></pre><p>Make a closed path from the <code>points</code> and round the corners by making them arcs with the given radius. Execute the action when finished.</p><p>The arcs are sometimes different sizes: if the given radius is bigger than the length of the shortest side, the arc can&#39;t be drawn at its full radius and is therefore drawn as large as possible (as large as the shortest side allows).</p><p>The <code>debug</code> option also draws the construction circles at each corner.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/polygons.jl#L420-L431">source</a><br/></section><h3><a class="nav-anchor" id="Offsetting-polygons-1" href="#Offsetting-polygons-1">Offsetting polygons</a></h3><p>The experimental <code>offsetpoly()</code> function constructs an outline polygon outside or inside an existing polygon. In the following example, the dotted red polygon is the original, the black polygons have positive offsets and surround the original, the cyan polygons have negative offsets and run inside the original. Use <code>poly()</code> to draw the result returned by <code>offsetpoly()</code>.</p><div><pre><code class="language-julia">p = star(O, 45, 5, 0.5, 0, vertices=true)
sethue(&quot;red&quot;)
setdash(&quot;dot&quot;)
poly(p, :stroke, close=true)
setdash(&quot;solid&quot;)
sethue(&quot;black&quot;)

poly(offsetpoly(p, 20), :stroke, close=true)
poly(offsetpoly(p, 25), :stroke, close=true)
poly(offsetpoly(p, 30), :stroke, close=true)
poly(offsetpoly(p, 35), :stroke, close=true)

sethue(&quot;darkcyan&quot;)

poly(offsetpoly(p, -10), :stroke, close=true)
poly(offsetpoly(p, -15), :stroke, close=true)
poly(offsetpoly(p, -20), :stroke, close=true)</code></pre></div><p><img src="assets/figures/polyoffset-simple.png" alt="offset poly"/></p><p>The function is intended for simple cases, and it can go wrong if pushed too far. Sometimes the offset distances can be larger than the polygon segments, and things will start to go wrong. In this example, the offset goes so far negative that the polygon overshoots the origin, becomes inverted and starts getting larger again.</p><p><img src="assets/figures/polygon-offset.gif" alt="offset poly problem"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.offsetpoly" href="#Luxor.offsetpoly"><code>Luxor.offsetpoly</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">offsetpoly(path::Array, d)</code></pre><p>Return a polygon that is offset from a polygon by <code>d</code> units.</p><p>The incoming set of points <code>path</code> is treated as a polygon, and another set of points is created, which form a polygon lying <code>d</code> units away from the source poly.</p><p>Polygon offsetting is a topic on which people have written PhD theses and published academic papers, so this short brain-dead routine will give good results for simple polygons up to a point (!). There are a number of issues to be aware of:</p><ul><li><p>very short lines tend to make the algorithm &#39;flip&#39; and produce larger lines</p></li><li><p>small polygons that are counterclockwise and larger offsets may make the new polygon appear the wrong side of the original</p></li><li><p>very sharp vertices will produce even sharper offsets, as the calculated intersection point veers off to infinity</p></li><li><p>duplicated adjacent points might cause the routine to scratch its head and wonder how to draw a line parallel to them</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/polygons.jl#L457-L479">source</a><br/></section><h3><a class="nav-anchor" id="Fitting-splines-1" href="#Fitting-splines-1">Fitting splines</a></h3><p>The experimental <code>polyfit()</code> function constructs a B-spline that follows the points approximately.</p><div><pre><code class="language-julia">pts = [Point(x, rand(-100:100)) for x in -280:30:280]
setopacity(0.7)
sethue(&quot;red&quot;)
prettypoly(pts, :none, () -&gt; circle(O, 5, :fill))
sethue(&quot;darkmagenta&quot;)
poly(polyfit(pts, 200), :stroke)</code></pre></div><p><img src="assets/figures/polyfit.png" alt="offset poly"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.polyfit" href="#Luxor.polyfit"><code>Luxor.polyfit</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">polyfit(plist::Array, npoints=30)</code></pre><p>Build a polygon that constructs a B-spine approximation to it. The resulting list of points makes a smooth path that runs between the first and last points.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/polygons.jl#L520-L525">source</a><br/></section><h2><a class="nav-anchor" id="Converting-paths-to-polygons-1" href="#Converting-paths-to-polygons-1">Converting paths to polygons</a></h2><p>You can convert the current path to an array of polygons, using <code>pathtopoly()</code>.</p><p>In the next example, the path consists of a number of paths, some of which are subpaths, which form the holes.</p><div><pre><code class="language-julia">textpath(&quot;get polygons from paths&quot;)
plist = pathtopoly()
for (n, pgon) in enumerate(plist)
    randomhue()
    prettypoly(pgon, :stroke, close=true)
    gsave()
    translate(0, 100)
    poly(polysortbyangle(pgon, polycentroid(pgon)), :stroke, close=true)
    grestore()
end</code></pre></div><p><img src="assets/figures/path-to-poly.png" alt="path to polygon"/></p><p>The <code>pathtopoly()</code> function calls <code>getpathflat()</code> to convert the current path to an array of polygons, with each curved section flattened to line segments.</p><p>The <code>getpath()</code> function gets the current path as an array of elements, lines, and unflattened curves.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.pathtopoly" href="#Luxor.pathtopoly"><code>Luxor.pathtopoly</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pathtopoly()</code></pre><p>Convert the current path to an array of polygons.</p><p>Returns an array of polygons.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/polygons.jl#L557-L563">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.getpath" href="#Luxor.getpath"><code>Luxor.getpath</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getpath()</code></pre><p>Get the current path and return a CairoPath object, which is an array of <code>element_type</code> and <code>points</code> objects. With the results you can step through and examine each entry. For example:</p><pre><code class="language-none">o = getpath()
for e in o
      if e.element_type == Cairo.CAIRO_PATH_MOVE_TO
          (x, y) = e.points
          move(x, y)
      elseif e.element_type == Cairo.CAIRO_PATH_LINE_TO
          (x, y) = e.points
          # straight lines
          line(x, y)
          strokepath()
          circle(x, y, 1, :stroke)
      elseif e.element_type == Cairo.CAIRO_PATH_CURVE_TO
          (x1, y1, x2, y2, x3, y3) = e.points
          # Bezier control lines
          circle(x1, y1, 1, :stroke)
          circle(x2, y2, 1, :stroke)
          circle(x3, y3, 1, :stroke)
          move(x, y)
          curve(x1, y1, x2, y2, x3, y3)
          strokepath()
          (x, y) = (x3, y3) # update current point
      elseif e.element_type == Cairo.CAIRO_PATH_CLOSE_PATH
          closepath()
      else
          error(&quot;unknown CairoPathEntry &quot; * repr(e.element_type))
          error(&quot;unknown CairoPathEntry &quot; * repr(e.points))
      end
  end</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/basics.jl#L486-L522">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.getpathflat" href="#Luxor.getpathflat"><code>Luxor.getpathflat</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getpathflat()</code></pre><p>Get the current path, like <code>getpath()</code> but flattened so that there are no Bézier curves.</p><p>Returns a CairoPath which is an array of <code>element_type</code> and <code>points</code> objects.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/basics.jl#L525-L531">source</a><br/></section><h2><a class="nav-anchor" id="Polygons-to-Bézier-paths-and-back-again-1" href="#Polygons-to-Bézier-paths-and-back-again-1">Polygons to Bézier paths and back again</a></h2><p>Use the <code>makebezierpath()</code> and <code>drawbezierpath()</code> functions to make and draw Bézier paths. A Bézier path is a sequence of Bézier curve segments; each curve segment is defined by four points: two end points and two control points. Bezier paths are slightly different from ordinary paths in that they don&#39;t contain straight line segments.</p><p><code>makebezierpath()</code> takes the points in a polygon and converts each line segment into a Bézier curve. <code>drawbezierpath()</code> draws the resulting sequence.</p><div><pre><code class="language-julia">pts = ngon(O, 150, 3, pi/6, vertices=true)
bezpath = makebezierpath(pts)
poly(pts, :stroke)
for (p1, c1, c2, p2) in bezpath[1:end-1]
    circle.([p1, p2], 4, :stroke)
    circle.([c1, c2], 2, :fill)
    line(p1, c1, :stroke)
    line(p2, c2, :stroke)
end
sethue(&quot;black&quot;)
setline(3)
drawbezierpath(bezpath, :stroke, close=false)</code></pre></div><p><img src="assets/figures/abezierpath.png" alt="path to polygon"/></p><div><pre><code class="language-julia">tiles = Tiler(600, 300, 1, 4, margin=20)
for (pos, n) in tiles
    @layer begin
        translate(pos)
        pts = polysortbyangle(
                randompointarray(
                    Point(-tiles.tilewidth/2, -tiles.tilewidth/2),
                    Point(tiles.tilewidth/2, tiles.tilewidth/2),
                    4))
        setopacity(0.7)
        sethue(&quot;black&quot;)
        prettypoly(pts, :stroke, close=true)
        randomhue()
        drawbezierpath(makebezierpath(pts), :fill)
    end
end</code></pre></div><p><img src="assets/figures/bezierpaths.png" alt="path to polygon"/></p><p>You can convert a Bézier path to a polygon (an array of points), using the <code>bezierpathtopoly()</code> function. This chops up the curves into a series of straight line segments. An optional <code>steps</code> keyword lets you specify how many line segments are used for each Bézier curve segment.</p><p>In this example, the grey star is first rendered as a Bézier path, then the Bézier path is converted to a polygon but offset by 20 units before being drawn.</p><div><pre><code class="language-julia">pgon = star(O, 250, 5, 0.6, 0, vertices=true)

@layer begin
 setgrey(0.5)
 setdash(&quot;dot&quot;)
 poly(pgon, :stroke, close=true)
 setline(5)
end

setline(4)

sethue(&quot;coral&quot;)
np = makebezierpath(pgon)
drawbezierpath(np, :stroke)

sethue(&quot;steelblue&quot;)
p = bezierpathtopoly(np, steps=3)
q1 = offsetpoly(p, 20)
prettypoly(q1, :stroke, close=true)</code></pre></div><p><img src="assets/figures/bezierpathtopoly.png" alt="path to polygon"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.makebezierpath" href="#Luxor.makebezierpath"><code>Luxor.makebezierpath</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">makebezierpath(pgon::Array; smoothing=1)</code></pre><p>Return a Bézier path that follows an array of points. The Bézier path is an array of tuples; each tuple contains the four points that make up a section of the path.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/bezierpath.jl#L36-L42">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.drawbezierpath" href="#Luxor.drawbezierpath"><code>Luxor.drawbezierpath</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">drawbezierpath(bezierpath, action=:none;
    close=true)</code></pre><p>Draw a Bézier path, and apply the action, such as <code>:none</code>, <code>:stroke</code>, <code>:fill</code>, etc. By default the path is closed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/bezierpath.jl#L57-L63">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.bezierpathtopoly" href="#Luxor.bezierpathtopoly"><code>Luxor.bezierpathtopoly</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bezierpathtopoly(bezierpath::Array{NTuple{4,Luxor.Point}}; steps=10)</code></pre><p>Convert a Bezier path (an array of Bezier segments, where each segment is a tuple of four points: anchor1, control1, control2, anchor2) to a polygon.</p><p>The <code>steps</code> optional keyword determines how many line sections are used for each path.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/bezierpath.jl#L144-L150">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.beziertopoly" href="#Luxor.beziertopoly"><code>Luxor.beziertopoly</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">beziertopoly(bpseg::NTuple{4,Luxor.Point}; steps=10)</code></pre><p>Convert a Bezier segment (a tuple of four points: anchor1, control1, control2, anchor2) to a polygon (an array of points).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/bezierpath.jl#L77-L81">source</a><br/></section><h2><a class="nav-anchor" id="Polygon-information-1" href="#Polygon-information-1">Polygon information</a></h2><p><code>polyperimeter</code> calculates the length of a polygon&#39;s perimeter.</p><div><pre><code class="language-julia">p = box(O, 50, 50, vertices=true)
poly(p, :stroke)
text(string(round(polyperimeter(p, closed=false))), O.x, O.y + 60)

translate(200, 0)

poly(p, :stroke, close=true)
text(string(round(polyperimeter(p, closed=true))), O.x, O.y + 60)</code></pre></div><p><img src="assets/figures/polyperimeter.png" alt="polyperimeter"/></p><p><code>polyportion()</code> and <code>polyremainder()</code> return part of a polygon depending on the fraction you supply. For example, <code>polyportion(p, 0.5)</code> returns the first half of polygon <code>p</code>, <code>polyremainder(p, .75)</code> returns the last quarter of it.</p><div><pre><code class="language-julia">p = ngon(O, 100, 7, 0, vertices=true)
poly(p, :stroke, close=true)
setopacity(0.75)

setline(20)
sethue(&quot;red&quot;)
poly(polyportion(p, 0.25), :stroke)

setline(10)
sethue(&quot;green&quot;)
poly(polyportion(p, 0.5), :stroke)

setline(5)
sethue(&quot;blue&quot;)
poly(polyportion(p, 0.75), :stroke)

setline(1)
circle(polyremainder(p, 0.75)[1], 5, :stroke)</code></pre></div><p><img src="assets/figures/polyportion.png" alt="polyportion"/></p><p><code>polydistances</code> returns an array of the accumulated side lengths of a polygon.</p><pre><code class="language-none">julia&gt; p = ngon(O, 100, 7, 0, vertices=true);
julia&gt; polydistances(p)
8-element Array{Real,1}:
   0.0000
  86.7767
 173.553
 260.33  
 347.107
 433.884
 520.66  
 607.437</code></pre><p><code>nearestindex</code> returns the index of the nearest index value, an array of distances made by polydistances, to the value, and the excess value.</p><h3><a class="nav-anchor" id="Area-of-polygon-1" href="#Area-of-polygon-1">Area of polygon</a></h3><p>Use <code>polyarea()</code> to find the area of a polygon. Of course, this only works for simple polygons; polygons that intersect themselves or have holes are not correctly processed.</p><div><pre><code class="language-julia">g = GridRect(O + (200, -200), 80, 20, 85)
text(&quot;#sides&quot;, nextgridpoint(g), halign=:right)
text(&quot;area&quot;, nextgridpoint(g), halign=:right)

for i in 20:-1:3
    sethue(i/20, 0.5, 1 - i/20)
    ngonside(O, 50, i, 0, :fill)
    sethue(&quot;grey40&quot;)
    ngonside(O, 50, i, 0, :stroke)
    p = ngonside(O, 50, i, 0, vertices=true)
    text(string(i), nextgridpoint(g), halign=:right)
    text(string(round(polyarea(p), 3)), nextgridpoint(g), halign=:right)
end</code></pre></div><p><img src="assets/figures/polyarea.png" alt="poly area"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.polyperimeter" href="#Luxor.polyperimeter"><code>Luxor.polyperimeter</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">polyperimeter(p::Array{Point, 1}; closed=true)</code></pre><p>Find the total length of the sides of polygon <code>p</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/polygons.jl#L610-L614">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.polyportion" href="#Luxor.polyportion"><code>Luxor.polyportion</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">polyportion(p::Array{Point, 1}, portion=0.5; closed=true, pdist=[])</code></pre><p>Return a portion of a polygon, starting at a value between 0.0 (the beginning) and 1.0 (the end). 0.5 returns the first half of the polygon, 0.25 the first quarter, 0.75 the first three quarters, and so on.</p><p>If you already have a list of the distances between each point in the polygon (the &quot;polydistances&quot;), you can pass them in <code>pdist</code>, otherwise they&#39;ll be calculated afresh, using <code>polydistances(p, closed=closed)</code>.</p><p>Use the complementary <code>polyremainder()</code> function to return the other part.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/polygons.jl#L638-L646">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.polydistances" href="#Luxor.polydistances"><code>Luxor.polydistances</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">polydistances(p::Array{Point, 1}; closed=true)</code></pre><p>Return an array of the cumulative lengths of a polygon.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/polygons.jl#L591-L595">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.nearestindex" href="#Luxor.nearestindex"><code>Luxor.nearestindex</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">nearestindex(polydistancearray, value)</code></pre><p>Return a tuple of the index of the largest value in <code>polydistancearray</code> less than <code>value</code>, and the difference value. Array is assumed to be sorted.</p><p>(Designed for use with <code>polydistances()</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/polygons.jl#L619-L626">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.polyarea" href="#Luxor.polyarea"><code>Luxor.polyarea</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">polyarea(p::Array)</code></pre><p>Find the area of a simple polygon. It works only for polygons that don&#39;t self-intersect.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/5e489a4b981fefaa39daa34d366d5d4d599a8e60/src/polygons.jl#L704-L709">source</a><br/></section><footer><hr/><a class="previous" href="colors-styles.html"><span class="direction">Previous</span><span class="title">Colors and styles</span></a><a class="next" href="text.html"><span class="direction">Next</span><span class="title">Text</span></a></footer></article></body></html>
