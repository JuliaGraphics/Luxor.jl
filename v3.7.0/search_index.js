var documenterSearchIndex = {"docs":
[{"location":"howto/snapshots/#Snapshots","page":"Snapshots","title":"Snapshots","text":"","category":"section"},{"location":"howto/snapshots/","page":"Snapshots","title":"Snapshots","text":"A snapshot is a view of the current Luxor drawing in its current state, before it's been closed via finish. You can take a snapshot, then continue drawing on the current drawing.","category":"page"},{"location":"howto/snapshots/","page":"Snapshots","title":"Snapshots","text":"note: Note\nYou can take a snapshot only for drawings created using the :rec (recording) format.","category":"page"},{"location":"howto/snapshots/","page":"Snapshots","title":"Snapshots","text":"The following code exports a series of snapshots made with snapshot, showing the state of the computation for different values of the stepby parameter. (This image is a composite of all the snapshots.)","category":"page"},{"location":"howto/snapshots/","page":"Snapshots","title":"Snapshots","text":"(Image: juliaset)","category":"page"},{"location":"howto/snapshots/","page":"Snapshots","title":"Snapshots","text":"using Luxor, ColorSchemes, Colors\n\nfunction julia(z, c, maxiter::Int64)\n    for n = 1:maxiter\n        abs(z) > 2 ? (return n) : z = z^3 + c\n    end\n    return maxiter\nend\n\nfunction drawjulia(c::Complex, pwidth, pheight;\n        klo = 0.0,\n        khi = 1.0,\n        cpos = Point(0, 0),\n        w = 4,\n        stepby=1,\n        maxiterations = 300)\n    xmin = cpos.x - w/2; ymin = cpos.y - w/2\n    xmax = cpos.x + w/2; ymax = cpos.y + w/2\n    lo = 10; hi = 2\n    for col = -pwidth/2:stepby:pwidth/2\n        for row = -pheight/2:stepby:pheight/2\n            imagex = rescale(col, -pwidth/2, pwidth/2, xmin, xmax)\n            imagey = rescale(row, -pheight/2, pheight/2, ymin, ymax)\n            pixelcolor = julia(complex(imagex, imagey), c, maxiterations)\n            if pixelcolor > hi\n                hi = pixelcolor\n            end\n            if pixelcolor < lo\n                lo = pixelcolor\n            end\n            s = rescale(pixelcolor, klo, khi)\n            a = slope(Point(row, col), O)\n            h, sa, l = getfield.(convert(HSL, get(ColorSchemes.inferno, s)), 1:3)\n            sethue(HSL(mod(180 + 360 * a/2π, 360), sa , 2l))\n            box(Point(row, -col), stepby,  stepby, :fillstroke)\n        end\n    end\n    sethue(\"white\")\n    text(\"$(stepby)\", boxbottomcenter(BoundingBox()) + (0, -20), halign=:center)\n    snapshot(fname = \"/tmp/temp-$(stepby).png\")\n    return lo, hi\nend\n\nfunction main()\n    w = h = 500\n    Drawing(w, h, :rec)\n    fontsize(20)\n    fontface(\"JuliaMono-Bold\")\n    origin()\n    circle(O, w/2, :clip)\n    for s in vcat(50:-5:1,1)\n        l, h = drawjulia(-0.5368 + 0.0923im, w, w, maxiterations = 250,\n            w=3, stepby=s, klo=1, khi=100)\n    end\n    finish()\n    preview()\nend\n\nmain()","category":"page"},{"location":"explanation/imagematrix/#Drawings-as-image-matrices","page":"Image matrix","title":"Drawings as image matrices","text":"","category":"section"},{"location":"explanation/imagematrix/#Images-as-matrices","page":"Image matrix","title":"Images as matrices","text":"","category":"section"},{"location":"explanation/imagematrix/","page":"Image matrix","title":"Image matrix","text":"While drawing a PNG drawing, you can at any time copy the current graphics in a drawing as a matrix of colored pixels, using the image_as_matrix function. ","category":"page"},{"location":"explanation/imagematrix/","page":"Image matrix","title":"Image matrix","text":"With the @imagematrix macro, you can create a drawing in the usual way, and then return the result as a matrix of colored pixels.","category":"page"},{"location":"explanation/imagematrix/","page":"Image matrix","title":"Image matrix","text":"This code draws a very small PNG image and also uses the image_as_matrix() function to stores the pixels in mat as a 25×25 reinterpret(ColorTypes.ARGB32, ::Matrix{UInt32}):. ","category":"page"},{"location":"explanation/imagematrix/","page":"Image matrix","title":"Image matrix","text":"using Luxor\nDrawing(25, 25, :png)\norigin()\nbackground(randomhue()...)\nsethue(\"red\")\nfontsize(20)\nfontface(\"Georgia\")\ntext(\"42\", halign=:center, valign=:middle)\nmat = image_as_matrix()\nfinish()\npreview()","category":"page"},{"location":"explanation/imagematrix/","page":"Image matrix","title":"Image matrix","text":"The next example draws an ampersand and then processes the pixels further in Images.jl.","category":"page"},{"location":"explanation/imagematrix/","page":"Image matrix","title":"Image matrix","text":"using Luxor, Colors, Images, ImageFiltering\n\nm = @imagematrix begin\n        background(\"black\")\n        sethue(\"white\")\n        fontface(\"Georgia\")\n        fontsize(180)\n        text(\"&\", halign=:center, valign=:middle)\nend 200 200\n\nfunction convertmatrixtocolors(m)\n    return convert.(Colors.RGBA, m)\nend\n\nimg = convertmatrixtocolors(m)\n\nimfilter(img, Kernel.gaussian(10))","category":"page"},{"location":"explanation/imagematrix/","page":"Image matrix","title":"Image matrix","text":"(Image: image matrix)","category":"page"},{"location":"explanation/imagematrix/","page":"Image matrix","title":"Image matrix","text":"image_as_matrix returns a array of ARGB32 (AlphaRedGreenBlue) values. Each ARGB value encodes the Red, Green, Blue, and Alpha 8-bit values of a pixel into a single 32 bit integer.","category":"page"},{"location":"explanation/imagematrix/","page":"Image matrix","title":"Image matrix","text":"You can display the matrix using, for example, Images.jl.","category":"page"},{"location":"explanation/imagematrix/","page":"Image matrix","title":"Image matrix","text":"using Luxor, Images\n\n# in Luxor\n\nDrawing(250, 250, :png)\norigin()\nbackground(randomhue()...)\nsethue(\"red\")\nfontsize(200)\nfontface(\"Georgia\")\ntext(\"42\", halign=:center, valign=:middle)\nmat = image_as_matrix()\nfinish()\n\n# in Images\n\nimg = RGB.(mat)\n# img = Gray.(mat) # for greyscale\n\nimfilter(img, Kernel.gaussian(10))","category":"page"},{"location":"explanation/imagematrix/","page":"Image matrix","title":"Image matrix","text":"In Luxor:","category":"page"},{"location":"explanation/imagematrix/","page":"Image matrix","title":"Image matrix","text":"(Image: 42 image array)","category":"page"},{"location":"explanation/imagematrix/","page":"Image matrix","title":"Image matrix","text":"In Images:","category":"page"},{"location":"explanation/imagematrix/","page":"Image matrix","title":"Image matrix","text":"(Image: 42 image array)","category":"page"},{"location":"explanation/imagematrix/","page":"Image matrix","title":"Image matrix","text":"The next example makes two drawings. The first draws a red rectangle, then copies the drawing in its current state into a matrix called mat1. Next it adds a blue triangle, and copies the updated drawing state into mat2.","category":"page"},{"location":"explanation/imagematrix/","page":"Image matrix","title":"Image matrix","text":"In the second drawing, values from these two matrices are tested, and table cells are randomly colored depending on the corresponding values ... this is a primitive Boolean operation.","category":"page"},{"location":"explanation/imagematrix/","page":"Image matrix","title":"Image matrix","text":"using Luxor, Colors, Random # hide\nRandom.seed!(42) # hide\n\n# first drawing\n\nDrawing(40, 40, :png)\norigin()\nbackground(\"black\")\nsethue(\"red\")\nbox(Point(0, 0), 40, 15, :fill)\nmat1 = image_as_matrix()\nsethue(\"blue\")\nsetline(10)\nsetopacity(0.6)\nngon(Point(0, 0), 10, 3, 0, :stroke)\nmat2 = image_as_matrix()\nfinish()\n\n# second drawing\n\nDrawing(400, 400, \"../assets/figures/image-drawings.svg\")\nbackground(\"grey20\")\norigin()\nt = Table(40, 40, 4, 4)\nsethue(\"white\")\nrc = CartesianIndices(mat1)\nfor i in rc\n    r, c = Tuple(i)\n    pixel1 = convert(Colors.RGBA, mat1[r, c])\n    pixel2 = convert(Colors.RGBA, mat2[r, c])\n    if red(pixel1) > .5 && blue(pixel2) > .5\n        randomhue()\n        box(t, r, c, :fillstroke)\n    end\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"explanation/imagematrix/","page":"Image matrix","title":"Image matrix","text":"The first image (enlarged) shows the mat1 matrix as red, mat2 as blue.","category":"page"},{"location":"explanation/imagematrix/","page":"Image matrix","title":"Image matrix","text":"(Image: intermediate)","category":"page"},{"location":"explanation/imagematrix/","page":"Image matrix","title":"Image matrix","text":"In the second drawing, a table with 1600 squares is colored according to the values in the matrices.","category":"page"},{"location":"explanation/imagematrix/","page":"Image matrix","title":"Image matrix","text":"(Image: image drawings)","category":"page"},{"location":"explanation/imagematrix/","page":"Image matrix","title":"Image matrix","text":"(You can use collect to gather the re-interpreted values together.)","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"DocTestSetup = quote\n    using Luxor, Colors\n    end","category":"page"},{"location":"example/examples/#Simple-examples","page":"Simple examples","title":"Simple examples","text":"","category":"section"},{"location":"example/examples/#The-obligatory-\"Hello-World\"","page":"Simple examples","title":"The obligatory \"Hello World\"","text":"","category":"section"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"Here's the \"Hello world\":","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"(Image: \"Hello world\")","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"using Luxor\nDrawing(1000, 1000, \"hello-world.png\")\norigin()\nbackground(\"black\")\nsethue(\"red\")\nfontsize(50)\ntext(\"hello world\")\nfinish()\npreview()","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"Drawing(1000, 1000, \"hello-world.png\") defines the width, height, location, and format of the finished image. origin moves the 0/0 point to the centre of the drawing surface (by default it's at the top left corner). Thanks to Colors.jl we can specify colors by name as well as by numeric value: background(\"black\") defines the color of the background of the drawing. text(\"helloworld\") draws the text. It's placed at the current 0/0 point and left-justified if you don't specify otherwise. finish completes the drawing and saves the PNG image in the file. preview tries to display the saved file, perhaps using another application (eg Preview on macOS).","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"The macros @png, @svg, @pdf, @draw, and @imagematrix provide shortcuts for making and previewing graphics without you having to provide the usual set-up and finish instructions:","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"So this macro:","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"using Luxor\n\n@png begin\n    fontsize(50)\n    circle(Point(0, 0), 150, action = :stroke)\n    text(\"hello world\", halign=:center, valign=:middle)\nend","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"(Image: background)","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"expands the 140 or so characters into this 250+ character source:","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"Drawing(600, 600, \"luxor-drawing-072453_822.png\")\norigin()\nbackground(\"white\")\nsethue(\"black\")\nfontsize(50)\ncircle(Point(0, 0), 150, action=:stroke)\ntext(\"hello world\", halign=:center, valign=:middle)\nfinish()\npreview()","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"The @drawsvg macro returns SVG code of the drawing which, in this Documenter-generated document, will be inserted into the HTML source of the page.","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"using Luxor\n\n@drawsvg begin\n    background(\"black\")\n    sethue(\"red\")\n    randpoint = Point(rand(-300:300), rand(-300:300))\n    circle(randpoint, 5, action = :fill)\n    sethue(\"white\")\n    foreach(f -> arrow(f, between(f, randpoint, .1), arrowheadlength=6),\n        first.(collect(Table(fill(30, 20), fill(30, 20)))))\nend","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"The @draw and drawsvg macros create a PNG or SVG format drawing in memory, rather than saved in a file, and the result of executing the code is returned and, in many editing environments, included and displayed as a graphic. For VS Code, the graphic is usually displayed in the plot pane. In Pluto, it appears above the cell.","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"using Luxor\n\n@draw begin\n    setopacity(0.85)\n    steps = 20\n    gap   = 2\n    for (n, θ) in enumerate(range(0, step=2π/steps, length=steps))\n        sethue([Luxor.julia_green,\n            Luxor.julia_red,\n            Luxor.julia_purple,\n            Luxor.julia_blue][mod1(n, 4)])\n        sector(Point(0, 0), 50, 250 + 2n, θ, θ + 2π/steps - deg2rad(gap), action = :fill)\n    end\nend","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"(Image: background)","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"(Image: pluto logo)","category":"page"},{"location":"example/examples/#The-Julia-logos","page":"Simple examples","title":"The Julia logos","text":"","category":"section"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"Luxor contains built-in functions that draw the Julia logo, either in color or a single color, and the three Julia circles.","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"using Luxor\nDrawing(600, 400, \"../assets/figures/julia-logos.png\")\norigin()\nbackground(\"white\")\n\nfor θ in range(0, step=π/8, length=16)\n    gsave()\n    scale(0.2)\n    rotate(θ)\n    translate(350, 0)\n    julialogo(action=:fill, bodycolor=randomhue())\n    grestore()\nend\n\ngsave()\nscale(0.3)\njuliacircles()\ngrestore()\n\ntranslate(150, -150)\nscale(0.3)\njulialogo()\nfinish()\n\n# preview()\nnothing # hide","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"(Image: background)","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"The gsave function saves the current drawing environment temporarily, and any subsequent changes such as the scale and rotate operations are discarded when you call the next grestore function.","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"Use the extension to specify the format: for example, change julia-logos.png to julia-logos.svg or julia-logos.pdf or julia-logos.eps to produce SVG, PDF, or EPS format output.","category":"page"},{"location":"example/examples/#Something-a-bit-more-complicated:-a-Sierpinski-triangle","page":"Simple examples","title":"Something a bit more complicated: a Sierpinski triangle","text":"","category":"section"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"Here's a version of the Sierpinski recursive triangle, clipped to a circle.","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"(Image: Sierpinski)","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"using Luxor, Colors\nDrawing()\nbackground(\"white\")\norigin()\n\nfunction triangle(points, degree)\n    sethue(cols[degree])\n    poly(points, action = :fill)\nend\n\nfunction sierpinski(points, degree)\n    triangle(points, degree)\n    if degree > 1\n        p1, p2, p3 = points\n        sierpinski([p1, midpoint(p1, p2),\n                        midpoint(p1, p3)], degree-1)\n        sierpinski([p2, midpoint(p1, p2),\n                        midpoint(p2, p3)], degree-1)\n        sierpinski([p3, midpoint(p3, p2),\n                        midpoint(p1, p3)], degree-1)\n    end\nend\n\nfunction draw(n)\n    circle(Point(0, 0), 75, :clip)\n    points = ngon(Point(0, 0), 150, 3, -π/2, vertices=true)\n    sierpinski(points, n)\nend\n\ndepth = 8 # 12 is ok, 20 is right out (on my computer, at least)\ncols = distinguishable_colors(depth) # from Colors.jl\ndraw(depth)\n\nfinish()\npreview()","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"The Point type is an immutable composite type containing x and y fields that specify a 2D point.","category":"page"},{"location":"example/examples/#Simple-numberlines","page":"Simple examples","title":"Simple numberlines","text":"","category":"section"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"tickline() is useful for generating spaced points along a line:","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"using Luxor\n@drawsvg begin\nbackground(\"black\")\nfontsize(12)\nsethue(\"white\")\ntickline(Point(-350, 0), Point(350, 0),\n    finishnumber=100,\n    log=true,\n    major=7)\nend 800 150","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"The arrow functions let you add decoration to the arrow shafts, so it's possible to use this function to create more complicated spacings. Here's how a curved number line could be made:","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"using Luxor\n@drawsvg begin\n    background(\"antiquewhite\")\n    _counter() = (a = -1; () -> a += 1)\n    counter = _counter() # closure\n    fontsize(15)\n    arrow(O +  (0, 100), 200, π, 2π,\n        arrowheadlength=0,\n        decoration=range(0, 1, length=61),\n        decorate = () -> begin\n                d = counter()\n                if d % 5 == 0\n                    text(string(d), O + (0, -20), halign=:center)\n                    setline(3)\n                end\n                line(O - (0, 5), O + (0, 5), action = :stroke)\n            end\n        )\nend 800 300","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"The decorate function here adds graphics and text at the origin, which is located at each point along the shaft.","category":"page"},{"location":"example/examples/#Draw-a-matrix","page":"Simple examples","title":"Draw a matrix","text":"","category":"section"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"To draw the contents of a matrix, you can use a Table to generate the positions for the numbers.","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"It's sometimes useful to be able to highlight particular cells. Here, numbers that have already been used once are drawn in orange.","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"using Luxor\n\nfunction drawmatrix(A::Matrix;\n        cellsize = (10, 10))\n    table = Table(size(A)..., cellsize...)\n    used = Set()\n    for i in CartesianIndices(A)\n        r, c = Tuple(i)\n        if A[r, c] ∈ used\n            sethue(\"orange\")\n        else\n            sethue(\"purple\")\n            push!(used, A[r, c])\n        end\n        text(string(A[r, c]), table[r, c],\n            halign=:center,\n            valign=:middle)\n        sethue(\"white\")\n        box(table, r, c, action = :stroke)        \n    end\nend\n\nA = rand(1:99, 5, 8)\n\n@drawsvg begin\n    background(\"black\")\n    fontsize(30)\n    setline(0.5)\n    sethue(\"white\")\n    drawmatrix(A, cellsize = 10 .* size(A))\nend","category":"page"},{"location":"example/examples/#Simple-\\LaTeX-equations","page":"Simple examples","title":"Simple LaTeX equations","text":"","category":"section"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"You can draw simple LaTeX equations by passing a string to text(), using the formats provided by the LaTeXStrings.jl package.","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"# drawing with 800×300 canvas\nusing Luxor\nusing MathTeXEngine\nd = Drawing(800, 300, :svg)\norigin()\nbackground(\"khaki\")\nf(t) = Point(4cos(t) + 2cos(5t), 4sin(t) + 2sin(5t))\nsetline(15)\nfontsize(35)\n@layer begin\n    setopacity(0.4)\n    sethue(\"purple\")\n    poly(20f.(range(0, 2π, length=160)), action = :stroke)\nend\nsethue(\"grey5\")\ntext(L\"f(t) = [4\\cos(t) + 2\\cos(5t), 4\\sin(t) + 2\\sin(5t)]\", halign=:center)\nfinish()\nd","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"(Image: LaTeX text)","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"See the Writing LaTeX section for more information. You'll have to install the fonts that MathTeXEngine.jl requires. ","category":"page"},{"location":"example/examples/#Drawing-pixels","page":"Simple examples","title":"Drawing pixels","text":"","category":"section"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"You can use Luxor to draw into an array of ARGB32 values, which are essentially colored pixels. This example uses Images.jl to display the array.","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"using Luxor, Colors, Images\n\n# a matrix of 150 rows, 600 columns\nbuffer = zeros(ARGB32, 150, 600) \n\nDrawing(buffer)\norigin()\n\nfor i in 1:15:150\n    buffer[i:i+10, 1:600] .= RGB(rand(), rand(), rand())\nend\n\nfor i in 1:100\n    randomhue()\n    ngon(rand(BoundingBox()), 15, 4, 0, :fill)\nend\n\nfinish()\nbuffer","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"(Image: buffer drawing)","category":"page"},{"location":"example/examples/#Triangulations","page":"Simple examples","title":"Triangulations","text":"","category":"section"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"This example shows how a Delaunay triangulation of a set of random points can be used to derive a set of Voronoi cells.","category":"page"},{"location":"example/examples/","page":"Simple examples","title":"Simple examples","text":"# Inspired by @TheCedarPrince!\nusing Luxor, Colors, Random\nRandom.seed!(42)\n\nd = @drawsvg begin\nbackground(\"black\")\nsetlinejoin(\"bevel\")\nverts = randompointarray(BoundingBox(), 40)\n\ntriangles = polytriangulate(verts) # create Delaunay\n\n@layer begin\n    for tri in triangles\n        sethue(HSB(rand(120:320), 0.7, 0.7))\n        poly(tri, action = :stroke, close=true)\n    end\nend\n\ndict = Dict{Point, Vector{Int}}()\n\nfor (n, t) in enumerate(triangles)\n    for pt in t\n        if haskey(dict, pt)\n            push!(dict[pt], n)\n        else\n            dict[pt] = [n]\n        end\n    end\nend\n\nsetopacity(0.9)\nsetline(3)\nfor v in verts\n    hull = Point[]\n    tris = dict[v]\n    # vertex v belongs to all triangles tris\n    for tri in tris\n        push!(hull, trianglecenter(triangles[tri]...))\n    end\n    sethue(HSB(rand(120:320), 0.7, 0.7))\n    if length(hull) >= 3\n        ph = polyhull(hull)\n        poly(ph, action = :fillpreserve, close=true)\n        sethue(\"black\")\n        strokepath()\n    end\nend\nend 800 500\nd","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"DocTestSetup = quote\n    using Luxor, Colors\n    end","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"Graphics are placed on the current drawing according to the current transformation matrix. You can either modify this indirectly, using functions, or set the matrix directly.","category":"page"},{"location":"explanation/transforms/#Transformation-functions","page":"Transforms and matrices","title":"Transformation functions","text":"","category":"section"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"For basic transformations, use translate(tx, ty), scale(sx, sy), and rotate(a).","category":"page"},{"location":"explanation/transforms/#Translation","page":"Transforms and matrices","title":"Translation","text":"","category":"section"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"translate(pos) (and translate(x, y)) shift the current origin to pos or by the specified amounts in x and y. It's relative and cumulative, rather than absolute:","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"using Luxor, Colors, Random # hide\nDrawing(800, 200, \"../assets/figures/translate.png\") # hide\nbackground(\"antiquewhite\") # hide\nRandom.seed!(1) # hide\nsetline(1) # hide\norigin()  # hide\nfor i in range(0, step=30, length=6)\n    sethue(HSV(i, 1, 1)) # from Colors\n    setopacity(0.5)\n    circle(Point(0, 0), 40, :fillpreserve)\n    setcolor(\"black\")\n    strokepath()\n    translate(50, 0)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"(Image: translate)","category":"page"},{"location":"explanation/transforms/#Scaling","page":"Transforms and matrices","title":"Scaling","text":"","category":"section"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"scale(x, y) and scale(n) scale the current workspace by the specified amounts. It's relative to the current scale, not to the drawing's original.","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"using Luxor, Colors, Random # hide\nDrawing(800, 300, \"../assets/figures/scale.png\") # hide\nbackground(\"antiquewhite\") # hide\nRandom.seed!(1) # hide\nsetline(1) # hide\norigin()\nfor i in range(0, step=30, length=6)\n    sethue(HSV(i, 1, 1)) # from Colors\n    circle(Point(0, 0), 130, :fillpreserve)\n    setcolor(\"black\")\n    strokepath()\n    scale(0.8)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"(Image: scale)","category":"page"},{"location":"explanation/transforms/#Rotation","page":"Transforms and matrices","title":"Rotation","text":"","category":"section"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"rotate rotates the current workspace by the specified amount about the current 0/0 point. It's relative to the previous rotation - \"rotate by\".","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"using Luxor, Random # hide\nDrawing(800, 200, \"../assets/figures/rotate.png\") # hide\nbackground(\"antiquewhite\") # hide\nRandom.seed!(1) # hide\nsetline(1) # hide\norigin()\nsetopacity(0.7) # hide\nfor i in 1:8\n    randomhue()\n    squircle(Point(40, 0), 20, 30, :fillpreserve)\n    sethue(\"black\")\n    strokepath()\n    rotate(π/4)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"(Image: rotate)","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"origin resets the matrix then moves the origin to the center of the page.","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"Use the getscale, gettranslation, and getrotation functions to find the current values.","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"To quickly return home after many changes, you can use setmatrix([1, 0, 0, 1, 0, 0]) to reset the matrix to the default.","category":"page"},{"location":"explanation/transforms/#Linear-interpolation-(\"lerp\")","page":"Transforms and matrices","title":"Linear interpolation (\"lerp\")","text":"","category":"section"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"rescale is a convenient utility function for linear interpolation. An easy way to visualize it is by imagining two number lines. A value relative to a pair of low and high values is rescaled to have the equivalent value relative to another pair of low and high values.","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"using Luxor\n\nreddot(pos) = @layer begin\nsethue(\"red\")\ncircle(pos, 8, :fill)\nend\n\ndiagram = @drawsvg begin\n    background(\"antiquewhite\")\n    sethue(\"black\")\n    setline(1)\n    fontsize(14)\n\n    n = 35\n    dot′′ = between(O + (-200, 40), O + (200, 40), rescale(n, 30, 40, 0, 1))\n    reddot(dot′′)\n\n    text(string(\"n = $(n)\"), O + (0, -60), halign=:center)\n    text(\"rescale(n, 30, 40, 1, 2) = $(rescale(n, 30, 40, 1, 2))\", dot′′ + (0, -60), halign=:center)\n\n    pts = (O + (-200, 40), O + (200, 40))\n\n    tickline(pts...,\n        startnumber = 1,\n        finishnumber = 2,        \n        minor=0,\n        major=9)\n    tickline(pts...,\n        startnumber = 30,\n        finishnumber = 40,        \n        minor=0,\n        major=9,\n        major_tick_function = (n, pos; startnumber=30, finishnumber=40, nticks=10) -> begin\n            @layer begin\n                translate(pos)\n                line(O, O + polar(5, 3π/2), :stroke)\n                k = rescale(n, 0, nticks - 1, startnumber, finishnumber)\n                ticklength = get_fontsize() * 1.3\n                text(\"$(round(k, digits=2))\", O + (0, -ticklength), halign=:center, valign=:middle, angle = -getrotation())\n            end\n        end)\n    finish()\nend 800 200","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"diagram # hide","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"This function is sometimes called “lerp” in other systems. For example, in Processing, the lerp() function takes the form lerp(low, high, value), where the returned value lies between low and high corresponding to how value lies between 0 and 1.","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"The equivalent to lerp(10, 20, 0.5) in Luxor is rescale(0.5, 0, 1, 10, 20). Luxor requires a ‘from’ scale (here ... 0, 1, ...) although the ‘to’ scale is optional and defaults to 0, 1.","category":"page"},{"location":"explanation/transforms/#Scaling-of-line-thickness","page":"Transforms and matrices","title":"Scaling of line thickness","text":"","category":"section"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"Line thicknesses are not scaled by default. For example, with a current line thickness set by setline(1), lines drawn before and after scale(2) will be the same thickness. If you want line thicknesses to respond to the current scale, so that a line thickness of 1 is scaled by n after calls to scale(n), you can call setstrokescale with true to enable stroke scaling, and setstrokescale(false) to disable it. You can also enable stroke scaling when creating a new Drawing by passing the named argument strokescale during Drawing construction (i.e., Drawing(400, 400, strokescale=true)).","category":"page"},{"location":"explanation/transforms/#Matrices","page":"Transforms and matrices","title":"Matrices","text":"","category":"section"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"In Luxor, there's always a current matrix that determines how coordinates are interpreted in the current workspace. In Cairo, it's a six element array:","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"beginbmatrix\n1  0  0 \n0  1  0 \nendbmatrix","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"and Luxor/Cairo matrix functions accept and return simple 6-element vectors:","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"julia> getmatrix()\n6-element Array{Float64,1}:\n   1.0\n   0.0\n   0.0\n   1.0\n   0.0\n   0.0","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"note: Note\nYou can convert between the 6-element and 3x3 versions of a transformation matrix using the functions cairotojuliamatrix and juliatocairomatrix.","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"transform(a) transforms the current workspace by ‘multiplying’ the current matrix with matrix a. For example, transform([1, 0, xskew, 1, 50, 0]) skews the current matrix by xskew radians and moves it 50 in x and 0 in y.","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"using Luxor # hide\nfname = \"../assets/figures/transform.png\" # hide\npagewidth, pageheight = 800, 100 # hide\nDrawing(pagewidth, pageheight, fname) # hide\norigin() # hide\nbackground(\"antiquewhite\") # hide\ntranslate(-200, 0) # hide\n\nfunction boxtext(p, t)\n    sethue(\"grey30\")\n    box(p, 30, 50, :fill)\n    sethue(\"white\")\n    textcentered(t, p)\nend\n\nfor i in 0:5\n    xskew = tand(i * 5.0)\n    transform([1, 0, xskew, 1, 50, 0])\n    boxtext(O, string(round(rad2deg(xskew), digits=1), \"°\"))\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"(Image: transform)","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"getmatrix gets the current matrix, setmatrix(a) sets the matrix to array a.","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"Other functions include getmatrix, setmatrix, transform, crossproduct, blendmatrix, rotationmatrix, scalingmatrix, and translationmatrix.","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"Use the getscale, gettranslation, and getrotation functions to find the current values of the current matrix. These can also find the values of arbitrary 3x3 matrices.","category":"page"},{"location":"explanation/transforms/#World-position","page":"Transforms and matrices","title":"World position","text":"","category":"section"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"If you use translate to move the origin to different places on a drawing, you can use getworldposition to find the \"true\" world coordinates of points. In the following example, we temporarily translate to a random point, and \"drop a pin\" that remembers the new origin in terms of the drawing's world coordinates. After the temporary translation is over, we have a record of where it was.","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"using Luxor, Random # hide\nDrawing(800, 400, \"../assets/figures/getworldposition.png\") # hide\nbackground(\"antiquewhite\") # hide\nRandom.seed!(3) # hide\nsetline(1) # hide\norigin()\n\n@layer begin\n    translate(0.7rand(BoundingBox()))\n    pin = getworldposition()\nend\n\nlabel(\"you went ... \", :n, O, offset = 10)\nlabel(\"... here\", :n, pin, offset = 20)\narrow(O, pin)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"(Image: translate)","category":"page"},{"location":"explanation/transforms/#Coordinate-conventions","page":"Transforms and matrices","title":"Coordinate conventions","text":"","category":"section"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"In Luxor, by convention, the y axis points downwards, and the x axis points to the right.","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"There are basically two conventions for computer graphics:","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"most computer graphics systems (HTML, SVG, Processing, Cairo, Luxor, image processing, most GUIs, etc) use the “y downwards” convention\nmathematical illustrations, such as graphs, figures, Plots.jl, plots, etc. use the “y upwards” convention","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"using Luxor\ndiagram = @drawsvg begin\n    background(\"antiquewhite\")\n    table = Table(1, 2, 300, 400)\n    fontsize(16)\n    @layer begin\n        translate(table[1])\n        arrow(O, O  + (0, -200))\n        text(\"y\", O  + (20, -200))\n        arrow(O, O  + (200, 0))\n        text(\"x\", O  + (200, 20))\n\n        text(\"maths: y upwards\", O  + (0, 100), halign=:center)\n    end\n\n    @layer begin\n        translate(table[2])        \n        text(\"computing: y downwards\", O  + (0, 100), halign=:center)\n        rulers()\n    end\n\nend 800 450","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"diagram # hide","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"You could use a transformation matrix to reflect the Luxor drawing space in the x axis.","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"using Luxor # hide\n@drawsvg begin # hide\n    background(\"antiquewhite\") # hide\n    table = Table(1, 2, 300, 400) # hide\n    fontsize(30) # hide\n    pts = (Point(0, 0), Point(50, 100))\n    @layer begin\n        translate(table[1])\n        arrow(pts...)\n        rulers()\n    end\n\n    @layer begin\n        translate(table[2])\n        transform([1 0 0 -1 0 0])               # <--\n        arrow(pts...)\n        rulers()\n    end\nend 800 450 # hide","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"note: Note\nIf you do this and try to place text, all your text will be incorrectly drawn upside down, so you'd need to enclose any text placement with another matrix transformation.","category":"page"},{"location":"explanation/transforms/#Advanced-transformations","page":"Transforms and matrices","title":"Advanced transformations","text":"","category":"section"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"For more powerful transformations of graphic elements, consider using Julia packages which are designed specifically for the purpose.","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"The following example uses the Rotations and CoordinateTransformations packages. It sets up some transformations which can then be composed in the correct order to transform points.","category":"page"},{"location":"explanation/transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"using CoordinateTransformations, Rotations, StaticArrays, LinearAlgebra\n\nrawpts = [\n    [0.1, 0.1],\n    [0.1, -0.1],\n    [-0.1, -0.1],\n    [-0.1, 0.1]\n]\n\nfunction transform_point(pt, transformation)\n    x, y, _ = transformation(SVector(pt[1], pt[2], 1.0))\n    return Point(x, y)\nend\n\n𝕊1 = LinearMap(UniformScaling(60))\n𝕋1 = Translation(20, 30, 0)\nℝ1 = LinearMap(RotZ(π/3))\npts = map(pt -> transform_point(pt, 𝕋1 ∘ ℝ1 ∘ 𝕊1), rawpts)\n...\n","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"DocTestSetup = quote\n    using Luxor, Colors\n    end","category":"page"},{"location":"tutorial/basicpath/#Basic-path-construction","page":"Basic path building","title":"Basic path construction","text":"","category":"section"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"This tutorial covers the basics of drawing paths in Luxor. If you're familiar with the basics of Cairo, PostScript, Processing, HTML canvas, or similar graphics applications, you can probably glance through these tutorials and then refer to the How To sections. For more information about how paths are built, refer to the Cairo API documentation; Luxor hides the details behind friendly Julia syntax, but the underlying mechanics are the same.","category":"page"},{"location":"tutorial/basicpath/#How-to-build-a-path","page":"Basic path building","title":"How to build a path","text":"","category":"section"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"Consider the following drawing. (We'll use the quick @drawsvg ...end macro syntax for simplicity.) The point (0, 0) is at the center of the drawing canvas, and, as with most graphics software applications, the y direction is downwards.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"warning: Warning\nMathematicians and people who like making plots say that the y axis goes up the page. Most graphics software is written with the assumption that the y axis goes downwards.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"using Luxor\n@drawsvg begin\nbackground(\"black\")\nsethue(\"white\")\nmove(Point(200, 0))\nline(Point(250, 100))\ncurve(Point(150, 150), Point(0, 100), Point(-200, -200))\nclosepath()\n\nstrokepath()\nend","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"This drawing constructs and renders a path, using basic building blocks.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"In Luxor, there's always a current path. At the start, just after we set the color to white, the current path is empty. The move() function call starts the path by moving to (200, 0), ie 200 units in x (right). This sets the current point to Point(200, 0). ","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"The line(Point(250, 100)) function call adds a straight line from the current point down to the point (250, 100). The current point is now set to (250, 100), and the current path now has two entries. We've reached the bottom right corner of this particular path.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"The curve() function takes three point arguments, and adds a cubic Bézier curve to the current path. The curve runs from the current point to the third point argument, with the first and second point arguments defining the Bézier curve's control points. These influence the shape of the curve. Finally, the current point is updated to the point defined by the third argument.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"note: Note\nTo learn about Bézier curves, read A Primer on Bézier Curves.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"The closepath() function adds a straight line to the path, joining the current point to the beginning of the path (more specifically, to the most recent point moved to). The current point is then updated to this point.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"We could have used line(Point(200, 0)) rather than closepath(), but closepath() is better here because it will make a mitred join between the two line segments.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"So, now we've constructed a path. The final job is to decide what to do with it. We used strokepath() to draw the path using a line with the current settings (width, color, etc). But an alternative is to use fillpath() to fill the shape with the current color. fillstroke() does both. To change colors and styles, see Colors and styles.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"After you've rendered the path, the current path is empty again, and there is no current point.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"And that's how you draw paths in Luxor. ","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"However, you'd be right if you're thinking that constructing every single shape like this would be a lot of work. This is why there are so many other functions in Luxor, such as circle(), ngon(), star(), rect(), box(), etc. See Simple graphics.","category":"page"},{"location":"tutorial/basicpath/#Arcs","page":"Basic path building","title":"Arcs","text":"","category":"section"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"There are arc() and carc() (counterclockwise arc) functions that provide the ability to add circular arcs to the current path, just as curve() adds a Bézier curve. However, these need careful handling. Consider this drawing:","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"using Luxor\n@drawsvg begin\nbackground(\"black\")\nsethue(\"white\")\nmove(Point(100, 200))\narc(Point(0, 0), 70, 0, 3π / 2)\nline(Point(-200, -200))\nstrokepath()\nend","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"The arc() function arguments are: the center point, the radius, the start angle, and the end angle.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"But you'll notice that there are two straight lines, not just one. After moving down to (100, 200), the calculated start point for the arc isn't (100, 200), but (70, 0). So an additional straight line from the current point (100, 200) to the arc's starting point (70, 0) was automatically inserted into the path.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"Internally, circular arcs are converted to Bézier curves.","category":"page"},{"location":"tutorial/basicpath/#Relative-coordinates","page":"Basic path building","title":"Relative coordinates","text":"","category":"section"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"The move() and line() functions require absolute coordinates, which always refer to the current origin, (0, 0). You might prefer to define the positions with reference to the current path's current point. Use rmove() and rline() to do this.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"This drawing draws two boxes with 120 unit sides.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"using Luxor\n@drawsvg begin\n    background(\"black\")\n    sethue(\"white\")\n\n    move(0, 0)\n\n    rline(Point(120, 0))\n    rline(Point(0, 120))\n    rline(Point(-120, 0))\n    rline(Point(0, -120))\n\n    closepath()\n\n    rmove(150, 0)\n\n    rline(Point(120, 0))\n    rline(Point(0, 120))\n    rline(Point(-120, 0))\n    rline(Point(0, -120))\n\n    closepath()\n\n    strokepath()\nend","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"The drawing instructions to make the two shapes are the same, the second is just moved 150 units in x.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"rmove() requires a current point to be \"relative to\". This is why the first drawing function is move() rather than rmove().","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"Notice that this code draws two shapes, but there was only one strokepath() function call. These two shapes are in fact subpaths.","category":"page"},{"location":"tutorial/basicpath/#Subpaths","page":"Basic path building","title":"Subpaths","text":"","category":"section"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"A path consists of one or more of these move-line-curve-arc-closepath sequences. Each is a subpath. When you call a strokepath() or fillpath() function, all the subpaths in the entire path are rendered, and then the current path is emptied.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"You can create a new subpath either by doing a move() or rmove() in the middle of building a path (before you render it), or with the specific newsubpath() function.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"An important feature of subpaths is that they can form holes in paths.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"using Luxor\n@drawsvg begin\nbackground(\"black\")\nsethue(\"white\")\n\nmove(0, 0)\nline(Point(0, 100))\nline(Point(100, 100))\nline(Point(100, 0))\nclosepath()\n\nnewsubpath()\nmove(25, 25)\nline(Point(75, 25))\nline(Point(75, 75))\nline(Point(25, 75))\nclosepath()\n\nfillpath()\nend","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"The first subpath is counterclockwise, the second subpath is clockwise and thus forms a hole when you fill the path. (See Nonzero winding rule for details.)","category":"page"},{"location":"tutorial/basicpath/#Not-just-fill-and-stroke","page":"Basic path building","title":"Not just fill and stroke","text":"","category":"section"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"As well as strokepath() or fillpath(), you can:","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"fillstroke(): fill and stroke the path\nclip():  turn the path into a clipping path \nstrokepreserve(): stroke the path but don't empty the current path\nfillpreserve(): fill the path but don't empty the current path","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"The -preserve() functions are useful for using different styles for fill and stroke:","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"using Luxor\n@drawsvg begin\nbackground(\"black\")\n\nmove(0, 0)\nline(Point(0, 100))\nline(Point(100, 100))\nline(Point(100, 0))\nclosepath()\n\n# purple fill\nsethue(\"purple\")\nfillpreserve() \n\n# current path is still here!\n\n# cyan stroke\nsethue(\"cyan\")\nstrokepath()\nend ","category":"page"},{"location":"tutorial/basicpath/#Translate,-scale,-rotate","page":"Basic path building","title":"Translate, scale, rotate","text":"","category":"section"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"Suppose you want to repeat a path in various places on the drawing. Obviously you don't want to code the same steps over and over again.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"In this example, the t() function draws a triangle path.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"using Luxor\nfunction t()\n    move(Point(100, 0))\n    line(Point(0, -100))\n    line(Point(-100, 0))\n    closepath()\n    strokepath()\nend\n\n@drawsvg begin\nbackground(\"black\")\nsethue(\"white\")\nt()\nend","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"Inside t(), the coordinates are interpreted relative to the current graphics state: the current origin position (0, 0), scale (1), and rotation (0°).","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"To draw the triangle in another location, you can first use translate() to shift the (0, 0) origin to another location. Now the move() and line() calls inside the t() function all refer to the new location.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"using Luxor\nfunction t()\n    move(Point(100, 0))\n    line(Point(0, -100))\n    line(Point(-100, 0))\n    closepath()\n    strokepath()\nend\n\n@drawsvg begin\nbackground(\"black\")\nsethue(\"white\")\nt()\n\ntranslate(Point(150, 150))\nt()\nend","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"You can also use the scale() and rotate() functions to modify the current state:","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"using Luxor\nfunction t()\n    move(Point(100, 0))\n    line(Point(0, -100))\n    line(Point(-100, 0))\n    closepath()\n    strokepath()\nend\n\n@drawsvg begin\nbackground(\"black\")\nsethue(\"white\")\nt()\n\ntranslate(Point(150, 150))\nt()\n\ntranslate(Point(30, 30))\nscale(0.5)\nt()\n\ntranslate(Point(120, 120))\nrotate(π/3)\nt()\nend","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"As you experiment with these three functions, you'll notice that the changes are always relative to the previous state. So if you do scale(0.5) twice, the next path will be drawn a quarter of the size.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"So how do you return to a default initial state? You could of course keep a record of each transformation and apply the opposites, making sure you do this in the right order.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"But a better way is to enclose a sequence of changes of position, scale, and orientation in a pair of functions (gsave() and grestore()). The following code generates a grid of points in a nested loop. At each iteration:","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"gsave() saves the current position, scale, and orientation on an internal stack.\nThe graphics state is translated, scaled, and rotated. \nThe t() function is called, and draws the triangle with the new settings.\ngrestore() throws away any changes to position, scale, and rotation, then restores the previous state that was saved with gsave().","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"using Luxor\n\nfunction t()\n    move(Point(100, 0))\n    line(Point(0, -100))\n    line(Point(-100, 0))\n    closepath()\n    strokepath()\nend\n\n@drawsvg begin\n    background(\"black\")\n    sethue(\"white\")\n    for x in -250:20:250, y in -250:20:250\n            gsave()\n             translate(Point(x, y))\n             scale(0.1)\n             rotate(rand() * 2π)\n             t()\n            grestore()\n    end\nend","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"note: Note\nAs an alternative to gsave() and grestore() you can use the @layer begin ... end macro, which does the same thing.","category":"page"},{"location":"tutorial/basicpath/#Useful-tools","page":"Basic path building","title":"Useful tools","text":"","category":"section"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"You can use currentpoint() to get the current point. ","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"rulers() is useful for drawing the current x and y axes before you start a path.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"storepath() grabs the current path and saves it as a Path object. This feature is intended to make Luxor paths more like other Julia objects, which you can save and manipulate before drawing them.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"There's another method for line() which takes two points and a rendering instruction. For example:","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"line(Point(0, 0), Point(100, 100), :stroke)","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"is just a quicker way of typing:","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"move(Point(0, 0))\nline(Point(100, 100))\nstrokepath()","category":"page"},{"location":"tutorial/basicpath/#Polygonal-thinking","page":"Basic path building","title":"Polygonal thinking","text":"","category":"section"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"In Luxor, a polygon is an array (a standard Julia vector) of Points. You can treat it like any standard Julia array, and then eventually draw it using the poly() function. ","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"It's all straight lines, no curves, so you might have to use a lot of points to get smooth curves.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"using Luxor\n@drawsvg begin\n    background(\"black\")\n    sethue(\"white\")\n    pts = 30 .* [Point(x, sin(x)) for x in -2π:0.1:2π]\n    poly(pts, :stroke)\n\n    translate(0, 100)\n\n    poly(pts, :fill)\nend ","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"You might find it easier to generate polygons using Julia code than to generate paths. But, of course, there are no curves. If you need arcs and Bézier curves, stick to paths.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"The poly() function simply builds a path with straight lines, and then does the :fill or :stroke action, depending on which you provide.","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"There are some Luxor functions that let you modify the points in a polygon in various ways:","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"polymove!(pgon, pt1, pt2)","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"move all points by pt1 -> pt2","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"polyreflect!(pgon, pt1, pt2)","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"reflect all points in line between pt1 and pt2","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"polyrotate!(pgon, θ)","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"rotate all points by θ","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"polyscale!(pgon, s)","category":"page"},{"location":"tutorial/basicpath/","page":"Basic path building","title":"Basic path building","text":"scale all points by s","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"DocTestSetup = quote\n    using Luxor, Colors\n    end","category":"page"},{"location":"howto/tables-grids/#Tables-and-grids","page":"Work with tables and grids","title":"Tables and grids","text":"","category":"section"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"You often want to position graphics at regular locations on the drawing. The positions can be provided by:","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"Tiler: a rectangular grid which you specify by enclosing area, and the number of rows and columns\nPartition: a rectangular grid which you specify by enclosing area, and the width and height of each cell\nGrid a rectangular grid, points supplied on demand\nTable: a rectangular grid which you specify by providing row and column numbers, row heights and column widths","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"These are types which act as iterators. Their job is to provide you with centerpoints; you'll probably want to use these in combination with the cell's widths and heights.","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"There are also functions to make hexagonal grids. See Hexagonal grids.","category":"page"},{"location":"howto/tables-grids/#Tiles-and-partitions","page":"Work with tables and grids","title":"Tiles and partitions","text":"","category":"section"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"The drawing area (or any other area) can be divided into rectangular tiles (as rows and columns) using the Tiler and Partition iterators.","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"The Tiler iterator returns the center point and tile number of each tile in turn.","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"In this example, every third tile is divided up into subtiles and colored:","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"using Luxor, Random # hide\nDrawing(800, 500, \"../assets/figures/tiler.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nRandom.seed!(1) # hide\nfontsize(20) # hide\ntiles = Tiler(800, 500, 4, 5, margin=5)\nfor (pos, n) in tiles\n    randomhue()\n    box(pos, tiles.tilewidth, tiles.tileheight, action=:fill)\n    if n % 3 == 0\n        gsave()\n        translate(pos)\n        subtiles = Tiler(tiles.tilewidth, tiles.tileheight, 4, 4, margin=5)\n        for (pos1, n1) in subtiles\n            randomhue()\n            box(pos1, subtiles.tilewidth, subtiles.tileheight, action=:fill)\n        end\n        grestore()\n    end\n    sethue(\"white\")\n    textcentered(string(n), pos + Point(0, 5))\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"(Image: tiler)","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"Partition is like Tiler, but you specify the width and height of the tiles, rather than how many rows and columns of tiles you want.","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"You can obtain the centerpoints of all the tiles in one go with:","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"first.(collect(tiles))","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"or obtain ranges with:","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"tiles[1:2:end]","category":"page"},{"location":"howto/tables-grids/#Tables","page":"Work with tables and grids","title":"Tables","text":"","category":"section"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"The Table iterator can be used to define tables: rectangular grids with a specific number of rows and columns.","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"Unlike a Tiler, the Table iterator lets you have columns with different widths, and rows with different heights.","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"note: Note\nLuxor generally tries to keep to the Julia convention of ‘width’ -> ‘height’, ‘row’ -> ‘column’. This flavour of consistency can sometimes be confusing if you’re expecting other kinds of consistency, such as ‘x before y’ or ‘column major’.)","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"Tables don't store data, of course, but are designed to help you draw tabular data.","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"To create a simple table with 3 rows and 4 columns, using the default width and height (100):","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"julia> t = Table(3, 4);","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"When you use this as an iterator, you can get the coordinates of the center of each cell, and its number:","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"julia> for i in t\n           println(\"row: $(t.currentrow), column: $(t.currentcol), center: $(i[1])\")\n       end\nrow: 1, column: 1, center: Luxor.Point(-150.0, -100.0)\nrow: 1, column: 2, center: Luxor.Point(-50.0, -100.0)\nrow: 1, column: 3, center: Luxor.Point(50.0, -100.0)\nrow: 1, column: 4, center: Luxor.Point(150.0, -100.0)\nrow: 2, column: 1, center: Luxor.Point(-150.0, 0.0)\nrow: 2, column: 2, center: Luxor.Point(-50.0, 0.0)\nrow: 2, column: 3, center: Luxor.Point(50.0, 0.0)\nrow: 2, column: 4, center: Luxor.Point(150.0, 0.0)\nrow: 3, column: 1, center: Luxor.Point(-150.0, 100.0)\nrow: 3, column: 2, center: Luxor.Point(-50.0, 100.0)\nrow: 3, column: 3, center: Luxor.Point(50.0, 100.0)\nrow: 3, column: 4, center: Luxor.Point(150.0, 100.0)","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"You can also access row and column information:","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"julia> for r in 1:size(t)[1]\n           for c in 1:size(t)[2]\n               @show t[r, c]\n           end\n       end\nt[r, c] = Luxor.Point(-150.0, -100.0)\nt[r, c] = Luxor.Point(-50.0, -100.0)\nt[r, c] = Luxor.Point(50.0, -100.0)\nt[r, c] = Luxor.Point(150.0, -100.0)\nt[r, c] = Luxor.Point(-150.0, 0.0)\nt[r, c] = Luxor.Point(-50.0, 0.0)\nt[r, c] = Luxor.Point(50.0, 0.0)\nt[r, c] = Luxor.Point(150.0, 0.0)\nt[r, c] = Luxor.Point(-150.0, 100.0)\nt[r, c] = Luxor.Point(-50.0, 100.0)\nt[r, c] = Luxor.Point(50.0, 100.0)\nt[r, c] = Luxor.Point(150.0, 100.0)","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"The next example creates a table with 10 rows and 10 columns, where each cell is 50 units wide and 35 high.","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"using Luxor, Random # hide\nDrawing(600, 400, \"../assets/figures/table2.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nRandom.seed!(42) # hide\nfontface(\"Helvetica-Bold\") # hide\nfontsize(20) # hide\nsethue(\"black\")\n\nt = Table(10, 10, 50, 35) # 10 rows, 10 columns, 50 wide, 35 high\n\nhundred = 1:100\n\nfor n in 1:length(t)\n   text(string(hundred[n]), t[n], halign=:center, valign=:middle)\nend\n\nsetopacity(0.5)\nsethue(\"thistle\")\ncircle.(t[3, :], 20, action=:fill) # row 3, every column\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"(Image: table 2)","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"You can access rows or columns in the usual Julian way.","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"Notice that the table is drawn row by row, whereas 2D Julia arrays are usually accessed column by column.","category":"page"},{"location":"howto/tables-grids/#Varying-row-heights-and-column-widths","page":"Work with tables and grids","title":"Varying row heights and column widths","text":"","category":"section"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"To specify varying row heights and column widths, supply arrays or ranges to the Table constructor. The next example has logarithmically increasing row heights, and four columns of width 130 points:","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"using Luxor # hide\nDrawing(600, 400, \"../assets/figures/table1.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\n\nt = Table(10 .^ range(0.7, length=25, stop=1.5), fill(130, 4))\n\nfor (pt, n) in t\n    setgray(rescale(n, 1, length(t), 0, 1))\n    box(pt, t.colwidths[t.currentcol], t.rowheights[t.currentrow], :fill)\n    sethue(\"white\")\n    fontsize(t.rowheights[t.currentrow])\n    text(string(n), pt, halign=:center, valign=:middle)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"(Image: table 1)","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"To fill table cells, it's useful to be able to access the table's row and column specifications (using the colwidths and rowheights fields), and iteration can also provide information about the current row and column being processed (currentrow and currentcol).","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"To ensure that graphic elements don't stray outside the cell walls, you can use a clipping region.","category":"page"},{"location":"howto/tables-grids/#Drawing-arrays-and-dataframes","page":"Work with tables and grids","title":"Drawing arrays and dataframes","text":"","category":"section"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"With a little bit of extra work you can write code that draws objects like arrays and dataframes combining text with graphic features. For example, this code draws arrays visually and numerically.","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"using Luxor, Random # hide\nfunction drawbar(t::Table, data, row, column, minvalue, maxvalue, barheight)\n    setline(1.5)\n    cellwidth = t.colwidths[column] - 10\n    leftmargin = t[row, column] - (cellwidth/2, 0)\n    sethue(\"gray70\")\n    box(leftmargin - (0, barheight/2), leftmargin + (cellwidth, barheight/2), :fill)\n    boxwidth = rescale(data[row, column], minvalue, maxvalue, 0, cellwidth)\n    sethue(\"red\")\n    box(leftmargin - (0, barheight/2), leftmargin + (boxwidth, barheight/2), :fill)\n    sethue(\"black\")\n    line(leftmargin + (boxwidth, -barheight/2),\n         leftmargin + (boxwidth, +barheight/2),\n         :stroke)\n    text(string(round(data[row, column], digits=3)), t[row, column] - (cellwidth/2, 10),\n         halign=:left)\nend\n\nDrawing(700, 250, \"../assets/figures/arraytable.svg\")  # hide\norigin() # hide\nbackground(\"white\") # hide\nRandom.seed!(42) # hide\nA = rand(6, 6)\nl, h = extrema(A)\nrt, ct = size(A)\nt = Table(size(A), (80, 30))\nfontface(\"Georgia\")\nfontsize(12)\nfor r in 1:rt\n    for c in 1:ct\n        drawbar(t, A, r, c, l, h, 10)\n    end\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"(Image: array table)","category":"page"},{"location":"howto/tables-grids/#Grids","page":"Work with tables and grids","title":"Grids","text":"","category":"section"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"You might also find a use for a grid. Luxor provides a simple grid utility. Grids are lazy: they'll supply the next point on the grid when you ask for it.","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"Define a rectangular grid with GridRect. Get the next grid point from a grid with nextgridpoint(grid).","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"using Luxor, Random # hide\nDrawing(700, 250, \"../assets/figures/grids.png\")  # hide\nbackground(\"white\") # hide\nfontsize(14) # hide\ntranslate(50, 50) # hide\nRandom.seed!(42) # hide\ngrid = GridRect(O, 40, 80, (10 - 1) * 40)\nfor i in 1:20\n    randomhue()\n    p = nextgridpoint(grid)\n    squircle(p, 20, 20, :fill)\n    sethue(\"white\")\n    text(string(i), p, halign=:center)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"(Image: grids)","category":"page"},{"location":"howto/tables-grids/#Hexagonal-grids","page":"Work with tables and grids","title":"Hexagonal grids","text":"","category":"section"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"Use the hexagon constructors HexagonOffsetOddR, HexagonOffsetEvenR, HexagonAxial, and HexagonCubic to define a hexagonal tile on a grid, using hexagon index values to specify their location.","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"You can use hexcenter() to find the Cartesian coordinates of the center of a hexagonal tile on the grid, and hextile() to return the Cartesian coordinates of the vertices of the tile.","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"For example, this code draws a hexagon with the hexagonal indices 0 0 on a grid centred at the origin with grid spacing of 100 units:","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"using Luxor, Colors # hide\n@drawsvg begin  # hide\nsethue(\"purple\")\npoly(hextile(HexagonOffsetOddR(0, 0, 100)), :fill)\nend 600 300  # hide","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"By default the hexagonal grid indices 0 0 are located at the drawing's origin (Point(0, 0)). You can change this, and also specify the width and height of the hexagonal grid.","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"By using different index values you can draw hexagons at other locations on the hexagonal grid.","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"using Luxor, Colors  # hide\n@drawsvg begin  # hide\nsethue(\"purple\")\npoly(hextile(HexagonOffsetOddR(-1, -1, 40)), :fill)\nsethue(\"orange\")\npoly(hextile(HexagonOffsetOddR(-1, 1, 40)), :fill)\nsethue(\"green\")\npoly(hextile(HexagonOffsetOddR(1, 1, 40)), :fill)\nsethue(\"blue\")\npoly(hextile(HexagonOffsetOddR(1, -1, 40)), :fill)\nend 600 300  # hide","category":"page"},{"location":"howto/tables-grids/#Hexagonal-grid-indexing","page":"Work with tables and grids","title":"Hexagonal grid indexing","text":"","category":"section"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"Whereas rectangular grids can be indexed using x (\"column\") and y (\"row\") integers, hexagonal grids can be indexed in various ways. For example, odd-numbered \"rows\" can be shifted to the right:","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"using Luxor, Colors, Random  # hide\n@drawsvg begin  # hide\nfontsize(16)\nfor q in -2:2 # vertical\n    for r in -2:2 # horizontal\n        pgon = hextile(HexagonOffsetOddR(q, r, 40))\n        sethue(HSB(rand(1:360), 0.6, 0.7))\n        poly(pgon, :fill)\n        sethue(\"white\")\n        text(\"$q\", hexcenter(HexagonOffsetOddR(q, r, 40)),\n            halign=:left, valign=:top)\n        text(\"$r\", hexcenter(HexagonOffsetOddR(q, r, 40)),\n            halign=:right, valign=:bottom)\n    end\nend\nend 600 350  # hide","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"Alternatively, even-numbered \"rows\" can be shifted to the right:","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"using Luxor, Colors, Random  # hide\n@drawsvg begin # hide\nfontsize(16)\nfor q in -2:2 # vertical\n    for r in -2:2 # horizontal\n        pgon = hextile(HexagonOffsetEvenR(q, r, 40))\n        sethue(HSB(rand(1:360), 0.6, 0.7))\n        poly(pgon, :fill)\n        sethue(\"white\")\n        text(\"$q\", hexcenter(HexagonOffsetEvenR(q, r, 40)),\n            halign=:left, valign=:top)\n        text(\"$r\", hexcenter(HexagonOffsetEvenR(q, r, 40)),\n            halign=:right, valign=:bottom)\n    end\nend\nend 600 350 # hide","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"The cubic hexagon constructor accepts three coordinates: ","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"using Luxor, Colors, Random  # hide\n@drawsvg begin # hide\nfor q in -2:2 \n    for r in -2:2 \n        pgon = hextile(HexagonCubic(q, r, -q - r, 25))\n        sethue(HSB(rand(1:360), 0.6, 0.7))\n        poly(pgon, :fill)\n    end\nend\nend 600 350 # hide","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"The axial constructor accepts two:","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"using Luxor, Colors, Random  # hide\n@drawsvg begin # hide\nfor q in -2:2\n    for r in -2:2\n        pgon = hextile(HexagonAxial(q, r, 25))\n        sethue(HSB(rand(1:360), 0.6, 0.7))\n        poly(pgon, :fill)\n    end\nend\nend 600 350 # hide","category":"page"},{"location":"howto/tables-grids/#Hexagonal-rings","page":"Work with tables and grids","title":"Hexagonal rings","text":"","category":"section"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"The hexring() function finds the nth ring of adjacent hexagons surrounding a hexagon.","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"The first ring consists of six hexagons. Ring n consists of 6n hexagons. ","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"using Luxor # hide\nusing Colors # hide\n\n@drawsvg begin # hide\nhexa = HexagonOffsetOddR(0, 0, 10)\nfor i in 1:15\n    ring = hexring(i, hexa)\n    sethue(HSB(rescale(i, 1, 15, 0, 360), 0.8, 0.8))\n    for (n, h) in enumerate(ring)\n        poly(hextile(h), :fillpreserve)\n    end\nend\nend # hide","category":"page"},{"location":"howto/tables-grids/#Neighbouring-hexagons","page":"Work with tables and grids","title":"Neighbouring hexagons","text":"","category":"section"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"To find the six hexagons that surround a hexagon, use hexneighbors().","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"using Luxor # hide\nusing Colors # hide\n\n@drawsvg begin # hide\nfor i in 1:10\n    sethue(HSB(rand(0:360), 0.8, 0.8))\n    hex1 = HexagonOffsetOddR(rand(-7:7), rand(-7:7), 15)\n    for neighbor in hexneighbors(hex1)\n        poly(hextile(neighbor), :fill)\n        circle(hexcenter(neighbor), 25, :stroke)\n    end\nend\nend # hide","category":"page"},{"location":"howto/tables-grids/#Spiralling-hexagons","page":"Work with tables and grids","title":"Spiralling hexagons","text":"","category":"section"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"The hexspiral() function generates a spiral of hexagons around a central hexagon to form n rings of hexagons.","category":"page"},{"location":"howto/tables-grids/","page":"Work with tables and grids","title":"Work with tables and grids","text":"using Luxor, Colors\n@drawsvg begin # hide\nbackground(\"black\")\nhexagon = HexagonOffsetEvenR(0, 0, 16)\nsetline(0.75)\nfor (n, h) in enumerate(hexspiral(hexagon, 10))\n    sethue(HSB(mod1(5n, 360), 0.8, 0.8))\n    poly(hextile(h), :fillpreserve)\n    sethue(\"black\")\n    text(string(n), hexcenter(h), halign=:center)\n    strokepath()\nend\nend # hide","category":"page"},{"location":"example/moreexamples/","page":"More examples","title":"More examples","text":"DocTestSetup = quote\n    using Luxor, Colors\nend","category":"page"},{"location":"example/moreexamples/#More-examples","page":"More examples","title":"More examples","text":"","category":"section"},{"location":"example/moreexamples/","page":"More examples","title":"More examples","text":"One place to look for examples is the Luxor/test directory.","category":"page"},{"location":"example/moreexamples/","page":"More examples","title":"More examples","text":"(Image: \"tiled images\")","category":"page"},{"location":"example/moreexamples/#Illustrating-this-document","page":"More examples","title":"Illustrating this document","text":"","category":"section"},{"location":"example/moreexamples/","page":"More examples","title":"More examples","text":"This documentation was built with Documenter.jl, which is an amazingly powerful and flexible documentation generator written in Julia. The illustrations are mostly created when the HTML pages are built: the Julia source for the image is stored in the Markdown source document, and the code to create the images runs each time the documentation is generated.","category":"page"},{"location":"example/moreexamples/","page":"More examples","title":"More examples","text":"The Markdown markup looks like this:","category":"page"},{"location":"example/moreexamples/","page":"More examples","title":"More examples","text":"```@example\nusing Luxor, Random # hide\nDrawing(600, 250, \"../assets/figures/polysmooth-pathological.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetopacity(0.75) # hide\nRandom.seed!(42) # hide\nsetline(1) # hide\np = star(O, 60, 5, 0.35, 0, vertices=true)\nsetdash(\"dot\")\nsethue(\"red\")\nprettypoly(p, close=true, action = :stroke)\nsetdash(\"solid\")\nsethue(\"black\")\npolysmooth(p, 40, :fill, debug=true)\nfinish() # hide\n```\n\n![polysmooth](../assets/figures/polysmooth-pathological.png)","category":"page"},{"location":"example/moreexamples/","page":"More examples","title":"More examples","text":"and after you run Documenter's build process the HTML output looks like this:","category":"page"},{"location":"example/moreexamples/","page":"More examples","title":"More examples","text":"using Luxor, Random # hide\nDrawing(600, 250, \"../assets/figures/polysmoothy.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetopacity(0.75) # hide\nRandom.seed!(42) # hide\nsetline(1) # hide\np = star(O, 60, 5, 0.35, 0, vertices=true)\nsetdash(\"dot\")\nsethue(\"red\")\nprettypoly(p, close=true, action = :stroke)\nsetdash(\"solid\")\nsethue(\"black\")\npolysmooth(p, 40, :fill, debug=true)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"example/moreexamples/","page":"More examples","title":"More examples","text":"(Image: polysmooth)","category":"page"},{"location":"example/moreexamples/#Why-turtles?","page":"More examples","title":"Why turtles?","text":"","category":"section"},{"location":"example/moreexamples/","page":"More examples","title":"More examples","text":"An interesting application for turtle-style graphics is for drawing Lindenmayer systems (l-systems). Here's an example of how a complex pattern can emerge from a simple set of rules, taken from Lindenmayer.jl:","category":"page"},{"location":"example/moreexamples/","page":"More examples","title":"More examples","text":"(Image: penrose)","category":"page"},{"location":"example/moreexamples/","page":"More examples","title":"More examples","text":"The definition of this figure is:","category":"page"},{"location":"example/moreexamples/","page":"More examples","title":"More examples","text":"penrose = LSystem(Dict(\"X\"  =>  \"PM++QM----YM[-PM----XM]++t\",\n                       \"Y\"  => \"+PM--QM[---XM--YM]+t\",\n                       \"P\"  => \"-XM++YM[+++PM++QM]-t\",\n                       \"Q\"  => \"--PM++++XM[+QM++++YM]--YMt\",\n                       \"M\"  => \"F\",\n                       \"F\"  => \"\"),\n                  \"1[Y]++[Y]++[Y]++[Y]++[Y]\")","category":"page"},{"location":"example/moreexamples/","page":"More examples","title":"More examples","text":"where some of the characters—eg \"F\", \"+\", \"-\", and \"t\"—issue turtle control commands, and others—\"X,\", \"Y\", \"P\", and \"Q\"—refer to specific components of the design. The execution of the l-system involves replacing every occurrence in the drawing code of every dictionary key with the matching values.","category":"page"},{"location":"example/moreexamples/#Strange","page":"More examples","title":"Strange","text":"","category":"section"},{"location":"example/moreexamples/","page":"More examples","title":"More examples","text":"It's usually better to draw fractals and similar images using pixels and image processing tools. But just for fun it's an interesting experiment to render a strange attractor image using vector drawing rather than placing pixels.","category":"page"},{"location":"example/moreexamples/","page":"More examples","title":"More examples","text":"using Luxor, Colors\nfunction strange(dotsize, w=800.0)\n    xmin = -2.0; xmax = 2.0; ymin= -2.0; ymax = 2.0\n    Drawing(w, w, \"../assets/figures/strange-vector.png\")\n    origin()\n    background(\"grey5\")\n    xinc = w / (xmax - xmin)\n    yinc = w / (ymax - ymin)\n    # control parameters\n    a = 2.24\n    b = 0.43\n    c = -0.65\n    d = -2.43\n    e1 = 1.0\n    x = y = z = 0.0\n    wover2 = w / 2 - 50 # margin\n    for j = 1:w\n        for i = 1:w\n            xx = sin(a * y) - z * cos(b * x)\n            yy = z * sin(c * x) - cos(d * y)\n            zz = e1 * sin(x)\n            x = xx\n            y = yy\n            z = zz\n            if xx < xmax && xx > xmin\n                if yy < ymax && yy > ymin\n                    xpos = rescale(\n                        xx,\n                        xmin,\n                        xmax,\n                        -wover2,\n                        wover2,\n                    ) # scale to range\n                    ypos = rescale(\n                        yy,\n                        ymin,\n                        ymax,\n                        -wover2,\n                        wover2,\n                    ) # scale to range\n                    rcolor = rescale(xx, -1, 1, 0.0, 0.6)\n                    gcolor = rescale(yy, -1, 1, 0.2, 0.5)\n                    bcolor = rescale(zz, -1, 1, 0.6, 0.9)\n                    setcolor(rcolor, gcolor, bcolor)\n                    move(Point(xpos, ypos))\n                    line(Point(xpos + dotsize, ypos))\n                    line(Point(\n                        xpos + dotsize,\n                        ypos + dotsize,\n                    ))\n                    line(Point(xpos, ypos + dotsize))\n                    fillpath()\n                end\n            end\n        end\n    end\n    finish()\nend\n\nstrange(.5, 800)\nnothing # hide","category":"page"},{"location":"example/moreexamples/","page":"More examples","title":"More examples","text":"(Image: strange attractor in vectors)","category":"page"},{"location":"example/moreexamples/","page":"More examples","title":"More examples","text":"This example generates about 650,000 paths, which is why it’s better to target PNG rather than SVG or PDF for this example. Also for speed, the “dots” are actually simple square paths, which are slightly quicker to draw than circles or polygons.","category":"page"},{"location":"example/moreexamples/#More-animations","page":"More examples","title":"More animations","text":"","category":"section"},{"location":"example/moreexamples/","page":"More examples","title":"More examples","text":"(Image: strange attractor in vectors)","category":"page"},{"location":"example/moreexamples/","page":"More examples","title":"More examples","text":"Most of the animations on this YouTube channel are made with Luxor.","category":"page"},{"location":"example/moreexamples/#The-Luxor-logo","page":"More examples","title":"The Luxor logo","text":"","category":"section"},{"location":"example/moreexamples/","page":"More examples","title":"More examples","text":"using Luxor, Colors\n\nfunction set_gold_blend()\n    gblend = blend(O, 0, O, 250, \"gold2\", \"gold3\")\n    setblend(gblend)\nend\n\nfunction draw_scarab_legs(pos)\n    translate(pos)\n    # legs\n    @layer begin\n        for i in 1:2\n            move(O)\n            rline.((polar(80, -π/6),\n                polar(70, -π/2),\n                polar(12, -5π/6),\n                polar(60, -π/4)))\n\n            #middle leg\n            move(0, 40)\n            rline.((\n                polar(120, -π/6),\n                polar(40, π/2)))\n\n            #back leg\n            move(0, 100)\n            rline.((\n                polar(130, -π/6),\n                polar(110, π/2)))\n\n            # flip for other leg\n            transform([-1 0 0 1 0 0])\n        end\n    end\nend\n\nfunction draw_scarab_body()\n    @layer begin\n        squircle(Point(0, -25), 26, 75, action=:path)\n        squircle(Point(0, 0), 50, 70, action=:path)\n        squircle(Point(0, 40), 65, 90, action=:path)\n    end\nend\n\nfunction draw()\n    @drawsvg begin\n    setopacity(1.0)\n    setline(20)\n    setlinecap(\"butt\")\n    setlinejoin(\"round\")\n    width = 180\n    height= 240\n\n    sethue(\"black\")\n    squircle(O, width, height-5, rt=0.4, action=:fill)\n\n    set_gold_blend()\n    squircle(O, width, height-5, rt=0.4, action=:path)\n    translate(0, 50)\n    draw_scarab_legs(O)\n    strokepath()\n    draw_scarab_body()\n    fillpath()\n\n    # julia dots === Ra egyptian sun deity\n    @layer begin\n        translate(0, -190)\n        circle(O, 48, action=:fill)\n        juliacircles(20)\n    end\n\n    clipreset()\n    end\nend\n\ndraw()","category":"page"},{"location":"example/moreexamples/#A-Japanese-style-Temple-scene","page":"More examples","title":"A Japanese-style Temple scene","text":"","category":"section"},{"location":"example/moreexamples/","page":"More examples","title":"More examples","text":"This code was created by kfung, a student that participated in Google Code-in 2019 competition.","category":"page"},{"location":"example/moreexamples/","page":"More examples","title":"More examples","text":"using Luxor\nDrawing(1280, 720, \"../assets/figures/temple.png\")\norigin()\nsetblend(blend(Point(0, -200), Point(0, 300), \"#F38070\", \"#F3C3BC\"))\nbox(O, 1280, 720, :fill)\nsethue(\"#F7C5BC\")\nsetopacity(0.3)\nsun = Point(450, -225)\npoly([sun, Point(400, 400), Point(640, 400), sun], :fill)\npoly([sun, Point(-150, 400), Point(150, 400), sun], :fill)\npoly([sun, Point(-640, 400), Point(-640, 0), sun], :fill)\npoly([sun, Point(-640, -150), Point(-640, -450), sun], :fill)\npoly([sun, Point(100, -360), Point(300, -360), sun], :fill)\npoly([sun, Point(375, -400), Point(475, -400), sun], :fill)\npoly([sun, Point(585, -400), Point(775, -400), sun], :fill)\npoly([sun, Point(640, -265), Point(640, -175), sun], :fill)\npoly([sun, Point(640, -100), Point(640, 125), sun], :fill)\nsethue(\"#C02C20\")\nsetopacity(1)\ncircle(450, -225, 40, :fill)\nsethue(\"white\")\nsetopacity(0.98)\nellipse(20, -275, 150, 75, :fill)\nellipse(-20, -240, 150, 50, :fill)\nellipse(60, -245, 150, 50, :fill)\nellipse(-450, -240, 150, 50, :fill)\nellipse(-350, -250, 150, 50, :fill)\nellipse(430, -90, 200, 10, :fill)\nellipse(470, -95, 200, 10, :fill)\nsetopacity(0.8)\nellipse(-450, -130, 200, 10, :fill)\nellipse(-490, -135, 200, 10, :fill)\nsetopacity(1)\nsethue(\"#2E951A\")\ndrawbezierpath(makebezierpath([Point(-780, 500), Point(-640, 100), Point(-560, -20), Point(-480, -80), Point(-400, -80), Point(-320, -20), Point(-240, 100), Point(-240, 500)]), :fill, close=false)\nsethue(\"#37C61B\")\ndrawbezierpath(makebezierpath([Point(-780, 500), Point(-640, 200), Point(-560, 100), Point(-480, 40), Point(-400, 30), Point(-320, 70), Point(-240, 150), Point(-240, 500)]), :fill, close=false)\nsethue(\"#23AE34\")\nsetopacity(1)\nellipse(530, 90, 100, 100, :fill)\nellipse(490, 150, 80, 80, :fill)\nellipse(570, 150, 80, 80, :fill)\nsethue(\"#713D1D\")\nbox(530, 220, 15, 290, :fill)\nsetline(15)\nline(Point(530,180), Point(565, 125), action = :stroke)\nline(Point(530,140), Point(495, 105), action = :stroke)\nsethue(\"#E13705\")\ncircle(480, 150, 8, :fill)\ncircle(560, 100, 8, :fill)\ncircle(510, 70, 8, :fill)\ncircle(580, 160, 8, :fill)\n[circle(544+16*(i-1), 292, 8, :fill) for i in 1:3]\ncircle(552, 278, 8, :fill)\ncircle(512, 292, 8, :fill)\ncircle(496, 292, 8, :fill)\nsethue(\"white\")\nsetline(10)\nline(Point(440, 300), Point(440, 250), action = :stroke)\npoly([Point(410, 250), Point(395, 235), Point(410, 220), Point(465, 220), Point(465, 250)], :fill)\nsethue(\"black\")\nfontsize(12)\nfontface(\"Arial\")\ntext(\"THIS WAY\", Point(434, 241), halign=:center,  valign = :center)\nsetopacity(1)\nsethue(\"#2A3A4A\")\nbox(0, 330, 1280, 60, :fill)\nsetline(20)\nsetopacity(1)\ndrawbezierpath(makebezierpath([Point(-570, 320), Point(-500, 270), Point(-400, 230), Point(-550, 200), Point(-360, 160), Point(-460, 110), Point(-342, 70), Point(-340, 70)]), action = :stroke, close=false)\ncircle(-340, 69, 10, :fill)\ncircle(-336, 67, 10, :fill)\nsetopacity(1)\nsethue(\"white\")\n[box(-600+100*(i-1), 330, 50, 5, :fill) for i in 1:13]\nsethue(\"#E7D1BC\")\nbox(0, 240, 700, 120, :fill)\nbox(0, 150, 300, 120, :fill)\nbox(0, 40, 500, 120, :fill)\nsethue(\"#EE766B\")\n[circle((-400+20*(i-1)), 180, 10, :fill) for i in 1:41]\n[circle((-270+20*(i-1)), -20, 10, :fill) for i in 1:28]\nsethue(\"#D14A3E\")\npoly([Point(-420, 180), Point(420, 180), Point(250, 70), Point(-250, 70), Point(-420, 180)], :fill)\npoly([Point(-290, -20), Point(290, -20), Point(150, -120), Point(-150, -120), Point(-290, -20)], :fill)\ncircle(0, 58, 10, :fill)\ncircle(0, 45, 4, :fill)\nsethue(\"#B71909\")\npoly([Point(0, 55), Point(140, 180), Point(-140, 180), Point(0, 55)], :fill)\nsethue(\"#E7D1BC\")\npoly([Point(0, 70), Point(159, 210), Point(-159, 210), Point(0, 70)], :fill)\nsethue(\"black\")\n[box(-180+120*(i-1), 30, 20, 40, :fill) for i in 1:4]\nbox(-300, 240, 20, 40, :fill)\nbox(-200, 240, 20, 40, :fill)\nbox(200, 240, 20, 40, :fill)\nbox(300, 240, 20, 40, :fill)\nsethue(\"#C99A6F\")\nbox(-130, 240, 10, 120, :fill)\nbox(130, 240, 10, 120, :fill)\npoly([Point(0, 85), Point(91, 165), Point(-91, 165), Point(0, 85)], :fill)\nsethue(\"black\")\nbox(0, 258, 88, 84, :fill)\nsethue(\"#C99A6F\")\nbox(-20, 260, 38, 80, :fill)\nbox(20, 260, 38, 80, :fill)\nsethue(\"black\")\ncircle(-10, 260, 4, :fill)\ncircle(10, 260, 4, :fill)\nfinish()\nnothing # hide","category":"page"},{"location":"example/moreexamples/","page":"More examples","title":"More examples","text":"(Image: temple)","category":"page"},{"location":"explanation/strokepathdispatch/#Custom-behavior-for-strokepath-and-fillpath","page":"Customize strokepath/fillpath","title":"Custom behavior for strokepath and fillpath","text":"","category":"section"},{"location":"explanation/strokepathdispatch/","page":"Customize strokepath/fillpath","title":"Customize strokepath/fillpath","text":"There are four functions that \"paint\" the current path to the drawing: they are strokepath , strokepreserve , fillpath, and fillpreserve. Other mechanisms to draw on the canvas are clip , clippreserve and paint. (text is another function that draws on the canvas but is not considered here)","category":"page"},{"location":"explanation/strokepathdispatch/","page":"Customize strokepath/fillpath","title":"Customize strokepath/fillpath","text":"If you would like to have some custom behavior for these functions, such as adding a way to extract or modify paths etc.), Luxor provides a way to do so.","category":"page"},{"location":"explanation/strokepathdispatch/","page":"Customize strokepath/fillpath","title":"Customize strokepath/fillpath","text":"These four functions are basically defined as: ","category":"page"},{"location":"explanation/strokepathdispatch/","page":"Customize strokepath/fillpath","title":"Customize strokepath/fillpath","text":"funcname() = funcname(DISPATCHER[1]) funcname(::DefaultLuxor) = {...do_some_graphics_work...} funcname(::LDispatcher) = funcname(DefaultLuxor())","category":"page"},{"location":"explanation/strokepathdispatch/","page":"Customize strokepath/fillpath","title":"Customize strokepath/fillpath","text":"DISPATCHER[1] is defined as an instance of a struct (with no fields)  DefaultLuxor. The datatype DefaultLuxor is a subtype of LDispatcher. DISPATCHER as such is defined as an array of LDispatcher. This is to make it mutable. Only the first element ie. DISPATCHER[1] is ever used. ","category":"page"},{"location":"explanation/strokepathdispatch/","page":"Customize strokepath/fillpath","title":"Customize strokepath/fillpath","text":"You can make custom behavior for the functions in the following way:","category":"page"},{"location":"explanation/strokepathdispatch/","page":"Customize strokepath/fillpath","title":"Customize strokepath/fillpath","text":"1 Define a new struct MyDispatcher <: Luxor.LDispatcher (it needn't have any fields).","category":"page"},{"location":"explanation/strokepathdispatch/","page":"Customize strokepath/fillpath","title":"Customize strokepath/fillpath","text":"2 Define a function that dispatches on the above struct.","category":"page"},{"location":"explanation/strokepathdispatch/","page":"Customize strokepath/fillpath","title":"Customize strokepath/fillpath","text":"3 Change Luxor.DISPATCHER[1] to an instance of your struct. ","category":"page"},{"location":"explanation/strokepathdispatch/","page":"Customize strokepath/fillpath","title":"Customize strokepath/fillpath","text":"Here's an example of a method that changes the behavior of all calls to strokepath() such that the current color is printed to the terminal as the path is drawn.","category":"page"},{"location":"explanation/strokepathdispatch/","page":"Customize strokepath/fillpath","title":"Customize strokepath/fillpath","text":"struct MyDispatcher <: Luxor.LDispatcher end\nfunction Luxor.strokepath(::MyDispatcher)\n    println(\"$(Luxor.get_current_color())\")\n\treturn Luxor.strokepath(Luxor.DefaultLuxor())\nend\nLuxor.DISPATCHER[1] = MyDispatcher()\n\n@draw begin\n    for i in 1:20\n        randomhue()\n        star(rand(BoundingBox()), 30, 6, 0.5, action = :stroke)\n    end\nend","category":"page"},{"location":"explanation/strokepathdispatch/","page":"Customize strokepath/fillpath","title":"Customize strokepath/fillpath","text":"Now, all calls to strokepath() whether explicitly called or through other functions (for example, with the :stroke action) will print the current color  just before the path is stroked.","category":"page"},{"location":"explanation/strokepathdispatch/","page":"Customize strokepath/fillpath","title":"Customize strokepath/fillpath","text":"Similar dispatches can be written for strokepreserve, fillpath, fillpreserve, clip, clippreserve, and paint. ","category":"page"},{"location":"explanation/strokepathdispatch/","page":"Customize strokepath/fillpath","title":"Customize strokepath/fillpath","text":"Functions which don't have methods defined for the types will default to calling funcname(Luxor.DefaultLuxor())","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"DocTestSetup = quote\n    using Luxor, Colors\n    end","category":"page"},{"location":"explanation/basics/#The-drawing-model","page":"Basic concepts","title":"The drawing model","text":"","category":"section"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"The underlying drawing model is that you build paths, and these are filled and/or stroked, using the current graphics state, which specifies colors, line thicknesses, scale, orientation, opacity, and so on.","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"You can modify the current graphics state by transforming/rotating/scaling it, setting color and style parameters, and so on. Subsequent graphics use the new state, but the graphics you've already drawn are unchanged.","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"Many of the drawing functions have an action argument, supplied as a keyword argument (eg action=:fill). This action determines what happens to the current path. It can be :fill, :stroke, :fillstroke, :fillpreserve, :strokepreserve, :clip, or :path. The default is usually :path, ie. add the graphics to the current path.","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"The main Julia data types you'll encounter in Luxor are:","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"Name of type Purpose\nDrawing holds the current drawing\nPoint specifies 2D points\nBoundingBox defines a bounding box\nTable defines a table with different column widths and row  heights\nPartition defines a table defined by cell width and height\nTiler defines a rectangular grid of tiles\nBezierPathSegment a Bezier path segment defined by 4 points\nBezierPath contains a series of BezierPathSegments\nGridRect defines a rectangular grid\nGridHex defines a hexagonal grid\nScene used to define a scene for an animation\nTurtle represents a turtle for drawing turtle graphics\nPath contains a complete path","category":"page"},{"location":"explanation/basics/#Points-and-coordinates","page":"Basic concepts","title":"Points and coordinates","text":"","category":"section"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"You specify points on the drawing surface using Point(x, y).","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"The default origin (ie the x = 0, y = 0 point) is at the top left corner: the x axis runs left to right across the page, and the y axis runs top to bottom down the page, so Y coordinates increase downwards.","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"By default, Point(0, 100) is below Point(0, 0).","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"using Luxor\nsvgimage = @drawsvg begin\nsethue(\"antiquewhite\")\nbox(boxtopleft(BoundingBox() + (40, 40)), boxbottomright(BoundingBox() - (40, 40)), action = :fill)\ntranslate(boxtopleft(BoundingBox() + (40, 40)))\nsethue(\"black\")\ncircle(Point(0, 0), 6, action = :fill)\nlabel(\"(0, 0)\", :se, Point(0, 0), offset=15)\ncircle(Point(0, 100), 6, action = :fill)\nlabel(\"(0, 100)\", :se, Point(0, 100), offset=15)\nrulers()\nend","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"svgimage # hide","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"note: Note\nAlthough this is the preferred coordinate system for most computer graphics software, including Luxor and Cairo, but mathematicians and scientists may well be used to the other convention, where the origin is in the center of the drawing and the y-axis increases up the page. See the macros such as @png, @svg, and @pdf which will put the origin at the center for you.","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"You can reposition the origin at any time, using origin. The 'user space' can be modified by functions such as scale, translate, and rotate, or more directly using matrix transforms.","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"The Point type holds two coordinates, x and y. For example:","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"julia> P = Point(12.0, 13.0)\nLuxor.Point(12.0, 13.0)\n\njulia> P.x\n12.0\n\njulia> P.y\n13.0","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"Points are immutable, so you can't change P's x or y values directly. But it's easy to make new points based on existing ones.","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"Points can be added together:","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"julia> Q = Point(4, 5)\nLuxor.Point(4.0, 5.0)\n\njulia> P + Q\nLuxor.Point(16.0, 18.0)","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"You can add and multiply Points and scalars:","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"julia> 10P\nLuxor.Point(120.0, 130.0)\n\njulia> P + 100\nLuxor.Point(112.0, 113.0)","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"You can also make new points by mixing Points and tuples:","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"julia> P + (10, 0)\nLuxor.Point(22.0, 13.0)\n\njulia> Q * (0.5, 0.5)\nLuxor.Point(2.0, 2.5)","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"You can also create points from tuples:","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"julia> Point((1.0, 14))\nPoint(1.0, 14.0)\n\njulia> plist = (1.0, 2.0), (-10, 10), (14.2, 15.4);\n\njulia> Point.(plist)\n3-element Array{Point,1}:\n Point(1.0, 2.0)\n Point(-10.0, 10.0)\n Point(14.2, 15.4)","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"You can use the letter O as a shortcut to refer to the current Origin, Point(0, 0). Most coding fonts clearly show the difference between the letter O and the digit 0.","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"using Luxor # hide\nDrawing(600, 300, \"../assets/figures/point-ex.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsethue(\"blue\") # hide\nrulers()\nbox.([O + (i, 0) for i in range(0, stop=200, length=5)], 20, 20, action = :stroke)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"(Image: point example)","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"Angles are usually supplied in radians, measured starting at the positive x-axis turning towards the positive y-axis (which usually points 'down' the page or canvas). So rotations look ‘clockwise’. (The main exception is for turtle graphics, which conventionally let you supply angles in degrees.)","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"Coordinates are usually interpreted as PostScript points, where a point is 1/72 of an inch, or as pixels, at a DPI of 72ppi.","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"Because Julia allows you to combine numbers and variables directly, you can supply units with dimensions and have them converted to points (assuming the current scale is 1:1):","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"inch (in is unavailable, being used by for syntax)\ncm   (centimeters)\nmm   (millimeters)","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"For example:","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"rect(Point(20mm, 2cm), 5inch, (22/7)inch, action = :fill)","category":"page"},{"location":"explanation/basics/#The-drawing-surface","page":"Basic concepts","title":"The drawing surface","text":"","category":"section"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"The origin function moves the 0/0 point to the center of the drawing. It's often convenient to do this at the beginning of a program.","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"You can use functions like scale, rotate, and translate to change the coordinate system.","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"background usually fills the drawing with a color, covering any previous contents. By default, PDF drawings have a white background, whereas PNG drawings have no background so that the background appears transparent in other applications. ","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"If there is a current clipping region, background fills just that region. In the next example, the first background fills the entire drawing with magenta, but the calls in the loop fill only the active clipping region, a table cell defined by the Table iterator:","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"using Luxor # hide\nDrawing(600, 400, \"../assets/figures/backgrounds.png\") # hide\nbackground(\"magenta\")\norigin()\ntable = Table(5, 5, 100, 50)\nfor (pos, n) in table\n    box(pos,\n        table.colwidths[table.currentcol],\n        table.rowheights[table.currentrow],\n        action = :clip)\n    background(randomhue()...)\n    clipreset()\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"(Image: background)","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"The rulers function draws a couple of rulers to indicate the position and orientation of the current axes.","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"using Luxor # hide\nDrawing(400, 400, \"../assets/figures/axes.png\") # hide\nbackground(\"gray80\")\norigin()\nrulers()\nfinish() # hide\nnothing # hide","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"(Image: axes)","category":"page"},{"location":"explanation/basics/#Save-and-restore:-layers-and-state","page":"Basic concepts","title":"Save and restore: layers and state","text":"","category":"section"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"gsave saves a copy of the current graphics settings (current axis rotation, position, scale, line and text settings, color, and so on). When the next grestore is called, all changes you've made to the graphics settings will be discarded, and the previous settings are restored, so things return to how they were when you last used gsave. gsave and grestore should always be balanced in pairs, enclosing the functions.","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"@svg begin\n    circle(Point(0, 0), 100, action = :stroke)\n    gsave()\n        sethue(\"red\")\n        rule(Point(0, 0))\n        rule(Point(0, 0), pi/2)\n    grestore()\n    circle(Point(0, 0), 200, action = :stroke)\nend","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"The @layer macro is a shorter synonym for a gsave...grestore pair.","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"@svg begin\n    circle(Point(0, 0), 100, action = :stroke)\n    @layer (sethue(\"red\"); rule(Point(0, 0)); rule(O, π/2))\n    circle(Point(0, 0), 200, action = :stroke)\nend","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"or","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"@svg begin\n    circle(Point(0, 0), 100, action = :stroke)\n    @layer begin\n        sethue(\"red\")\n        rule(Point(0, 0))\n        rule(Point(0, 0), pi/2)\n    end\n    circle(Point(0, 0), 200, action = :stroke)\nend","category":"page"},{"location":"explanation/basics/#Return-the-current-drawing","page":"Basic concepts","title":"Return the current drawing","text":"","category":"section"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"In some situations you'll want to explicitly return the current drawing to the calling function. Use currentdrawing or assign the result of Drawing() to a variable.","category":"page"},{"location":"explanation/basics/#Working-in-IDEs-and-notebooks","page":"Basic concepts","title":"Working in IDEs and notebooks","text":"","category":"section"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"You can use an environment such as a Jupyter or Pluto notebook or the Juno or VS Code IDEs, and load Luxor at the start of a session. The first drawing will take a few seconds, because the Cairo graphics engine needs to warm up. Subsequent drawings are then much quicker. (This is true of much graphics and plotting work. Julia compiles each function when it first encounters it, and then calls the compiled versions for the rest of the session.)","category":"page"},{"location":"explanation/basics/#Working-in-Jupyter","page":"Basic concepts","title":"Working in Jupyter","text":"","category":"section"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"(Image: Jupyter)","category":"page"},{"location":"explanation/basics/#Working-in-VS-Code","page":"Basic concepts","title":"Working in VS Code","text":"","category":"section"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"(Image: VS Code)","category":"page"},{"location":"explanation/basics/#Working-in-Pluto","page":"Basic concepts","title":"Working in Pluto","text":"","category":"section"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"(Image: Pluto)","category":"page"},{"location":"explanation/basics/#SVG-images","page":"Basic concepts","title":"SVG images","text":"","category":"section"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"Luxor can create new SVG images, either in a file or in memory, and can also place existing SVG images on a drawing. See Placing images for more. It's also possible to obtain the source of the current SVG drawing as a string. For example, this code draws the Julia logo using SVG code and stores the SVG in s:","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"Drawing(500, 500, :svg)\norigin()\njulialogo()\nfinish()\ns = svgstring()","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"You can now examine the SVG elements in s programmatically:","category":"page"},{"location":"explanation/basics/","page":"Basic concepts","title":"Basic concepts","text":"eachmatch(r\"rgb\\(.*?\\)\", s) |> collect\n5-element Vector{RegexMatch}:\n RegexMatch(\"rgb(0%,0%,0%)\")\n RegexMatch(\"rgb(79.6%,23.5%,20%)\")\n RegexMatch(\"rgb(25.1%,38.8%,84.7%)\")\n RegexMatch(\"rgb(58.4%,34.5%,69.8%)\")\n RegexMatch(\"rgb(22%,59.6%,14.9%)\")","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"DocTestSetup = quote\n    using Luxor, Colors, Random\n    end","category":"page"},{"location":"howto/simplegraphics/#Simple-graphics","page":"Draw simple shapes","title":"Simple graphics","text":"","category":"section"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"In Luxor, there are different ways of working with graphical items:","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"Draw them immediately. Create lines and curves to build a path on the drawing. When you paint the path, the graphics are ‘fixed’, and you move on to the next.\nConstruct arrays of points - polygons - which you can draw at some later point. Watch out for a vertices=true option, which returns coordinate data rather than adding shapes to the current path.\nYou can combine these two approaches: create a path from lines and curves (and jumps), then store the path, ready for drawing later on.","category":"page"},{"location":"howto/simplegraphics/#Line-width","page":"Draw simple shapes","title":"Line width","text":"","category":"section"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"The default line width in Luxor is 2 points. (Typically 1 point is 0.352777mm, 1/72.0inch.) Set the line width with setline. Find the current line width with getline. By default, line widths don't vary depending on the current drawing scale, but you can ask for them to be scaled - see Scaling-of-line-thickness.","category":"page"},{"location":"howto/simplegraphics/#Rectangles-and-boxes","page":"Draw simple shapes","title":"Rectangles and boxes","text":"","category":"section"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"Simple rectangle and box shapes can be made in different ways.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 220, \"../assets/figures/basicrects.png\") # hide\nbackground(\"antiquewhite\") # hide\norigin() # hide\nrulers()\nsethue(\"grey40\")\nrect(Point(0, 0), 100, 100, action = :stroke)\nsethue(\"blue\")\nbox(Point(0, 0), 100, 100, action=:stroke)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: rect vs box)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"rect rectangles are positioned by a corner, a box made with box can be defined either by its center and dimensions, or by two opposite corners.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor\nd = @drawsvg begin\n    background(\"antiquewhite\")\n    panes = Table(fill(100, 1), fill(200, 4))\n\n    fontsize(14)\n    fontface(\"JuliaMono-Bold\")\n    @layer begin\n        translate(panes[1])\n        p1 = Point(-70, -70)\n        p2 = Point(70, 70)\n        box(p1, p2, action = :stroke)\n        text(\"box(p1, p2\", boxbottomcenter(BoundingBox(box(O, 140, 140)) + (0, 20)), halign=:center)\n        sethue(\"purple\")\n        circle.((p1, p2), 8, action = :fill)\n        label.([\"p1\", \"p2\"], [:N, :S], [p1, p2], offset=20)\n    end\n    @layer begin\n        translate(panes[2])\n        p = Point(0, 0)\n        box(p, 140, 140, action = :stroke)\n        text(\"box(p, w, h\", boxbottomcenter(BoundingBox(box(O, 140, 140)) + (0, 20)), halign=:center)\n        sethue(\"purple\")\n        circle(p, 8, action = :fill)\n        label(\"p\", :S, p, offset=20)\n        corners = box(BoundingBox(box(p, 140, 140))...)\n        arrow(corners[2] + (0, -15), corners[3] + (0, -15), decorate = () -> text(\"w\", O + (0, -10)))\n        arrow(corners[2] + (-15, 0), corners[1] + (-15, 0), decorate = () -> text(\"h\", O + (0, 10), angle=-π/2))                \n    end\n    @layer begin\n        translate(panes[3])\n        pt = Point(-70, -70)\n        rect(pt, 140, 140, action = :stroke)\n        text(\"rect(pt, w, h\", boxbottomcenter(BoundingBox(box(O, 140, 140)) + (0, 20)), halign=:center)\n        sethue(\"purple\")\n        circle(pt, 8, action = :fill)\n        label(\"pt\", :SE, pt, offset=20)\n        corners = box(BoundingBox(box(O, 140, 140))...)\n        arrow(corners[2] + (0, -15), corners[3] + (0, -15), decorate = () -> text(\"w\", O + (0, -10)))\n        arrow(corners[2] + (-15, 0), corners[1] + (-15, 0), decorate = () -> text(\"h\", O + (0, 10), angle=-π/2))\n    end\n    @layer begin\n        translate(panes[4])\n        sethue(\"purple\")\n        s = star(O, 70, 5, 0.5, 0, action = :stroke)\n        sethue(\"black\")\n        box(BoundingBox(s), action = :stroke)\n        text(\"BoundingBox(poly...)\", boxbottomcenter(BoundingBox(box(O, 140, 140)) + (0, 20)), halign=:center)\n    end\nend 800 250","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"d # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"If you want the coordinates of the corners of a box, rather than draw one immediately, use:","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"box(centerpoint, width, height, vertices=true)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"or","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"box(corner1,  corner2, vertices=true)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"box is also able to draw some of the other Luxor objects, such as BoundingBoxes and Table cells, and usually also returns the coordinates of the corners.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"box(Point(0, 0), 100, 100)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"4-element Array{Point,1}:\n Point(-50.0, 50.0)\n Point(-50.0, -50.0)\n Point(50.0, -50.0)\n Point(50.0, 50.0)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"To draw a box/rectangle with rounded corners, supply one or four values for corner radii.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 250, \"../assets/figures/round-rect-1.png\") # hide\norigin() # hide\nbackground(\"antiquewhite\") # hide\nsetline(6)\nsethue(\"black\") # hide\nbox(O, 200, 150, 10, action = :stroke) # 1 value for all corners\nsethue(\"purple\")\nbox(O, 260, 220, [0, 15, 40, 80], action = :stroke) # different for each\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: rounded rect 1)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"Or you could smooth the sharp corners of a box, like so:","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 250, \"../assets/figures/round-rect.png\") # hide\norigin() # hide\nbackground(\"antiquewhite\") # hide\nsethue(\"black\") # hide\nsetline(4)\npolysmooth(box(O, 200, 150, vertices=true), 10, action = :stroke)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: rounded rect)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"The squircle function makes nicer shapes.","category":"page"},{"location":"howto/simplegraphics/#Triangles,-pentagons,-and-regular-polygons","page":"Draw simple shapes","title":"Triangles, pentagons, and regular polygons","text":"","category":"section"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"For regular polygons, pentagons, and so on, see the section on Polygons and paths. If you like drawing hexagons, you could also read Hexagonal grids.","category":"page"},{"location":"howto/simplegraphics/#Circles-and-ellipses","page":"Draw simple shapes","title":"Circles and ellipses","text":"","category":"section"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"There are various ways to make circles, including by center and radius, or passing through two or three points:","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 200, \"../assets/figures/circles.png\") # hide\nbackground(\"antiquewhite\") # hide\n\norigin() # hide\nsetline(3) # hide\nsethue(\"black\")\np1 = Point(0, -50)\np2 = Point(100, 0)\np3 = Point(0, 65)\nmap(p -> circle(p, 4, action = :fill), [p1, p2, p3])\nsethue(\"orange\")\ncircle(center3pts(p1, p2, p3)..., action = :stroke)\n\nsethue(\"red\")\np1 = Point(0, 30)\np2 = Point(20, -40)\np3 = Point(50, 5)\ncircle.((p1, p2, p3), 3, action = :stroke)\ncircle(p1, p2, p3, action = :stroke)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: circles)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"The center3pts function returns the center position and radius of a circle passing through three points:","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor, Random # hide\nDrawing(800, 200, \"../assets/figures/center3.png\") # hide\nbackground(\"antiquewhite\") # hide\norigin() # hide\nsetline(3) # hide\nsethue(\"black\")\np1 = Point(0, -50)\np2 = Point(100, 0)\np3 = Point(0, 65)\nmap(p -> circle(p, 4, action = :fill), [p1, p2, p3])\nsethue(\"orange\")\ncircle(center3pts(p1, p2, p3)..., action = :stroke)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: center and radius of 3 points)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"With ellipse you can place ellipses and circles by defining the center point and the width and height.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor, Random # hide\nDrawing(800, 300, \"../assets/figures/ellipses.png\") # hide\nbackground(\"antiquewhite\") # hide\nfontsize(11) # hide\nRandom.seed!(1) # hide\norigin() # hide\ntiles = Tiler(500, 300, 5, 5)\nwidth = 20\nheight = 25\nfor (pos, n) in tiles\n    global width, height\n    randomhue()\n    ellipse(pos, width, height, action = :fill)\n    sethue(\"black\")\n    label = string(round(width/height, digits=2))\n    textcentered(label, pos.x, pos.y + 25)\n    width += 2\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: ellipses)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"ellipse can also construct polygons that are approximations to ellipses. You supply two focal points and a length which is the sum of the distances of a point on the perimeter to the two focii.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor, Random # hide\nDrawing(800, 220, \"../assets/figures/ellipses_1.png\") # hide\norigin() # hide\nbackground(\"antiquewhite\") # hide\n\nRandom.seed!(42) # hide\nsethue(\"black\") # hide\nsetline(1) # hide\nfontface(\"Menlo\")\n\nf1 = Point(-100, 0)\nf2 = Point(100, 0)\n\ncircle.([f1, f2], 3, action = :fill)\n\nepoly = ellipse(f1, f2, 250, vertices=true)\npoly(epoly, action = :stroke,  close=true)\n\npt = epoly[rand(1:end)]\n\npoly([f1, pt, f2], action = :stroke)\n\nlabel(\"f1\", :W, f1, offset=10)\nlabel(\"f2\", :E, f2, offset=10)\n\nlabel(string(round(distance(f1, pt), digits=1)), :SE, midpoint(f1, pt))\nlabel(string(round(distance(pt, f2), digits=1)), :SW, midpoint(pt, f2))\n\nlabel(\"ellipse(f1, f2, 250)\", :S, Point(0, 75))\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: more ellipses)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"The advantage of this method is that there's a vertices=true option, allowing further scope for polygon manipulation.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 450, \"../assets/figures/ellipses_2.png\") # hide\norigin() # hide\nbackground(\"antiquewhite\") # hide\nsethue(\"gray30\") # hide\nsetline(1) # hide\nf1 = Point(-100, 0)\nf2 = Point(100, 0)\nellipsepoly = ellipse(f1, f2, 170, :none, vertices=true)\n[ begin\n    setgray(rescale(c, 150, 1, 0, 1))\n    poly(offsetpoly(ellipsepoly, c), close=true, action = :fill);\n    rotate(π/20)\n  end\n     for c in 150:-10:1 ]\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: even more ellipses)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"The ellipseinquad function constructs an ellipse that fits inside a four-sided quadrilateral.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 600, \"../assets/figures/ellipseinquad.png\") # hide\norigin() # hide\nbackground(\"antiquewhite\") # hide\nsethue(\"gray30\") # hide\nsetline(1) # hide\n\npg = ngon(O, 250, 6, π/6, vertices=true)\n\ntop = vcat(O, pg[[3, 4, 5]])\nleft = vcat(O, pg[[1, 2, 3]])\nright = vcat(O, pg[[5, 6, 1]])\nsethue(\"red\")\npoly(top, action = :fill, close=true)\n\nsethue(\"green\")\npoly(left, action = :fill, close=true)\n\nsethue(\"blue\")\npoly(right, action = :fill, close=true)\n\nsethue(\"orange\")\nellipseinquad.((top, left, right), action = :fill)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: ellipse in quadrilateral)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"circlepath constructs a circular path from Bézier curves, which allows you to use circles as paths.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 250, \"../assets/figures/circle-path.png\") # hide\norigin() # hide\nbackground(\"antiquewhite\") # hide\nsethue(\"black\") # hide\nsetline(4)\ntiles = Tiler(600, 250, 1, 5)\nfor (pos, n) in tiles\n    randomhue()\n    circlepath(pos, tiles.tilewidth/2, action = :path)\n    newsubpath()\n    circlepath(pos, rand(5:tiles.tilewidth/2 - 1), action = :fill, reversepath=true)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: circles as paths)","category":"page"},{"location":"howto/simplegraphics/#Circles-and-tangents","page":"Draw simple shapes","title":"Circles and tangents","text":"","category":"section"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"Functions to find tangents to circles include:","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"pointcircletangent finds a point on a circle that lies on line through another point\ncirclecircleoutertangents finds the points that lie on outer tangents to two circles\ncirclecircleinnertangents finds the points that lie on inner tangents to two circles\ncircletangent2circles makes circles of a particular radius tangential to two circles\ncirclepointtangent makes circles of a particular radius passing through a point and tangential to another circle","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 250, \"../assets/figures/point-circle-tangents.png\") # hide\norigin() # hide\nbackground(\"antiquewhite\") # hide\nsetline(1) # hide\nsethue(\"black\") # hide\n\npoint = Point(-150, 0)\ncirclecenter = Point(150, 0)\ncircleradius = 80\n\ncircle.((point, circlecenter), 5, action = :fill)\ncircle(circlecenter, circleradius, action = :stroke)\npt1, pt2 = pointcircletangent(point, circlecenter, circleradius)\ncircle.((pt1, pt2), 5, action = :fill)\n\nsethue(\"grey65\")\nrule(point, slope(point, pt1))\nrule(point, slope(point, pt2))\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: point circle tangents)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 250, \"../assets/figures/circle-circle-outer-tangents.png\") # hide\norigin() # hide\nbackground(\"antiquewhite\") # hide\nsetline(1) # hide\nsethue(\"black\") # hide\n\ncircle1center = Point(-150, 0)\ncircle1radius = 60\ncircle2center = Point(150, 0)\ncircle2radius = 80\n\ncircle.((circle1center, circle2center), 5, action = :fill)\ncircle(circle1center, circle1radius, action = :stroke)\ncircle(circle2center, circle2radius, action = :stroke)\n\np1, p2, p3, p4 = circlecircleoutertangents(\n    circle1center, circle1radius,\n    circle2center, circle2radius)\n\nsethue(\"orange\")\nrule(p1, slope(p1, p2))\nrule(p3, slope(p3, p4))\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: circle circle outer tangents)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"Finding the inner tangents requires a separate function.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 250, \"../assets/figures/circle-circle-inner-tangents.png\") # hide\norigin() # hide\nbackground(\"antiquewhite\") # hide\nsetline(1) # hide\nsethue(\"black\") # hide\n\ncircle1center = Point(-150, 0)\ncircle1radius = 60\ncircle2center = Point(150, 0)\ncircle2radius = 80\n\ncircle.((circle1center, circle2center), 5, action = :fill)\ncircle(circle1center, circle1radius, action = :stroke)\ncircle(circle2center, circle2radius, action = :stroke)\n\np1, p2, p3, p4 = circlecircleinnertangents(\n    circle1center, circle1radius,\n    circle2center, circle2radius)\n\nlabel.((\"p1\", \"p2\", \"p3\", \"p4\"), :n, (p1, p2, p3, p4))\nsethue(\"orange\")\nrule(p1, slope(p1, p2))\nrule(p3, slope(p3, p4))\n\nsethue(\"purple\")\ncircle.((p1, p2, p3, p4), 3, action = :fill)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: circle circle inner tangents)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"circletangent2circles takes the required radius and two existing circles:","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 250, \"../assets/figures/circle-tangents.png\") # hide\norigin() # hide\nbackground(\"antiquewhite\") # hide\nsethue(\"black\") # hide\nsetline(1) # hide\n\ncircle1 = (Point(-100, 0), 90)\ncircle(circle1..., action = :stroke)\ncircle2 = (Point(100, 0), 90)\ncircle(circle2..., action = :stroke)\n\nrequiredradius = 25\nncandidates, p1, p2 = circletangent2circles(requiredradius, circle1..., circle2...)\n\nif ncandidates==2\n    sethue(\"orange\")\n    circle(p1, requiredradius, action = :fill)\n    sethue(\"green\")\n    circle(p2, requiredradius, action = :fill)\n    sethue(\"purple\")\n    circle(p1, requiredradius, action = :stroke)\n    circle(p2, requiredradius, action = :stroke)\nend\n\n# the circles are 10 apart, so there should be just one circle\n# that fits there\n\nrequiredradius = 10\nncandidates, p1, p2 = circletangent2circles(requiredradius, circle1..., circle2...)\n\nif ncandidates==1\n    sethue(\"blue\")\n    circle(p1, requiredradius, action = :fill)\n    sethue(\"cyan\")\n    circle(p1, requiredradius, action = :stroke)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: circle tangents)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"circlepointtangent looks for circles of a specified radius that pass through a point and are tangential to a circle. There are usually two candidates.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 250, \"../assets/figures/circle-point-tangent.png\") # hide\norigin() # hide\nbackground(\"antiquewhite\") # hide\nsethue(\"black\") # hide\nsetline(1) # hide\n\ncircle1 = (Point(-100, 0), 90)\ncircle(circle1..., action = :stroke)\n\nrequiredradius = 50\nrequiredpassthrough = O + (80, 0)\nncandidates, p1, p2 = circlepointtangent(requiredpassthrough, requiredradius, circle1...)\n\nif ncandidates==2\n    sethue(\"orange\")\n    circle(p1, requiredradius, action = :stroke)\n    sethue(\"green\")\n    circle(p2, requiredradius, action = :stroke)\nend\n\nsethue(\"black\")\ncircle(requiredpassthrough, 4, action = :fill)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: circle tangents 2)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"These last two functions can return 0, 1, or 2 points (since there are often two solutions to a specific geometric layout).","category":"page"},{"location":"howto/simplegraphics/#Crescents","page":"Draw simple shapes","title":"Crescents","text":"","category":"section"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"Use crescent to construct crescent shapes. There are two methods. The first method allows the two arcs to have the same radius. The second method allows the two arcs to share the same centers.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 500, \"../assets/figures/crescents.png\") # hide\nbackground(\"antiquewhite\") # hide\norigin() # hide\n\n# method 1: same radius, different centers\n\nsethue(\"purple\")\ncrescent(Point(-200, 0), 200, Point(-150, 0), 200, action = :fill)\n\n# method 2: same center, different radii\n\nsethue(\"orange\")\ncrescent(O, 100, 200, action = :fill)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: crescents)","category":"page"},{"location":"howto/simplegraphics/#Paths-and-positions","page":"Draw simple shapes","title":"Paths and positions","text":"","category":"section"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"A path is a sequence of lines and curves. You can add lines and curves to the current path with various functions, then use closepath to join the last point to the first. Once you fill or stroke it, the path is emptied, and you start again.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"A path can have subpaths, created withnewsubpath, which can form holes.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"There is a 'current point' which you can set with move, and which is updated after functions like line, rline, rmove, text, newpath, closepath, arc, and curve. Use currentpoint and hascurrentpoint to find out about it.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"You can store a path for later use with storepath and draw it with drawpath. See Stored paths.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"For more about paths, see Polygons and paths and Paths versus polygons.","category":"page"},{"location":"howto/simplegraphics/#Lines","page":"Draw simple shapes","title":"Lines","text":"","category":"section"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"Use line and rline to draw straight lines. line(pt1, pt2, action) makes a path consisting of a line between two points. line(pt) adds a line to the current path going from the most recent current point to pt. rline(pt) adds a line relative to the current point.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"You can use rule to draw a horizontal line through a point. Supply an angle for lines at an angle to the current x-axis.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 200, \"../assets/figures/rule.png\") # hide\nbackground(\"antiquewhite\") # hide\nsethue(\"black\") # hide\nsetline(0.5) # hide\ny = 10\nfor x in 10 .^ range(0, length=100, stop=3)\n    global y\n    circle(Point(x, y), 2, action = :fill)\n    rule(Point(x, y), -π/2, boundingbox=BoundingBox(centered=false))\n    y += 2\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: arc)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"Use the boundingbox keyword argument to crop the ruled lines with a BoundingBox.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 200, \"../assets/figures/rulebbox.png\") # hide\norigin()\nbackground(\"antiquewhite\") # hide\nsethue(\"black\") # hide\nsetline(0.75) # hide\nbox(BoundingBox() * 0.9, action = :stroke)\nfor x in 10 .^ range(0, length=100, stop=3)\n    rule(Point(x, 0), π/2,  boundingbox=BoundingBox() * 0.9)\n    rule(Point(-x, 0), π/2, boundingbox=BoundingBox() * 0.9)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: arc)","category":"page"},{"location":"howto/simplegraphics/#Arrows","page":"Draw simple shapes","title":"Arrows","text":"","category":"section"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"You can draw lines, arcs, and curves with arrows at the end with arrow.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"type function call\nstraight between two points arrow(pt, pt)\ncurved: radius + two angles arrow(pt, rad, θ1, θ2)\nBezier 4 points arrow(pt1, pt2, pt3, pt4, action)\nBezier start finish + box arrow(pt1, pt2, [ht1, ht2])","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"For straight arrows, supply the start and end points. For arrows as circular arcs, you provide center, radius, and start and finish angles. You can optionally provide dimensions for the arrowheadlength and arrowheadangle of the tip of the arrow (angle in radians between side and center). The default line weight is 1.0, equivalent to setline(1), but you can specify another.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 250, \"../assets/figures/arrow.png\") # hide\nbackground(\"antiquewhite\") # hide\norigin() # hide\nsethue(\"steelblue4\") # hide\nsetline(2) # hide\narrow(Point(0, 0), Point(0, -65))\narrow(Point(0, 0), Point(100, -65), arrowheadlength=20, arrowheadangle=pi/4, linewidth=.3)\narrow(Point(0, 0), 100, π, π/2, arrowheadlength=25,   arrowheadangle=pi/12, linewidth=1.25)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: arrows)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"If you provide four points, you can draw a Bézier curve with optional arrowheads at each end. Use the various options to control their presence and appearance.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 400, \"../assets/figures/arrowbezier.png\") # hide\nbackground(\"antiquewhite\") # hide\norigin() # hide\nsetline(2) # hide\npts = ngon(Point(0, 0), 100, 8, vertices=true)\nsethue(\"mediumvioletred\")\narrow(pts[2:5]..., :stroke, startarrow=false, finisharrow=true)\nsethue(\"cyan4\")\narrow(pts[3:6]..., startarrow=true, finisharrow=true)\nsethue(\"midnightblue\")\narrow(pts[[4, 2, 6, 8]]..., :stroke,\n    startarrow=true,\n    finisharrow=true,\n    arrowheadangle = π/6,\n    arrowheadlength = 35,\n    linewidth  = 1.5)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: arrows)","category":"page"},{"location":"howto/simplegraphics/#Decoration","page":"Draw simple shapes","title":"Decoration","text":"","category":"section"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"The arrow functions allow you to specify decorations - graphics at one or more points somewhere along the shaft. For example, say you want to draw a number and a circle at the midpoint of an arrow's shaft, you can define a function that draws text t in a circle of radius r like this:","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"function marker(r, t)\n    @layer begin\n        sethue(\"purple\")\n        circle(Point(0, 0), r,  :fill)\n        sethue(\"white\")\n        fontsize(30)\n        text(string(t), halign=:center, valign=:middle)\n    end\nend","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"and then pass this to the decorate keyword argument of arrow. By default, the graphics origin when the function is called is placed at the midpoint (0.5) of the arrow's shaft.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 400, \"../assets/figures/arrowbezierdecoration.png\") # hide\nbackground(\"antiquewhite\") # hide\norigin() # hide\nsetline(2) # hide\n\nfunction marker(r, t) #hide\n    @layer begin #hide\n        sethue(\"purple\") #hide\n        circle(Point(0, 0), r,  :fill) #hide\n        sethue(\"white\") #hide\n        fontsize(25) #hide\n        text(string(t), halign=:center, valign=:middle) # hide\n    end #hide\nend #hide\n\npts = ngon(Point(0, 0), 100, 5, vertices=true)\n\nsethue(\"mediumvioletred\")\n\n# using an anonymous function\narrow(pts[1:4]..., decorate = () -> marker(10, 3))\n\nsethue(\"olivedrab\")\n\n# no arrow, just a graphic, at 0.75\narrow(pts[1:4]...,\n    decorate = () ->\n        ngon(Point(0, 0), 20, 4, 0, action = :fill),\n    decoration = 0.75, :none) # default action is :stroke\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: arrows with decoration)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"Use the decoration keyword to specify one or more locations other than the default 0.5.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"The graphics environment provided by the decorate function is centered at each decoration point in turn, and rotated to the slope of the shaft at that point.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor\n\nfunction fletcher()\n    line(O, polar(30, deg2rad(220)), action = :stroke)\n    line(O, polar(30, deg2rad(140)), action = :stroke)\nend\n\n@drawsvg begin\n    background(\"antiquewhite\")\n        arrow(O, 150, 0, π + π/3,\n            linewidth=5,\n            arrowheadlength=50,\n            decorate=fletcher,\n            decoration=range(0., .1, length=3))\nend 800 350","category":"page"},{"location":"howto/simplegraphics/#Custom-arrowheads","page":"Draw simple shapes","title":"Custom arrowheads","text":"","category":"section"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"To make custom arrowheads, you can define a three-argument function that draws them to your own design. This function takes the arguments:","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"the point at the end of the arrow's shaft\nthe point where the tip of the arrowhead would be\nthe angle of the shaft at the end","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"You can then use any code to draw the arrow. Pass this function to the arrow function's arrowheadfunction keyword.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\n\nfunction redbluearrow(shaftendpoint, endpoint, shaftangle)\n    @layer begin\n        sethue(\"red\")\n        sidept1 = shaftendpoint  + polar(10, shaftangle + π/2 )\n        sidept2 = shaftendpoint  - polar(10, shaftangle + π/2)\n        poly([sidept1, endpoint, sidept2], action=:fill)\n        sethue(\"blue\")\n        poly([sidept1, endpoint, sidept2], action=:stroke, close=false)\n    end\nend\n\n@drawsvg begin\n    background(\"antiquewhite\")\n    arrow(O, O + (120, 120),\n        linewidth=4,\n        arrowheadlength=40,\n        arrowheadangle=π/7,\n        arrowheadfunction = redbluearrow)\n\n    arrow(O, 100, 3π/2, π,\n        linewidth=4,\n        arrowheadlength=20,\n        clockwise=false,arrowheadfunction=redbluearrow)\nend 800 250","category":"page"},{"location":"howto/simplegraphics/#Arcs-and-curves","page":"Draw simple shapes","title":"Arcs and curves","text":"","category":"section"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"There are a few standard arc-drawing commands, such as curve, arc, carc, and arc2r. Because these are often used when building complex paths, they usually add arc sections to the current path. To construct a sequence of lines and arcs, use the :path action, followed by a final :stroke or similar.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"curve constructs Bézier curves from control points:","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 275, \"../assets/figures/curve.png\") # hide\norigin() # hide\nbackground(\"antiquewhite\") # hide\n\nsethue(\"black\") # hide\n\nsetline(.5)\npt1 = Point(0, -125)\npt2 = Point(200, 125)\npt3 = Point(200, -125)\n\nlabel.(string.([\"O\", \"control point 1\", \"control point 2\", \"control point 3\"]),\n    :e,\n    [O, pt1, pt2, pt3])\n\nsethue(\"red\")\nmap(p -> circle(p, 4, action=:fill), [O, pt1, pt2, pt3])\n\nline(Point(0, 0), pt1, action=:stroke)\nline(pt2, pt3, action = :stroke)\n\nsethue(\"black\")\nsetline(3)\n\n# start a path\nmove(Point(0, 0))\ncurve(pt1, pt2, pt3) #  add to current path\nstrokepath()\n\nfinish()  # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: curve)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"arc2r draws a circular arc centered at a point that passes through two other points:","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor, Random # hide\nDrawing(800, 200, \"../assets/figures/arc2r.png\") # hide\norigin() # hide\nRandom.seed!(42) # hide\nbackground(\"antiquewhite\") # hide\ntiles = Tiler(700, 200, 1, 6)\nfor (pos, n) in tiles\n    c1, pt2, pt3 = ngon(pos, rand(10:50), 3, rand(0:pi/12:2pi), vertices=true)\n    sethue(\"black\")\n    map(pt -> circle(pt, 4, action = :fill), [c1, pt3])\n    sethue(\"red\")\n    circle(pt2, 4, action = :fill)\n    randomhue()\n    arc2r(c1, pt2, pt3, action = :stroke)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: arc)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"arc2sagitta and carc2sagitta make circular arcs based on two points and the sagitta.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor, Colors # hide\nDrawing(800, 250, \"../assets/figures/arc2sagitta.svg\") # hide\norigin() # hide\nbackground(\"antiquewhite\") # hide\nsetline(.5) # hide\ntranslate(0, 50) # hide\npt1 = Point(-100, 0)\npt2 = Point(100, 0)\nfor n in reverse(range(1, length=7, stop=120))\n    sethue(\"red\")\n    rule(Point(0, -n))\n    sethue(LCHab(70, 80, rescale(n, 120, 1, 0, 359)))\n    pt, r = arc2sagitta(pt1, pt2, n, action = :fillpreserve)\n    sethue(\"black\")\n    strokepath()\n    text(string(round(n)), O + (120, -n))\nend\ncircle.((pt1, pt2), 5, action = :fill)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: arc)","category":"page"},{"location":"howto/simplegraphics/#More-curved-shapes:-sectors,-spirals,-and-squircles","page":"Draw simple shapes","title":"More curved shapes: sectors, spirals, and squircles","text":"","category":"section"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"A sector (technically an \"annular sector\") has an inner and outer radius, as well as start and end angles.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 200, \"../assets/figures/sector.png\") # hide\nbackground(\"antiquewhite\") # hide\norigin() # hide\nsethue(\"tomato\")\nsector(50, 90, π/2, 0, action=:fill)\nsethue(\"olive\")\nsector(Point(O.x + 200, O.y), 50, 90, 0, π/2, action=:fill)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: sector)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"You can also supply a value for a corner radius. The same sector is drawn but with rounded corners.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 200, \"../assets/figures/sectorrounded.png\") # hide\nbackground(\"antiquewhite\") # hide\norigin() # hide\nsethue(\"tomato\")\nsector(50, 90, π/2, 0, 15, action = :fill)\nsethue(\"olive\")\nsector(Point(O.x + 200, O.y), 50, 90, 0, π/2, 15, action = :fill)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: sector)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"A pie (or wedge) has start and end angles.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 300, \"../assets/figures/pie.png\") # hide\nbackground(\"antiquewhite\") # hide\norigin() # hide\nsethue(\"magenta\") # hide\npie(0, 0, 100, π/2, π, action = :fill)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: pie)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"To construct spirals, use the spiral function. These can be drawn directly, or used as polygons. The default is to draw Archimedean (non-logarithmic) spirals.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 300, \"../assets/figures/spiral.png\") # hide\nbackground(\"antiquewhite\") # hide\norigin() # hide\nsethue(\"black\") # hide\nsetline(.5) # hide\nfontface(\"Avenir-Heavy\") # hide\nfontsize(15) # hide\n\nspiraldata = [\n  (-2, \"Lituus\",      50),\n  (-1, \"Hyperbolic\", 100),\n  ( 1, \"Archimedes\",   1),\n  ( 2, \"Fermat\",       5)]\n\ngrid = GridRect(O - (200, 0), 130, 50)\n\nfor aspiral in spiraldata\n    @layer begin\n        translate(nextgridpoint(grid))\n        spiral(last(aspiral), first(aspiral), period=20π, action = :stroke)\n        label(aspiral[2], :S, offset=100)\n    end\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: spiral)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"Use the log=true option to draw logarithmic (Bernoulli or Fibonacci) spirals.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 400, \"../assets/figures/spiral-log.png\") # hide\nbackground(\"antiquewhite\") # hide\norigin() # hide\nsetline(.5) # hide\nsethue(\"black\") # hide\nfontface(\"Avenir-Heavy\") # hide\nfontsize(15) # hide\n\nspiraldata = [\n    (10,  0.05),\n    (4,   0.10),\n    (0.5, 0.17)]\n\ngrid = GridRect(O - (200, 0), 175, 50)\nfor aspiral in spiraldata\n    @layer begin\n        translate(nextgridpoint(grid))\n        spiral(first(aspiral), last(aspiral), log=true, period=10π, action = :stroke)\n        label(string(aspiral), :S, offset=100)\n    end\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"Modify the stepby and period parameters to taste, or collect the vertices for further processing.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: spiral log)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"A squircle is a cross between a square and a circle. You can adjust the squariness and circularity of it to taste by supplying a value for the root (keyword rt):","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 250, \"../assets/figures/squircle.png\") # hide\nbackground(\"antiquewhite\") # hide\norigin() # hide\nfontsize(20) # hide\nsetline(2)\ntiles = Tiler(600, 250, 1, 3)\nfor (pos, n) in tiles\n    sethue(\"lavender\")\n    squircle(pos, 80, 80, rt=[0.3, 0.5, 0.7][n], action = :fillpreserve)\n    sethue(\"grey20\")\n    strokepath()\n    textcentered(\"rt = $([0.3, 0.5, 0.7][n])\", pos)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: squircles)","category":"page"},{"location":"howto/simplegraphics/#Stars-and-crosses","page":"Draw simple shapes","title":"Stars and crosses","text":"","category":"section"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"Use star to make a star. You can draw it immediately, or use the array of points it can create.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 300, \"../assets/figures/stars.png\") # hide\nbackground(\"antiquewhite\") # hide\norigin() # hide\ntiles = Tiler(400, 300, 4, 6, margin=5)\nfor (pos, n) in tiles\n    randomhue()\n    star(pos, tiles.tilewidth/3, rand(3:8), 0.5, 0, action = :fill)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: stars)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"The ratio determines the length of the inner radius compared with the outer.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\n@drawsvg begin # hide\nbackground(\"antiquewhite\") # hide\nfontsize(10) # hide\ntiles = Tiler(800, 250, 1, 6, margin=10)\nsethue(\"black\") # hide\nfor (pos, n) in tiles\n    s = star(pos, tiles.tilewidth/2, 5, 1/n, 0, action = :stroke)\n    l2 = distance(pos, s[1])\n    l1 = distance(pos, s[2])\n    text(string(round(l1/l2, digits=2)), pos, halign=:center)\nend\nend 800 200 # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"Use polycross to draw a cross-shaped polygon.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 600, \"../assets/figures/polycross.png\") # hide\norigin() # hide\nbackground(\"antiquewhite\") # hide\nsethue(\"black\") # hide\nsetline(2) # hide\ntiles = Tiler(600, 600, 4, 4, margin=10)\nfor (pos, n) in tiles\n    randomhue()\n    polycross(pos, min(tiles.tileheight/3, tiles.tilewidth/3),\n        n + 2, # number of points\n        rescale(n, 1, length(tiles), 0.9, 0.1), # ratio\n        0, # orientation\n        action=:fill)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: polycross)","category":"page"},{"location":"howto/simplegraphics/#Stored-paths","page":"Draw simple shapes","title":"Stored paths","text":"","category":"section"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"It's possible to store the current path in a Path object. For example, this code:","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"fontsize(160)\nfontface(\"Bodoni-Poster\")\ntextpath(\"†\", O, halign=:center, valign=:middle)\ndagger = storepath()","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"stores the instructions to build the current path (which describe the dagger symbol) in dagger.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"The dagger is a Luxor Path type, and contains:","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"PathMove(Point(2.0, 90.5625)),\nPathCurve(Point(4.08203125, 68.16015625), Point(11.28125, 45.28125), Point(24.8828125, 26.40234375)),\nPathCurve(Point(17.51953125, 22.87890625), Point(2.0, 14.71875), Point(2.0, 5.12109375)),\nPathCurve(Point(2.0, 2.5625), Point(3.12109375, 0.640625), Point(5.83984375, 0.640625)),\nPathCurve(Point(12.8828125, 0.640625), Point(11.6015625, 14.2421875), Point(26.16015625, 14.2421875)),\nPathCurve(Point(35.76171875, 14.2421875), Point(42.0, 7.83984375), Point(42.0, -1.59765625)),\nPathCurve(Point(42.0, -10.3984375), Point(34.9609375, -17.4375), Point(26.16015625, -17.4375)),\nPathCurve(Point(10.9609375, -17.4375), Point(13.04296875, -3.6796875), Point(6.48046875, -3.6796875)),\nPathCurve(Point(3.6015625, -3.6796875), Point(1.83984375, -6.3984375), Point(1.83984375, -9.12109375)),\nPathCurve(Point(1.83984375, -14.3984375), Point(12.2421875, -23.6796875), Point(15.44140625, -26.87890625)),\nPathCurve(Point(18.640625, -30.078125), Point(19.76171875, -34.3984375), Point(19.76171875, -38.71875)),\nPathCurve(Point(19.76171875, -49.7578125), Point(10.9609375, -56.640625), Point(0.40234375, -56.640625)),\nPathCurve(Point(-11.1171875, -56.640625), Point(-19.91796875, -49.7578125), Point(-19.91796875, -38.71875)),\nPathCurve(Point(-19.91796875, -34.3984375), Point(-18.80078125, -30.078125), Point(-15.59765625, -26.87890625)),\nPathCurve(Point(-12.3984375, -23.6796875), Point(-2.0, -14.3984375), Point(-2.0, -9.12109375)),\nPathCurve(Point(-2.0, -6.3984375), Point(-3.7578125, -3.6796875), Point(-6.640625, -3.6796875)),\nPathCurve(Point(-13.19921875, -3.6796875), Point(-11.1171875, -17.4375), Point(-26.3203125, -17.4375)),\nPathCurve(Point(-35.1171875, -17.4375), Point(-42.16015625, -10.3984375), Point(-42.16015625, -1.59765625)),\nPathCurve(Point(-42.16015625, 7.83984375), Point(-35.91796875, 14.2421875), Point(-26.3203125, 14.2421875)),\nPathCurve(Point(-11.7578125, 14.2421875), Point(-13.0390625, 0.640625), Point(-6.0, 0.640625)),\nPathCurve(Point(-3.27734375, 0.640625), Point(-2.16015625, 2.5625), Point(-2.16015625, 5.12109375)),\nPathCurve(Point(-2.16015625, 14.71875), Point(-17.6796875, 22.87890625), Point(-25.0390625, 26.40234375)),\nPathCurve(Point(-11.4375, 45.28125), Point(-4.23828125, 68.16015625), Point(-2.16015625, 90.5625)),\nPathClose(),\nPathMove(Point(48.87890625, 56.640625))","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"You can draw this later:","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor\nd = @drawsvg begin\n    dagger  = Path([\n         PathMove(Point(2.0, 90.5625)),\n         PathCurve(Point(4.08203125, 68.16015625), Point(11.28125, 45.28125), Point(24.8828125, 26.40234375)),\n         PathCurve(Point(17.51953125, 22.87890625), Point(2.0, 14.71875), Point(2.0, 5.12109375)),\n         PathCurve(Point(2.0, 2.5625), Point(3.12109375, 0.640625), Point(5.83984375, 0.640625)),\n         PathCurve(Point(12.8828125, 0.640625), Point(11.6015625, 14.2421875), Point(26.16015625, 14.2421875)),\n         PathCurve(Point(35.76171875, 14.2421875), Point(42.0, 7.83984375), Point(42.0, -1.59765625)),\n         PathCurve(Point(42.0, -10.3984375), Point(34.9609375, -17.4375), Point(26.16015625, -17.4375)),\n         PathCurve(Point(10.9609375, -17.4375), Point(13.04296875, -3.6796875), Point(6.48046875, -3.6796875)),\n         PathCurve(Point(3.6015625, -3.6796875), Point(1.83984375, -6.3984375), Point(1.83984375, -9.12109375)),\n         PathCurve(Point(1.83984375, -14.3984375), Point(12.2421875, -23.6796875), Point(15.44140625, -26.87890625)),\n         PathCurve(Point(18.640625, -30.078125), Point(19.76171875, -34.3984375), Point(19.76171875, -38.71875)),\n         PathCurve(Point(19.76171875, -49.7578125), Point(10.9609375, -56.640625), Point(0.40234375, -56.640625)),\n         PathCurve(Point(-11.1171875, -56.640625), Point(-19.91796875, -49.7578125), Point(-19.91796875, -38.71875)),\n         PathCurve(Point(-19.91796875, -34.3984375), Point(-18.80078125, -30.078125), Point(-15.59765625, -26.87890625)),\n         PathCurve(Point(-12.3984375, -23.6796875), Point(-2.0, -14.3984375), Point(-2.0, -9.12109375)),\n         PathCurve(Point(-2.0, -6.3984375), Point(-3.7578125, -3.6796875), Point(-6.640625, -3.6796875)),\n         PathCurve(Point(-13.19921875, -3.6796875), Point(-11.1171875, -17.4375), Point(-26.3203125, -17.4375)),\n         PathCurve(Point(-35.1171875, -17.4375), Point(-42.16015625, -10.3984375), Point(-42.16015625, -1.59765625)),\n         PathCurve(Point(-42.16015625, 7.83984375), Point(-35.91796875, 14.2421875), Point(-26.3203125, 14.2421875)),\n         PathCurve(Point(-11.7578125, 14.2421875), Point(-13.0390625, 0.640625), Point(-6.0, 0.640625)),\n         PathCurve(Point(-3.27734375, 0.640625), Point(-2.16015625, 2.5625), Point(-2.16015625, 5.12109375)),\n         PathCurve(Point(-2.16015625, 14.71875), Point(-17.6796875, 22.87890625), Point(-25.0390625, 26.40234375)),\n         PathCurve(Point(-11.4375, 45.28125), Point(-4.23828125, 68.16015625), Point(-2.16015625, 90.5625)),\n         PathClose(),\n         PathMove(Point(48.87890625, 56.640625))\n        ])\nend 800 250","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"@drawsvg begin # hide\nbackground(\"antiquewhite\")  # hide\nsethue(\"black\") # hide\nfor θ in range(0, step=2π/10, length=10)\n    @layer begin\n        rotate(θ)\n        translate(150, 0)\n        rotate(π/2)\n        drawpath(dagger, action = :fill)\n    end\nend\nend # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"note: Note\nAfter you've stored the current path, it's still active. You might want to use newpath() before starting the next one. The drawpath() function will by default start a new path but there is an option to continue drawing the current one.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"Other functions for working with stored paths include:","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"drawpath draw all or part of a stored path using the current graphics state\npathsample resample the stored path\npathlength find the length of a stored path\nBoundingBox find the bounding box of a stored path","category":"page"},{"location":"howto/simplegraphics/#Julia-logos","page":"Draw simple shapes","title":"Julia logos","text":"","category":"section"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"A couple of functions, julialogo and juliacircles, provide you with instant access to the Julia logo and the three colored circles/dots:","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor, Random # hide\nDrawing(800, 300, \"../assets/figures/julia-logo.png\")  # hide\nRandom.seed!(42) # hide\norigin()  # hide\nbackground(\"antiquewhite\") # hide\n\ncells = Table([300], [350, 350])\n\n@layer begin\n    translate(cells[1])\n    translate(-165, -114)\n    rulers()\n    julialogo()\nend\n\n@layer begin\n    translate(cells[2])\n    translate(-165, -114)\n    rulers()\n    julialogo(action=:clip)\n    for i in 1:500\n        @layer begin\n            translate(rand(0:400), rand(0:250))\n            juliacircles(10)\n        end\n    end\n    clipreset()\n    end\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: julia logo and circles)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"There are various options for julialogo() to control coloring and positioning.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"The four standard Julia colors are available as RGB tuples as Luxor.julia_blue, Luxor.julia_green, Luxor.julia_purple,  Luxor.julia_red:","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"julia> Luxor.julia_red\n(0.796, 0.235, 0.2)","category":"page"},{"location":"howto/simplegraphics/#Hypotrochoids","page":"Draw simple shapes","title":"Hypotrochoids","text":"","category":"section"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"hypotrochoid makes hypotrochoids. The result is a polygon. You can either draw it directly, or pass it on for further polygon fun, as here, which uses offsetpoly to trace round it a few times.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 300, \"../assets/figures/hypotrochoid.png\")  # hide\norigin()\nbackground(\"grey15\")\nsethue(\"antiquewhite\")\nsetline(1)\np = hypotrochoid(100, 25, 55, action = :stroke, stepby=0.01, vertices=true)\nfor i in 0:3:15\n    poly(offsetpoly(p, i), action = :stroke, close=true)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: hypotrochoid)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"There's a matching epitrochoid function.","category":"page"},{"location":"howto/simplegraphics/#Ticks","page":"Draw simple shapes","title":"Ticks","text":"","category":"section"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"The tickline function lets you divide the space between two points by drawing ‘ticks’, short parallel lines positioned equidistant between the two points.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"In its simplest form the function can used to draw basic number lines, complete with automatic text labels.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\n@drawsvg begin # hide\nbackground(\"antiquewhite\")\n\n# major defaults to 1\ntickline(Point(-350, -100), Point(350, -100))\n\n# three major ticks inserted\ntickline(Point(-350, 0), Point(350, 0),\n    major=3,\n    startnumber=0, finishnumber=100)\n\n# four minor ticks inserted between each major\ntickline(Point(-350, 100), Point(350, 100), major=3, minor=4)\n\nend 800 350  # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"The function returns the positions of the generated ticks in two arrays of points - the locations of the major and minor ticks.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"The spaced positions (linear or logarithmic) are useful even when you switch off the display of text using vertices=true, which just returns vertices.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\n@drawsvg begin # hide\nbackground(\"antiquewhite\") # hide\n\n# no axis\ntickline(Point(-350, -100), Point(350, -100), minor=9, axis=false)\n\n# logarithmic\nmajticks, minticks = tickline(Point(-350, 0), Point(350, 0),\n    major=9,\n    startnumber=1,\n    finishnumber=10,\n    log=true,\n    vertices=false)\n\n# just the vertices\nmajticks, minticks = tickline(Point(-350, 100), Point(350, 100),\n    major=9,\n    minor=4,\n    log=true,\n    axis=false,\n    vertices=true)\ncircle.(majticks, 5, action = :fill)\nbox.(minticks, 1, 25, action = :fill)\nend 800 350  # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"You can pass a function that generates custom graphics and text for each tick.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor, Colors # hide\nfunction color_temp(n, pos;\n          startnumber  = 0,\n          finishnumber = 1,\n          nticks = 1)\n    k = rescale(n, 0, nticks - 1, startnumber, finishnumber)\n    sethue(RGB(colormatch(k)))\n    circle(pos, 20, action = :fillpreserve)\n    sethue(\"white\")\n    strokepath()\n    text(\"$(convert(Int, floor(k))) nm\", pos - (0, 30), halign=:left, angle=-π/4)\nend\n\n@drawsvg begin # hide\nbackground(\"black\") # hide\nfontsize(16) # hide\ntickline(Point(-350, 0), Point(350, 0),\n    startnumber=350,\n    finishnumber=750,\n    major=10,\n    major_tick_function=color_temp)\nend 800 300 # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"Sometimes you just want a sequence of spaced points.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor, Colors # hide\n\n_, minticks = tickline(Point(-400, 0), Point(260, 0),\n        major=0, minor=40,\n        log=true,\n        axis=false,\n        vertices=true)\n\n@drawsvg begin # hide\nbackground(\"black\") # hide\nfor (n, pt) in enumerate(minticks)\n    k = rescale(n, 1, length(minticks), 0, 1)\n    sethue(LCHab(60, 100, 360k))\n    setline(1/k)\n    wave = [pt + Point(120k * sin(y), 600/2π * y) for y in -π:π/20:π]\n    poly(wave, action = :stroke)\nend\n\nend 800 600  # hide","category":"page"},{"location":"howto/simplegraphics/#Cropmarks","page":"Draw simple shapes","title":"Cropmarks","text":"","category":"section"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"If you want cropmarks (aka trim marks), use the cropmarks function, supplying the centerpoint, followed by the width and height:","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"cropmarks(O, 1200, 1600)\ncropmarks(O, paper_sizes[\"A0\"]...)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 250, \"../assets/figures/cropmarks.png\")  # hide\norigin() # hide\nbackground(\"antiquewhite\") # hide\nsethue(\"red\")\nbox(O, 150, 150, action = :stroke)\ncropmarks(O, 150, 150)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: cropmarks)","category":"page"},{"location":"howto/simplegraphics/#Dimensioning","page":"Draw simple shapes","title":"Dimensioning","text":"","category":"section"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"Simple dimensioning graphics can be generated with dimension. To convert from the default unit (PostScript points), or to modify the dimensioning text, supply a function to the format keyword argument.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: dimensioning)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 350, \"../assets/figures/dimensioning.svg\")  # hide\norigin() # hide\nbackground(\"antiquewhite\") # hide\nsetline(0.75)\nsethue(\"purple\")\npentagon = ngonside(O, 120, 5, vertices=true)\npoly(pentagon, action = :stroke, close=true)\ncircle.(pentagon, 2, action = :fill)\nfontsize(6)\nlabel.(split(\"12345\", \"\"), :NE, pentagon)\nfontface(\"Menlo\")\nfontsize(10)\nsethue(\"grey30\")\n\ndimension(O, pentagon[4],\n    fromextension = [0, 0])\n\ndimension(pentagon[1], pentagon[2],\n    offset        = -60,\n    fromextension = [20, 50],\n    toextension   = [20, 50],\n    textrotation  = 2π/5,\n    textgap       = 20,\n    format        = (d) -> string(round(d, digits=4), \"pts\"))\n\ndimension(pentagon[2], pentagon[3],\n     offset        = -40,\n     format        =  string)\n\ndimension(pentagon[5], Point(pentagon[5].x, pentagon[4].y),\n    offset        = 60,\n    format        = (d) -> string(\"approximately \",round(d, digits=4)),\n    fromextension = [5, 5],\n    toextension   = [80, 5])\n\ndimension(pentagon[1], midpoint(pentagon[1], pentagon[5]),\n    offset               = 70,\n    fromextension        = [65, -5],\n    toextension          = [65, -5],\n    texthorizontaloffset = -5,\n    arrowheadlength      = 5,\n    format               = (d) ->\n        begin\n            if isapprox(d, 60.0)\n                string(\"exactly \", round(d, digits=4), \"pts\")\n            else\n                string(\"≈ \", round(d, digits=4), \"pts\")\n            end\n        end)\n\ndimension(pentagon[1], pentagon[5],\n    offset               = 120,\n    fromextension        = [5, 5],\n    toextension          = [115, 5],\n    textverticaloffset   = 0.5,\n    texthorizontaloffset = 0,\n    textgap              = 5)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/#Barcharts","page":"Draw simple shapes","title":"Barcharts","text":"","category":"section"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"For simple barcharts, use the barchart function, supplying an array of numbers:","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor # hide\nDrawing(800, 420, \"../assets/figures/bars.png\")  # hide\norigin() # hide\nbackground(\"antiquewhite\") # hide\nfontsize(7)\nsethue(\"black\")\nv = rand(-100:100, 25)\nbarchart(v, labels=true)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: bars)","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"To change the way the bars and labels are drawn, define some functions and pass them as keyword arguments:","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor, Colors, Random # hide\nDrawing(800, 450, \"../assets/figures/bars1.png\")  # hide\n\nRandom.seed!(2) # hide\norigin() # hide\nbackground(\"antiquewhite\") # hide\nsetopacity(0.8) # hide\nfontsize(8) # hide\nfontface(\"Helvetica-Bold\") # hide\nsethue(\"black\") # hide\n\nfunction mybarfunction(values, i, low, high, barwidth, scaledvalue)\n    @layer begin\n        extremes = extrema(values)\n        sethue(Colors.HSB(rescale(values[i], extremes[1], extremes[2], 0, 360), 1.0, 0.5))\n        csize = rescale(values[i], extremes[1], extremes[2], 5, 15)\n        circle(high, csize, action = :fill)\n        setline(1)\n        sethue(\"blue\")\n        line(low, high, action = :stroke)\n        sethue(\"white\")\n        text(string(values[i]), high, halign=:center, valign=:middle)\n    end\nend\n\nfunction mylabelfunction(values, i, low, high, barwidth, scaledvalue)\n    @layer begin\n        translate(low)\n        text(string(values[i]), O + (0, 10), halign=:center, valign=:middle)\n    end\nend\n\nv = rand(1:100, 15)\n\nbbox = BoundingBox() * 0.8\nbox(bbox, action = :clip)\np = barchart(v, boundingbox=bbox, barfunction=mybarfunction, labelfunction=mylabelfunction)\n\nrule(p[1])\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: bars 1)","category":"page"},{"location":"howto/simplegraphics/#Box-maps","page":"Draw simple shapes","title":"Box maps","text":"","category":"section"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"The boxmap function divides a rectangular area into a sorted arrangement of smaller boxes or tiles based on the values of elements in an array.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"This example uses the Fibonacci sequence to determine the area of the boxes. Notice that the values are sorted in reverse, and are scaled to fit in the available area.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"You specify the top left corner of the graphic, the width, and the height.","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"using Luxor, Colors, Random # hide\nDrawing(800, 450, \"../assets/figures/boxmap.png\")  # hide\nRandom.seed!(13) # hide\norigin() # hide\nbackground(\"antiquewhite\") # hide\n\nfib = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]\n\n# make a boxmap and store the tiles\ntiles = boxmap(fib, BoundingBox()[1], 800, 450)\n\nfor (n, t) in enumerate(tiles)\n    randomhue()\n    bb = BoundingBox(t)\n    sethue(\"black\")\n    box(bb - 5, action = :stroke)\n\n    randomhue()\n    box(bb - 8, action = :fill)\n\n    # text labels\n    sethue(\"white\")\n\n    # rescale text to fit better\n    fontsize(boxwidth(bb) > boxheight(bb) ? boxheight(bb)/4 : boxwidth(bb)/4)\n    text(string(sort(fib, rev=true)[n]),\n        midpoint(bb[1], bb[2]),\n        halign=:center,\n            valign=:middle)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/simplegraphics/","page":"Draw simple shapes","title":"Draw simple shapes","text":"(Image: boxmap)","category":"page"},{"location":"howto/turtle/","page":"Turtle graphics","title":"Turtle graphics","text":"DocTestSetup = quote\n    using Luxor, Colors\n    end","category":"page"},{"location":"howto/turtle/#Turtle-graphics","page":"Turtle graphics","title":"Turtle graphics","text":"","category":"section"},{"location":"howto/turtle/","page":"Turtle graphics","title":"Turtle graphics","text":"Luxor provides some basic \"turtle graphics\" functions. Functions to control the turtle begin (somewhat unusually) with a capital letter: Forward, Turn, Circle, Orientation, Towards, Rectangle, Pendown, Penup, Pencolor, Penwidth, and Reposition, and so on, and angles are specified in degrees rather than radians.","category":"page"},{"location":"howto/turtle/","page":"Turtle graphics","title":"Turtle graphics","text":"using Luxor, Colors\nDrawing(600, 400, \"../assets/figures/turtles.png\")  \norigin()  \nbackground(\"midnightblue\")  \n\n🐢 = Turtle() # you can type the turtle emoji with \\:turtle:\nPencolor(🐢, \"cyan\")\nPenwidth(🐢, 1.5)\nn = 5\nfor i in 1:400\n    global n\n    Forward(🐢, n)\n    Turn(🐢, 89.5)\n    HueShift(🐢)\n    n += 0.75\nend\nfontsize(20)\nMessage(🐢, \"finished\")\nfinish()  \nnothing # hide","category":"page"},{"location":"howto/turtle/","page":"Turtle graphics","title":"Turtle graphics","text":"(Image: turtles)","category":"page"},{"location":"howto/turtle/","page":"Turtle graphics","title":"Turtle graphics","text":"List of words the turtle knows Action\nForward More forward by d units\nTurn Increase the turtle's rotation by n degrees\nCircle Draw filled circle centered at current pos\nHueShift Shift the Hue of the turtle's pen color by n\nMessage Output text\nOrientation Set the turtle's orientation to n degrees\nPen_opacity_random Set opacity to random value\nPencolor Set the Red, Green, and Blue values\nPendown Start drawing\nPenup Stop drawing\nPenwidth Set the width of the line to n\nPop Move turtle to the value stored on the stack\nPush Save the turtle's position on the stack\nRandomize_saturation Randomize the saturation of the current color\nRectangle Draw filled rectangle centered at current pos\nReposition Place turtle at new position\nTowards Rotate turtle to face towards a point","category":"page"},{"location":"howto/turtle/","page":"Turtle graphics","title":"Turtle graphics","text":"The turtle commands expect a reference to a turtle as the first argument (it doesn't have to be a turtle emoji!), and you can have any number of turtles active at a time.","category":"page"},{"location":"howto/turtle/","page":"Turtle graphics","title":"Turtle graphics","text":"using Luxor, Colors # hide\nDrawing(800, 800, \"../assets/figures/manyturtles.svg\") # hide\norigin() # hide\nbackground(\"white\") # hide\nquantity = 9\nturtles = [Turtle(O, true, 2π * rand(), (rand(), rand(), 0.5)...) for i in 1:quantity]\nReposition.(turtles, first.(collect(Tiler(800, 800, 3, 3))))\nn = 10\nPenwidth.(turtles, 0.5)\nfor i in 1:300\n    global n\n    Forward.(turtles, n)\n    HueShift.(turtles)\n    Turn.(turtles, [60.1, 89.5, 110, 119.9, 120.1, 135.1, 145.1, 176, 190])\n    n += 0.5\nend\nfinish() # hide  \nnothing # hide","category":"page"},{"location":"howto/turtle/","page":"Turtle graphics","title":"Turtle graphics","text":"(Image: many turtles)","category":"page"},{"location":"howto/turtle/","page":"Turtle graphics","title":"Turtle graphics","text":"A turtle graphics approach lends itself well to recursive programming. This short recursive function draws a Hilbert curve.","category":"page"},{"location":"howto/turtle/","page":"Turtle graphics","title":"Turtle graphics","text":"using Luxor, Colors # hide\nDrawing(400, 400, \"../assets/figures/hilbertturtle.svg\") # hide\norigin() # hide\nbackground(\"black\") # hide\n\nfunction hilbert(t::Turtle, level, angle, lengthstep)\n    level == 0 && return\n\n    HueShift(t, 0.1)\n\n    Turn(t, angle)\n    hilbert(t, level-1, -angle, lengthstep)\n\n    Forward(t, lengthstep)\n    Turn(t, -angle)\n    hilbert(t, level-1, angle, lengthstep)\n\n    Forward(t, lengthstep)\n    hilbert(t, level-1, angle, lengthstep)\n\n    Turn(t, -angle)\n    Forward(t, lengthstep)\n    hilbert(t, level-1, -angle, lengthstep)\n\n    Turn(t, angle)\nend\n\n@draw begin\nbackground(\"black\")\nsetline(2)\nsetlinecap(\"round\")\n\nhilbert(Turtle(first(BoundingBox()) + (12, 12), true, 0, (1, 0, 0)),\n        6,  # level\n        90, # turn angle, in degrees\n        6   # steplength\n        )\nend\nnothing # hide","category":"page"},{"location":"howto/turtle/","page":"Turtle graphics","title":"Turtle graphics","text":"(Image: hilbert turtle)","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"DocTestSetup = quote\n    using Luxor, Colors\n    end","category":"page"},{"location":"howto/text/#Text-and-fonts","page":"Add text","title":"Text and fonts","text":"","category":"section"},{"location":"howto/text/#A-tale-of-two-APIs","page":"Add text","title":"A tale of two APIs","text":"","category":"section"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"There are two ways to draw text in Luxor. You can use either the so-called 'toy' API or the 'pro' API. Both have their advantages and disadvantages. Also, font selection and availability varies a lot across the three operating systems. You may have to experiment to find code patterns that work for you.","category":"page"},{"location":"howto/text/#The-Toy-API","page":"Add text","title":"The Toy API","text":"","category":"section"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"Use:","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"text(string, [position]) to place text at a position, otherwise at 0/0, and optionally specify the horizontal and vertical alignment\nfontface(fontname) to specify the fontname\nfontsize(fontsize) to specify the fontsize","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"fontsize(16)\nfontface(\"Georgia-Bold\")\ntext(\"Georgia: a serif typeface designed in 1993 by Matthew Carter.\", halign=:center)","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"(Image: text placement)","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"(If the specified font is unavailable on the current system configuration, the default, usually Times/Helvetica or DejaVu, is used.)","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"The label function also uses the Toy API.","category":"page"},{"location":"howto/text/#The-Pro-API","page":"Add text","title":"The Pro API","text":"","category":"section"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"Use:","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"setfont(fontname, fontsize) to specify the fontname and size\nsettext(text, [position]) to place the text at a position, and optionally specify horizontal and vertical alignment, rotation (in degrees counterclockwise!), and the presence of any pseudo-Pango-flavored markup.","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"setfont(\"Georgia Bold\", 16)\nsettext(\"Georgia: a serif typeface designed in 1993 by Matthew Carter.\", halign=\"center\")","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"(Image: text placement)","category":"page"},{"location":"howto/text/#Specifying-the-font-(\"Toy\"-API)","page":"Add text","title":"Specifying the font (\"Toy\" API)","text":"","category":"section"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"Use fontface(fontname) to choose a font, and fontsize(n) to set the font size. get_fontsize finds the current font size.","category":"page"},{"location":"howto/text/#Specifying-the-font-(\"Pro\"-API)","page":"Add text","title":"Specifying the font (\"Pro\" API)","text":"","category":"section"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"To select a font in the Pro text API, use setfont and supply both the font name and a size.","category":"page"},{"location":"howto/text/#Placing-text-(\"Toy\"-API)","page":"Add text","title":"Placing text (\"Toy\" API)","text":"","category":"section"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"Use text to place a string. The left edge is placed at the origin, by default. Or you can supply a position. Use halign and/or valign to align the string at the position.","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"using Luxor # hide\n@drawsvg begin # hide\nbackground(\"black\") # hide\nfontsize(20) # hide\npt1 = Point(-100, 0)\npt2 = Point(0, 0)\npt3 = Point(100, 0)\nsethue(\"white\")\ntext(\"text 1\",  pt1, halign=:left,   valign = :bottom)\ntext(\"text 2\",  pt2, halign=:center, valign = :bottom)\ntext(\"text 3\",  pt3, halign=:right,  valign = :bottom)\ntext(\"text 4\",  pt1, halign=:left,   valign = :top)\ntext(\"text 5\",  pt2, halign=:center, valign = :top)\ntext(\"text 6\",  pt3, halign=:right,  valign = :top)\nsethue(\"red\")\nmap(p -> circle(p, 5, :fill), [pt1, pt2, pt3])\nend 600 100 # hide","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"sethue(\"black\") # hide\nfontsize(10)\nfontface(\"Georgia\")\n[text(string(θ), Point(40cos(θ), 40sin(θ)), angle=θ) for θ in 0:π/12:47π/24]","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"(Image: text rotation)","category":"page"},{"location":"howto/text/#Placing-text-(\"Pro\"-API)","page":"Add text","title":"Placing text (\"Pro\" API)","text":"","category":"section"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"Use settext to place text. You can include some pseudo-HTML markup with the keyword argument markup=true.","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"using Luxor # hide\nDrawing(400, 150, \"../assets/figures/pro-text-placement.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nrulers()\nsethue(\"black\")\nsettext(\"<span font='26' background ='green' foreground='red'> Hey</span>\n    <i>italic</i> <b>bold</b> <sup>superscript</sup>\n    <tt>monospaced</tt>\",\n    halign=\"center\",\n    markup=true,\n    angle=10) # degrees counterclockwise!\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"(Image: pro text placement)","category":"page"},{"location":"howto/text/#Writing-LaTeX","page":"Add text","title":"Writing LaTeX","text":"","category":"section"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"It's possible to write math equations in LaTeX by passing a LaTeXString to the text function. Luxor uses MathTeXEngine.jl to parse the LaTeXString. You should load MathTeXEngine.jl (using MathTeXEngine) before accessing this feature.","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"note: Note\nMathTeXEngine.jl is a package that renders many LaTeXStrings without requiring a LaTeX compiler. The package uses the fonts Computer Modern and New Computer Modern. They're included with the MathTeXEngine package, and you can find them in your julia folder in packages/MathTeXEngine/.../assets/fonts. You should make sure these have been copied to your system's font directories before running Luxor and writing LaTeX strings.","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"using Luxor\nusing MathTeXEngine\npath_svg = \"latexexample.svg\"\npath_svg = \"../assets/figures/latexexample.svg\" # hide\nDrawing(600, 400, path_svg)\norigin()\nbackground(\"grey6\")\nfontsize(26)\nsethue(\"white\")\nt₁ = L\"e^{i\\pi} + 1 = 0\"\nt₂ = L\"e^x = \\sum^\\infty_{n=0} \\frac{x^n}{n!} = \\lim_{n\\to\\infty}(1+\\frac{x}{n})^n\"\nt₃ = L\"\\cos(\\theta)\"\n\ntext(t₁, Point(0, -100), halign=:center, valign=:baseline, angle=0)\ntext(t₂, Point(0, -20), halign=:center, valign=:top, angle=0)\n\nline(Point(0, 132), Point(50, 132), action = :stroke)\nline(Point(0, 132), Point(50cos(π/4), 132 - 50sin(π/4)), action = :stroke)\n\nfontsize(18)\ntext(t₃, Point(0, 120), halign = :left, valign = :baseline, angle = -π/4, rotationfixed = false)\nfinish()\nnothing # hide","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"(Image: textbox)","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"note: Note\nThe string macros in the LaTeXStrings.jl package allow you to enter LaTeX equations without having to escape backslashes and dollar signs (and they'll add the dollar signs for you if you omit them).","category":"page"},{"location":"howto/text/#Notes-on-fonts","page":"Add text","title":"Notes on fonts","text":"","category":"section"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"Fonts are loaded when you first start using Luxor/Cairo in a Julia session. This partly explains why starting a Luxor/Cairo session can take a few seconds.","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"On macOS, the fontname required by the Toy API's fontface should be the PostScript name of a currently activated font. You can find this out using, for example, the FontBook application.","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"On macOS, a list of currently activated fonts can be found (after a while) with the shell command:","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"system_profiler SPFontsDataType","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"Fonts currently activated by a Font Manager can be found and used by the Toy API but not by the Pro API (at least on my macOS computer currently).","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"On macOS, you can obtain a list of fonts that fontconfig considers are installed and available for use (via the Pro Text API with setfont) using the shell command:","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"fc-list | cut -f 2 -d \":\"","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"although typically this lists only those fonts in /System/Library/Fonts and /Library/Fonts, and not ~/Library/Fonts.","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"(There is a Julia interface to fontconfig at Fontconfig.jl. See also FreeTypeAbstraction.jl)","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"In the Pro API, the default font is Times Roman (on macOS). In the Toy API, the default font is Helvetica (on macOS).","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"One difference between settext and text (on macOS) is that many more missing Unicode glyphs are automatically substituted by other fonts when you use the former.","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"Cairo.jl (and hence Luxor.jl) doesn't support emoji currently. 😢","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"Text is rasterized (converted from outlines to pixels) only when you output to the PNG format. For SVG formats, text is converted to outlines (curves and lines). For PDF and EPS formats, the fonts you use are stored inside the output file (\"embedded\"), and the text is displayed using that font only when the file is viewed.","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"For PNG files, the appearance of fonts when output is controlled to some extent by the operating system. For example, on Windows, if ClearType is active, differently-colored pixels are used to display fonts, because of the use of subpixel rendering. These colored pixels will be visible in the PNG output.","category":"page"},{"location":"howto/text/#Text-to-paths","page":"Add text","title":"Text to paths","text":"","category":"section"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"textoutlines(string, position) converts the text into graphic path(s), places them starting at position, and applies the action.","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"fontface(\"Times-Roman\")\nfontsize(500)\nsetline(4)\nsethue(\"maroon2\")\ntextoutlines(\"&\", O, :path, valign=:middle, halign=:center)\nfillpreserve()\nsethue(\"black\")\nstrokepath()","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"(Image: text outlines)","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"textpath converts the text into graphic paths suitable for further manipulation.","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"textpath preserves the Bézier curves, whereas textoutlines flattens all curves and converts them to polygons.","category":"page"},{"location":"howto/text/#Text-and-font-dimensions-(\"Toy\"-API-only)","page":"Add text","title":"Text and font dimensions (\"Toy\" API only)","text":"","category":"section"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"The textextents(str) function returns the dimensions of the string str, given the current font. There has to be a current drawing before this function is called.","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"width and height are stored in elements 3 and 4. The first two elements are the offsets (\"bearings\") from the reference point (green) to the bounding box. The last two elements determine where the next (\"advance\") character should start (blue).","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"(Image: textextents)","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"note: Note\nThere is currently no equivalent of this function for the \"Pro\" API.","category":"page"},{"location":"howto/text/#Labels","page":"Add text","title":"Labels","text":"","category":"section"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"The label function places text relative to a specific point, and you can use compass points or angles to indicate where it should be. So :N (for North) places a text label directly above the point, as does 3π/2.","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"fontsize(15)\noctagon = ngon(O, 100, 8, 0, vertices=true)\n\ncompass = [:SE, :S, :SW, :W, :NW, :N, :NE, :E, :SE]\n\nfor i in 1:8\n    circle(octagon[i], 5, :fill)\n    label(string(compass[i]), compass[i], octagon[i], leader=true, leaderoffsets=[0.2, 0.9], offset=50)\nend","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"(Image: labels)","category":"page"},{"location":"howto/text/#Text-on-a-circle","page":"Add text","title":"Text on a circle","text":"","category":"section"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"Use textcurve(str) to draw a string str on a circular arc or spiral.","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"sethue(\"royalblue4\") # hide\nfontsize(7)\nfontface(\"Menlo\")\ntextstring = join(names(Base), \" \")\ntextcurve(\"this spiral contains every word in julia names(Base): \" * textstring,\n    -π/2,\n    350, 0, 0,\n    spiral_in_out_shift = -8.0,\n    letter_spacing = 0,\n    spiral_ring_step = 0)\nfontsize(35)\nfontface(\"Avenir-Black\")\ntextcentered(\"julia names(Base)\", 0, 0)","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"(Image: text on a curve or spiral)","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"For shorter strings, textcurvecentered tries to place the text on a circular arc by its center point.","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"fontface(\"Arial-Black\")\nfontsize(24) # hide\nsethue(\"black\") # hide\nsetdash(\"dot\") # hide\nsetline(0.25) # hide\ncircle(O, 100, action = :stroke)\ntextcurvecentered(\"hello world\", -π/2, 100, O;\n    clockwise = true,\n    letter_spacing = 0,\n    baselineshift = -20\n    )\ntextcurvecentered(\"hello world\", π/2, 100, O;\n    clockwise = false,\n    letter_spacing = 0,\n    baselineshift = 10\n    )","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"(Image: text centered on curve)","category":"page"},{"location":"howto/text/#Text-on-a-polygon","page":"Add text","title":"Text on a polygon","text":"","category":"section"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"Use textonpoly() to draw a string str that follows the route of a polygon.","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"using Luxor, Colors # hide\n\nd = @drawsvg begin # hide\n    origin() # hide\n    background(\"black\") # hide\n    setmesh(mesh(\n        box(BoundingBox()),\n        [\n            RGB(0.2, 0.2, 0.99),\n            RGB(0.9, 0.2, 0.3),\n            RGB(0.9, 0.9, 0.4),\n            RGB(0.2, 0.8, 0.99),\n        ],\n    ))\n\n    fontsize(15)\n\n    for y = -250:20:250\n        points = [\n            Point(\n                65x,\n                y + 30sin(x + rescale(y, -260, 250, 0, 2π)),\n            ) for x = -2π:π/10:2π\n        ]\n        textonpoly(\"WAVES \" ^ 15, points)\n    end\n\nend 800 500 # hide\nd # hide","category":"page"},{"location":"howto/text/#Text-clipping","page":"Add text","title":"Text clipping","text":"","category":"section"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"You can use newly-created text paths as a clipping region - here the text paths are filled with names of randomly chosen Julia functions:","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"(Image: text clipping)","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"fontsize(600)                             # big fontsize to use for clipping\nfontface(\"Agenda-Black\")\nstr = \"julia\"                             # string to be clipped\nw, h = textextents(str)[3:4]              # get width and height\n\ntranslate(-(currentwidth/2) + 50, -(currentheight/2) + h)\n\ntextpath(str)                             # make text into a path\nsetline(3)\nsetcolor(\"black\")\nfillpreserve()                            # fill but keep\nclip()                                    # and use for clipping region\n\nfontface(\"Monaco\")\nfontsize(10)\nnamelist = map(x->string(x), names(Base)) # get list of function names in Base.\n\nx = -20\ny = -h\nwhile y < currentheight\n    sethue(rand(7:10)/10, rand(7:10)/10, rand(7:10)/10)\n    s = namelist[rand(1:end)]\n    text(s, x, y)\n    se = textextents(s)\n    x += se[5]                            # move to the right\n    if x > w\n        x = -20                            # next row\n        y += 10\n    end\nend","category":"page"},{"location":"howto/text/#Text-blocks,-boxes,-and-wrapping","page":"Add text","title":"Text blocks, boxes, and wrapping","text":"","category":"section"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"Longer lines of text can be made to wrap inside an imaginary rectangle with textwrap. Specify the required width of the rectangle, and the location of the top left corner.","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"fontface(\"Georgia\")\nfontsize(12) # hide\nsethue(\"black\") # hide\n\nloremipsum = \"\"\"Lorem ipsum dolor sit amet, consectetur\nadipiscing elit. Nunc placerat lorem ullamcorper,\nsagittis massa et, elementum dui. Sed dictum ipsum vel\ncommodo pellentesque. Aliquam erat volutpat. Nam est\ndolor, vulputate a molestie aliquet, rutrum quis lectus.\nSed lectus mauris, tristique et tempor id, accumsan\npharetra lacus. Donec quam magna, accumsan a quam\nquis, mattis hendrerit nunc. Nullam vehicula leo ac\nleo tristique, a condimentum tortor faucibus.\"\"\"\n\nsetdash(\"dot\")\nbox(O, 200, 200, action = :stroke)\ntextwrap(loremipsum, 200, O - (200/2, 200/2))","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"(Image: text wrapping)","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"textwrap accepts a function that allows you to insert code that responds to the next line's linenumber, contents, position, and height.","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"fontface(\"Georgia\")\nfontsize(12) # hide\nsethue(\"black\") # hide\n\nloremipsum = \"\"\"Lorem ipsum dolor sit amet, consectetur\nadipiscing elit. Nunc placerat lorem ullamcorper,\nsagittis massa et, elementum dui. Sed dictum ipsum vel\ncommodo pellentesque. Aliquam erat volutpat. Nam est\ndolor, vulputate a molestie aliquet, rutrum quis lectus.\nSed lectus mauris, tristique et tempor id, accumsan\npharetra lacus. Donec quam magna, accumsan a quam\nquis, mattis hendrerit nunc. Nullam vehicula leo ac\nleo tristique, a condimentum tortor faucibus.\"\"\"\n\ntextwrap(loremipsum, 200, O - (200/2, 200/2),\n    (lnumber, str, pt, l) -> begin\n        sethue(Colors.HSB(rescale(lnumber, 1, 15, 0, 360), 1, 1))\n        text(string(\"line \", lnumber), pt - (50, 0))\n    end)","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"(Image: text wrapped)","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"The textbox function also draws text inside a box, but doesn't alter the lines, and doesn't force the text to a specific width. Supply an array of strings and the top left position. The leading argument specifies the distance between the lines, so should be set relative to the current font size (as set with fontsize).","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"This example counts the number of characters drawn, using a simple closure. The function returns the position of the start of what would have been the next line.","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"fontface(\"Georgia\")\nfontsize(30)\n\nloremipsum = \"\"\"Lorem ipsum dolor sit amet, consectetur\nadipiscing elit. Nunc placerat lorem ullamcorper,\nsagittis massa et, elementum dui. Sed dictum ipsum vel\ncommodo pellentesque. Aliquam erat volutpat. Nam est\ndolor, vulputate a molestie aliquet, rutrum quis lectus.\nSed lectus mauris, tristique et tempor id, accumsan\npharetra lacus. Donec quam magna, accumsan a quam\nquis, mattis hendrerit nunc. Nullam vehicula leo ac\nleo tristique, a condimentum tortor faucibus.\"\"\"\n\n_counter() = (a = 0; (n) -> a += n)\ncounter = _counter()\n\ntranslate(boxtopleft(BoundingBox()))\nfontface(\"Georgia\")\nfontsize(20)\n\nfinishpos = textbox(filter(!isempty, split(loremipsum, \"\\n\")),\n    O + (5, 0),\n    leading = 28,\n    linefunc = (lnumber, str, pt, h) -> begin\n        text(string(lnumber), pt - (30, 0))\n        counter(length(str))\n    end)\n\nfontsize(10)\ntext(string(counter(0), \" characters\"), finishpos)","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"(Image: textbox)","category":"page"},{"location":"howto/text/#Text-tracking","page":"Add text","title":"Text tracking","text":"","category":"section"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"Use texttrack to track or letter-space text, i.e. vary the spacing between every letter. (\"Kerning\" is when you do this for just a pair of letters.)","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"The tracking units depend on the current font size. In a 12‑point font, 1 em equals 12 points. A point is about 0.35mm, so a 1000 units of tracking for 12 point text produces about 4.2mm of space between each character.","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"function text_tracking_example()\n    fonts = [\n        \"Verdana\",\n        \"TrebuchetMS\",\n        \"Times-Roman\",\n        \"Georgia\",\n        \"Monaco\"]\n    fsize = 16\n    grid = GridRect(boxtopleft(BoundingBox() * 0.9), 0, 20)\n    tracking = 50\n    for f in fonts\n        fontsize(fsize)\n        fontface(f)\n        texttrack(\"This is some text in $(f): it’s been tracked by +$(tracking)\",\n            nextgridpoint(grid), tracking, fsize)\n        text(\"This is some text in $(f): it’s not been tracked\",\n            nextgridpoint(grid))\n        texttrack(\"This is some text in $(f): it’s been tracked by -$(tracking)\",\n            nextgridpoint(grid), -tracking, fsize)\n    end\n    finish()\nend\n\ntext_tracking_example()","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"(Image: textbox)","category":"page"},{"location":"howto/text/#Text-fitting","page":"Add text","title":"Text fitting","text":"","category":"section"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"Sometimes you want to fit some text into a specific area, rather than use a specific font size.","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"To do this, use textfit, and supply the text and a bounding box.","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"using Luxor # hide\nd = Drawing(800, 800, :svg) # hide\norigin() # hide\nbackground(\"grey7\") # hide\nrh = 700 .* [4//11, 2//11, 4//11, 1//11]\ncw = 700 .* [6//11, 2//11, 3//11, 1//11]\ncells = Table(rh, cw)\nfor (pos, n) in cells\n    setgrey(rand()/2)\n    box(cells, n, :fill)\n    setgrey(1)\n    textfit(\"The sound of one hand clapping\", BoundingBox(box(cells, n)), horizontalmargin=10)\nend\nfinish() # hide\nd # hide","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"You can supply a value for maximumfontsize as an optional argument, such that the text never exceeds that size (although it will probably be smaller).","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"note: Note\nThe algorithm used by this function doesn't always produce ideal results. Suggestions for improvements welcome!","category":"page"},{"location":"howto/text/#Animating-text","page":"Add text","title":"Animating text","text":"","category":"section"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"To animate the drawing of text, you can obtain and store the paths, and then build an animation using drawpath().","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"(Image: text animation)","category":"page"},{"location":"howto/text/","page":"Add text","title":"Add text","text":"function frame(scene, framenumber)\n    background(\"black\")\n    sethue(\"gold\")\n    fontface(\"BigMummy\")\n    fontsize(40)\n    textpath(\"Thank you for using\", boxtopcenter() + (0, 80) , halign=:center)\n    tp1 = storepath()\n    fontsize(130)\n    textpath(\"Luxor\", O + (0, 80), halign=:center)\n    tp2 = storepath()\n\n    eased_n = scene.easingfunction(framenumber - scene.framerange.start,\n        0, 1, scene.framerange.stop - scene.framerange.start)\n\n    for tp in (tp1, tp2)\n        drawpath(tp, eased_n, action = :stroke)\n    end\nend\n\namovie = Movie(600, 250, \"a movie\")\nanimate(amovie, Scene(amovie, frame, 1:150), creategif=true, pathname=\"/tmp/textanimation.gif\")","category":"page"},{"location":"tutorial/simple-animation/#Make-simple-animations","page":"Simple animation","title":"Make simple animations","text":"","category":"section"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"Luxor.jl can help you build simple animations, by assembling a series of PNG images into an animated GIF.","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"note: Note\nTo make richer and more complex animations, use Javis.jl, which is designed specifically for the purpose.","category":"page"},{"location":"tutorial/simple-animation/#:-A-Julia-spinner","page":"Simple animation","title":"1: A Julia spinner","text":"","category":"section"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"The first thing to do is to create a Movie object. This acts as a useful way to pass information from function to function.","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"using Luxor\nmymovie = Movie(400, 400, \"mymovie\")","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"The resulting animation will be 400 × 400 pixels.","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"To make the graphics, define a function called frame() (it doesn't have to be called that, but it's a good name) which accepts two arguments, a Scene object, and a framenumber (which  will be an integer).","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"A movie consists of one or more scenes. A scene determines how many Luxor drawings should be made into a sequence and what function should be used to make them. The framenumber lets you keep track of where you are in a scene.","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"Here's a simple frame function which creates a drawing.","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"function frame(scene::Scene, framenumber::Int64)\n    background(\"white\")\n    norm_framenumber = rescale(framenumber,\n        scene.framerange.start,\n        scene.framerange.stop,\n        0, 1)\n    rotate(norm_framenumber * 2π)\n    juliacircles(100)\nend","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"This function is responsible for drawing all the graphics for a single frame. The incoming frame number is converted (normalized) to lie between 0 and 1 - ie. between the first frame and the last frame of the scene. It's multiplied by 2π and used as input to rotate. So, as the framenumber goes from 1 to the last frame in the scene, each drawing will be rotated by an increasing angle from 0 to 2π. For example, for a scene with 60 frames, framenumber 30 will set a rotation value of about 2π * 0.5.","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"The Scene object has details about the number of frames for this scene, including the number of times the frame function is called.","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"To actually build the animation, the animate function takes a movie and an array of one or more scenes and creates all the drawings required. It can also build a GIF.","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"animate(mymovie,\n        [\n            Scene(mymovie, frame, 1:60)\n        ],\n    creategif=true,\n    pathname=\"juliaspinner.gif\")","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"(Image: julia spinner)","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"Obviously, if you increase the range from 1:60 to, say, 1:300, you'll generate 300 drawings rather than 60, and the rotation will take longer and will be much smoother. Of course, you could change the framerate to be something other than the default 30.","category":"page"},{"location":"tutorial/simple-animation/#:-Combining-scenes","page":"Simple animation","title":"2: Combining scenes","text":"","category":"section"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"In the next example, we'll construct an animation that uses different scenes.","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"Consider this animation, showing the sun’s position for each hour of a 24 hour day. (It’s only a model...)","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"(Image: sun24 animation)","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"Again, start by creating a movie, a useful handle that we can pass from function to function. We'll specify 24 frames for the entire animation.","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"sun24demo = Movie(400, 400, \"sun24\", 0:23)","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"We'll define a simple backgroundfunction function that draws a background that will be used for all frames (since animated GIFs like constant backgrounds):","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"function backgroundfunction(scene::Scene, framenumber)\n    background(\"black\")\nend","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"A nightskyfunction draws the night sky, covering the entire drawing:","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"function nightskyfunction(scene::Scene, framenumber)\n    sethue(\"midnightblue\")\n    box(O, 400, 400, action = :fill)\nend","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"A dayskyfunction draws the daytime sky:","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"function dayskyfunction(scene::Scene, framenumber)\n    sethue(\"skyblue\")\n    box(O, 400, 400, action = :fill)\nend","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"The sunfunction draws a sun at 24 positions during the day. Since the framenumber will be a number between 0 and 23, this can be easily converted to lie between 0 and 2π.","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"function sunfunction(scene::Scene, framenumber)\n    t = rescale(framenumber, 0, 23, 2pi, 0)\n    gsave()\n        sethue(\"yellow\")\n        circle(polar(150, t), 20, action = :fill)\n    grestore()\nend","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"And finally, tere's a groundfunction that draws the ground, the lower half of the drawing:","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"function groundfunction(scene::Scene, framenumber)\n    gsave()\n    sethue(\"brown\")\n    box(Point(O.x, O.y + 100), 400, 200, action = :fill)\n    grestore()\n    sethue(\"white\")\nend","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"To combine these together, we'll define a group of Scenes that make up the movie. The scenes specify which functions are to be used, and for which frames:","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"backdrop  = Scene(sun24demo, backgroundfunction, 0:23)   # every frame\nnightsky  = Scene(sun24demo, nightskyfunction, 0:6)      # midnight to 06:00\nnightsky1 = Scene(sun24demo, nightskyfunction, 17:23)    # 17:00 to 23:00\ndaysky    = Scene(sun24demo, dayskyfunction, 5:19)       # 05:00 to 19:00\nsun       = Scene(sun24demo, sunfunction, 6:18)          # 06:00 to 18:00\nground    = Scene(sun24demo, groundfunction, 0:23)       # every frame","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"Finally, the animate function scans all the scenes in the scenelist for the movie, and calls the specified functions for each frame to build the animation:","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"animate(sun24demo, [\n   backdrop, nightsky, nightsky1, daysky, sun, ground\n   ],\n   framerate=5,\n   creategif=true)","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"(Image: sun24 animation)","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"Notice that, for some frames, such as frame 0, 1, or 23, three of the functions are called: for others, such as 7 and 8, four or more functions are called.","category":"page"},{"location":"tutorial/simple-animation/#An-alternative","page":"Simple animation","title":"An alternative","text":"","category":"section"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"As this is a very simple example, there is of course an easier way to make this particular animation.","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"We can use the incoming framenumber, rescaled, as the master parameter that determines the position and appearance of all the graphics.","category":"page"},{"location":"tutorial/simple-animation/","page":"Simple animation","title":"Simple animation","text":"function frame(scene, framenumber)\n    background(\"black\")\n    n   = rescale(framenumber, scene.framerange.start, scene.framerange.stop, 0, 1)\n    n2π = rescale(n, 0, 1, 0, 2π)\n    sethue(n, 0.5, 0.5)\n    box(BoundingBox(), action = :fill)\n    if 0.25 < n < 0.75\n        sethue(\"yellow\")\n        circle(polar(150, n2π + π/2), 20, action = :fill)\n    end\n    if n < 0.25 || n > 0.75\n        sethue(\"white\")\n        circle(polar(150, n2π + π/2), 20, action = :fill)\n    end\nend","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"DocTestSetup = quote\n    using Luxor, Colors\n    end","category":"page"},{"location":"howto/images/#Placing-images","page":"Placing images","title":"Placing images","text":"","category":"section"},{"location":"howto/images/#Loading-and-placing-PNG-and-SVG-images","page":"Placing images","title":"Loading and placing PNG and SVG images","text":"","category":"section"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"Luxor lets you place existing PNG and SVG images on the drawing. First, load the image:","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"for PNG images, use readpng(filename)\nfor SVG images, use readsvg(filename) or readsvg(string)","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"(JPEGs aren't supported.)","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"Then use placeimage to place the image by its top left corner at point pt, or use the centered=true keyword to place the image's center point there. Access the image's dimensions with .width and .height.","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"using Luxor # hide\nDrawing(600, 350, \"../assets/figures/images.png\") # hide\norigin() # hide\nbackground(\"grey40\") # hide\nimg = readpng(\"../assets/figures/julia-logo-mask.png\")\nw = img.width\nh = img.height\nrulers()\nscale(0.3, 0.3)\nrotate(π/4)\nplaceimage(img, Point(-w/2, -h/2), .5)\nsethue(\"red\")\ncircle(-w/2, -h/2, 15, :fill)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"(Image: \"Images\")","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"PNG images can be placed with varying opacity or transparency.","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"readsvg also lets you supply raw (or pure) SVG code in a string.","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"You can also use placeimage() to place an array of RGB or RGBA pixels on a drawing.","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"using Luxor, Colors # hide\nN = 500\ni = reshape([RGBA(rand(4)...) for p in 1:N^2], N, N)\n# is is Matrix{RGBA{Float64}} \n# (alias for Array{RGBA{Float64}, 2})\n@draw begin\n  origin()\n  sethue(\"orange\")\n  box(O, N/2, N/2, :fill)\n  placeimage(i, O, centered=true, alpha=0.5)\nend 500 500","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"Or load an image as an array and place it on a drawing.","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"using Luxor, Colors, FileIO\nimg = load(dirname(dirname(pathof(Luxor))) * \"/docs/src/assets/figures/42.png\")\n@draw begin\n    img[1:50, :] .= colorant\"cyan\"\n    img[200:end, :] .= colorant\"magenta\"\n    placeimage(img, O, centered=true, alpha=0.5)\nend 250 250","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"(Image: \"Images\")","category":"page"},{"location":"howto/images/#SVG-images","page":"Placing images","title":"SVG images","text":"","category":"section"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"To create an SVG image, using the Drawing(... :svg) or specify an SVG filename. To obtain the SVG source of a completed drawing, use svgstring.","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"For example, draw the Julia logo:","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"Drawing(500, 500, :svg)\norigin()\njulialogo()\nfinish()\ns = svgstring()","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"The SVG source code is now stored in s. You can examine or process it further:","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"eachmatch(r\"rgb\\\\(.*?\\\\)\", s) |> collect\n5-element Vector{RegexMatch}:\n RegexMatch(\"rgb(0%,0%,0%)\")\n RegexMatch(\"rgb(79.6%,23.5%,20%)\")\n RegexMatch(\"rgb(25.1%,38.8%,84.7%)\")\n RegexMatch(\"rgb(58.4%,34.5%,69.8%)\")\n RegexMatch(\"rgb(22%,59.6%,14.9%)\")","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"To display the image in a Jupyter or Pluto notebook, use the HTML function, or you can use the readsvg and placeimage functions in combination.","category":"page"},{"location":"howto/images/#Placing-an-image-matrix","page":"Placing images","title":"Placing an image matrix","text":"","category":"section"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"You can also use placeimage to put image matrices on a drawing.","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"using Luxor\n\nmat = @imagematrix begin    \n    juliacircles(6)\nend 40 40\n\n@draw begin\n    for i in 1:500\n        pos = rand(BoundingBox())\n        @layer begin\n            translate(pos)\n            rotate(rand() * 2π)\n            placeimage(mat, centered = rand(Bool))\n        end\n    end\nend","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"(Image: place image matrix)","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"placeimage can also take in an optional argument alpha to change the opacity of the image matrix.","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"(Image: place image matrix alpha)","category":"page"},{"location":"howto/images/#Clipping-images","page":"Placing images","title":"Clipping images","text":"","category":"section"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"You can clip images. The following script repeatedly places the image using a circle to define a clipping path:","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"(Image: \"Images\")","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"using Luxor\n\nwidth, height = 4000, 4000\nmargin = 500\n\nfname = \"test-image.pdf\"\nDrawing(width, height, fname)\norigin()\nbackground(\"grey25\")\n\nsetline(5)\nsethue(\"green\")\n\nimage = readpng(dirname(@__FILE__) * \"../assets/figures/julia-logo-mask.png\")\n\nw = image.width\nh = image.height\n\npagetiles = Tiler(width, height, 7, 9)\ntw = pagetiles.tilewidth/2\nfor (pos, n) in pagetiles\n    circle(pos, tw, :stroke)\n    circle(pos, tw, :clip)\n    gsave()\n    translate(pos)\n    scale(.95, .95)\n    rotate(rand(0.0:π/8:2π))\n    placeimage(image, O, centered=true)\n    grestore()\n    clipreset()\nend\n\nfinish()","category":"page"},{"location":"howto/images/#Transforming-images","page":"Placing images","title":"Transforming images","text":"","category":"section"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"You can transform images by setting the current matrix, either with scale and rotate and similar, or by modifying it directly. This code scales and rotates an image made in an earlier chapter of this document around in a circle:","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"using Luxor # hide\nDrawing(600, 400, \"../assets/figures/transform-images.png\") # hide\norigin() # hide\nimg = readpng(dirname(dirname(pathof(Luxor))) * \"/docs/src/assets/figures/textoutlines.png\")\nw = img.width\nh = img.height\nfor θ in 0:π/6:2π-π/6\n    gsave()\n    scale(.4, .4)\n    rotate(θ)\n    translate(300, 0)\n    placeimage(img, -w/2, -h/2, 0.9)\n    grestore()\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"(Image: transforming images)","category":"page"},{"location":"howto/images/#Combining-images-and-vector-graphics","page":"Placing images","title":"Combining images and vector graphics","text":"","category":"section"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"You sometimes want to combine vector graphics and images, for example, to annotate them with text or vector graphics.","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"There are two ways you can do this: ","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"by adding the image with placeimage() and then drawing vector graphics on top. \nby opening the image as a drawing, and adding vector graphics into the image. ","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"The things to be aware of are mostly to do with coordinates and transforms.","category":"page"},{"location":"howto/images/#Adding-graphics-on-top","page":"Placing images","title":"Adding graphics on top","text":"","category":"section"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"In this example, we'll annotate a PNG file.","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"using Luxor # hide\n\nimage = readpng(\"../assets/figures/julia-logo-mask.png\")\n\nw = image.width\nh = image.height\n\n# create a drawing surface of the same size\n\nfname = \"../assets/figures/drawing_on_images.png\"\nDrawing(w, h, fname)\n\n# place the image on the Drawing - it's positioned by its top/left corner\n\nplaceimage(image, 0, 0)\n\n# now you can annotate the image. The (0/0) is at the top left.\n\nsethue(\"red\")\nsetline(1)\nfontsize(16)\ncircle(Point(150, 50), 2, :fill)\nlabel(\"(150/50)\", :NE, Point(150, 50), leader=true, offset=25)\n\narrow(Point(w/2, 90), Point(0, 90))\narrow(Point(w/2, 90), Point(w, 90))\ntext(\"width $w\", Point(w/2, 70), halign=:center)\n\n# to divide up the image into rectangular areas and number them,\n# temporarily position the axes at the center:\n\n@layer begin\n  setline(0.5)\n  sethue(\"green\")\n  fontsize(12)\n  translate(w/2, h/2)\n  tiles = Tiler(w, h, 8, 8, margin=0)\n  for (pos, n) in tiles\n      box(pos, tiles.tilewidth, tiles.tileheight, :stroke)\n      text(string(n-1), pos, halign=:center)\n  end\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"(Image: drawing on images)","category":"page"},{"location":"howto/images/#Adding-text-to-transformed-placed-images","page":"Placing images","title":"Adding text to transformed placed images","text":"","category":"section"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"The above approach works well, but suppose you want to locate the working origin at the lower left of the image, i.e. you want all coordinates to be relative to the bottom left corner of the image?","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"To do this, use translate and transform to modify the drawing space:","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"using Luxor # hide\n\nimage = readpng(\"../assets/figures/julia-logo-mask.png\")\nw = image.width\nh = image.height\nfname = \"../assets/figures/drawing_on_images_2.png\"\nDrawing(w, h, fname)\nplaceimage(image, 0, 0)\n\n# Move the axes to the bottom:\n\ntranslate(0, h)\n\n# and reflect in the x-axis\n\ntransform([1 0 0 -1 0 0])\n\n# now 0/0 is at the bottom left corner, and 100/100 is up and to the right.\n\nsethue(\"blue\")\narrow(Point(200, 300), Point(160, 300))\n\n# However, don't draw text while flipped, because it will be reversed!\n\nfontsize(20)\nsethue(\"black\")\ntext(\"Oh no!\", Point(30, 250))\n\n# To work around this, define a text function\n# that flips the workspace over the x-axis just for the text:\n\nfunction textoverlay(t, pos; kwargs...)\n    @layer begin\n        translate(pos)\n        transform([1 0 0 -1 0 0])\n        text(t, O; kwargs...)\n    end\nend\n\ntextoverlay(\"a tittle!\", Point(200, 300), halign=:left, valign=:middle)\ntextoverlay(\"0/0\", O)\narrow(Point(130, 400), Point(130, 340))\n\nfinish() # hide\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"(Image: drawing on transformed images)","category":"page"},{"location":"howto/images/#Opening-the-image-as-drawing","page":"Placing images","title":"Opening the image as drawing","text":"","category":"section"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"An alternative way to work with images is to open the image as a drawing. Let's open the well-known mandrill image in Luxor. (I'll call him Marvin, because I couldn't find out whether or not the model had a name, but I think he should have one.)","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"using Luxor, Colors, Images, TestImages\n\nmarvin = testimage(\"mandrill\")\nM = Luxor.Colors.ARGB32.(marvin)\nDrawing(M)","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"The current drawing is now a 512 × 512 array, where each pixel is an ARGB32 (an unsigned 32-bit integer holding 4 8-bit vaalues).","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"Marvin's right eye (on the left side of the drawing) is located at about 60 rows down, 175 columns across. Let's fill in his pupil with a white square:","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"M[55:65, 170:180] .= colorant\"white\"\nM","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"(Image: drawing into image)","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"Using M on its own should show the image in your notebook or code editor (but not the REPL). If you want to save it, using the standard Images.jl functions.","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"We can use these indices as x and y coordinates, since the drawing origin is also currently at the top left.","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"sethue(\"white\")\ncircle(Point(60, 175), 20, :stroke)\nM","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"If we want to draw, say, a 10 by 10 numbered grid overlay on top of Marvin, and highlight four numbered cells, it's easier to just add a transform() function that flips the x/cols and y/rows convention, then create a table centered at the center of the drawing:","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"fontsize(15)\nsethue(\"white\")\nsetline(1)\ntransform([0 1 1 0 0 0])\ncells = Table(10, 10, 512 / 10, 512 / 10, Point(512 / 2, 512 / 2))\nfor (pos, n) in cells\n    text(string(n), pos, halign = :center, valign = :middle)\n    box(pos, 512 / 10, 512 / 10, :stroke)\nend\nsetline(5)\nhighlightcells(cells, collect(1:100)[[2, 4, 35, 69]], :stroke, \n    color = colorant\"blue\")\nM","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"(Image: drawing into image)","category":"page"},{"location":"howto/images/#Image-compositing","page":"Placing images","title":"Image compositing","text":"","category":"section"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"You should be using Images.jl for most tasks involving image editing. But if you just need to composite images together, you can use the blending modes provided by setmode.","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"using Luxor # hide\nDrawing(600, 400, \"../assets/figures/image-compositing.png\") # hide\norigin() # hide\nimg = readpng(\"../assets/figures/textoutlines.png\")\nw = img.width\nh = img.height\n\nplaceimage(img, -w/2, -h/2, .5)\nsetmode(\"saturate\")\ntranslate(50, 0)\nplaceimage(img, -w/2, -h/2, .5)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/images/","page":"Placing images","title":"Placing images","text":"(Image: transforming images)","category":"page"},{"location":"howto/livegraphics/#Interactive-graphics-and-Threads","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"","category":"section"},{"location":"howto/livegraphics/#Continuous-display","page":"Interactive graphics and Threads","title":"Continuous display","text":"","category":"section"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"With the help of an external appication to manage windows, it's possible to use Luxor to create continuously changing graphics in a window.","category":"page"},{"location":"howto/livegraphics/#The-@play-macro","page":"Interactive graphics and Threads","title":"The @play macro","text":"","category":"section"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"This example uses the MiniFB package, which you can add using ] add MiniFB.","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"The file play.jl defines a simple macro, @play, which continuously evaluates and draws the graphics in a window. For example, this code:","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"using Luxor\n\ninclude(dirname(pathof(Luxor)) * \"/play.jl\")\n\nlet θ = 0\n    @play 400 400 begin\n    #\n        background(\"black\")\n        sethue(\"white\")\n        rotate(θ)\n        hypotrochoid(200, 110, 37, :stroke)\n        θ += π/120\n        sleep(0.01)\n    #\n    end\nend","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"draws a continuously rotating hypotrochoid.","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"(Image: live hypo)","category":"page"},{"location":"howto/livegraphics/#Clock","page":"Interactive graphics and Threads","title":"Clock","text":"","category":"section"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"This code also imports the @play macro.","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"The call to sleep reduces the CPU time, and allows other processes to run, but the millisecond animation will be less smooth as a result.","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"(Image: clock)","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"using Luxor, Colors, Dates, ColorSchemes\n\ninclude(dirname(pathof(Luxor)) * \"/play.jl\")\n\nfunction clock(cscheme=ColorSchemes.leonardo)\n    @play 400 600 begin\n\n        # background\n        sethue(get(cscheme, .0))\n        paint()\n\n        # 24hour sector\n        fontsize(30)\n        sethue(get(cscheme, .2))\n        h = Dates.hour(now())\n        sector(O, 180, 200, π/2, π/2 + rescale(h, 0, 24, 0, 2pi), :fill)\n\n        @layer begin\n            fontsize(12)\n            sethue(\"white\")\n            @. text([\"0\", \"6\", \"12\", \"18\"], polar(190, [i * π/2 for i in 1:4]),\n                halign=:center,\n                valign=:middle)\n        end\n\n        # minute sector\n        sethue(get(cscheme, .4))\n        m = Dates.minute(now())\n        sector(O, 160, 180, 3π/2, 3π/2 + rescale(m, 0, 60, 0, 2pi), :fill)\n\n        # second sector\n        sethue(get(cscheme, .6))\n        s = Dates.second(now())\n        sector(O, 140, 160, 3π/2, 3π/2 + rescale(s, 0, 60, 0, 2pi), :fill)\n\n        # millisecond indicator\n        @layer begin\n            setopacity(0.5)\n            sethue(get(cscheme, .8))\n            ms = Dates.value(Dates.Millisecond(Dates.now()))\n            circle(polar(120, 3π/2 + rescale(ms, 0, 1000, 0, 2pi)), 20, :fill)\n        end\n\n        # central text\n        fontface(\"JuliaMono-Black\")\n        sethue(get(cscheme, 1.0))\n        text(Dates.format(Dates.now(), \"HH:MM:SS\"), halign=:center)\n\n        sleep(0.05)\n    end\nend\n\nclock(ColorSchemes.klimt)","category":"page"},{"location":"howto/livegraphics/#Live-coding-with-MiniFB","page":"Interactive graphics and Threads","title":"Live coding with MiniFB","text":"","category":"section"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"Here are some examples of how to use Luxor with MiniFB as the display window, without using the simple @play macro.","category":"page"},{"location":"howto/livegraphics/#Interactivity","page":"Interactive graphics and Threads","title":"Interactivity","text":"","category":"section"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"This example lets you type graphic commands at the REPL and see the results instantly displayed in a window.","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"First, run this code to connect a Luxor drawing to a MiniFB buffer:","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"using Luxor\nusing Colors\nusing MiniFB\n\nfunction window_update_task(window, buffer, showFPS=false)\n    state = mfb_update(window, buffer)\n    updateCount = 0\n    startTime = floor(Int, time())\n    fps = \"0\"\n    while state == MiniFB.STATE_OK\n        if showFPS\n            elapsedTime = floor(Int, time()) - startTime\n            if elapsedTime > 1\n                fps = string(round(Int, updateCount / elapsedTime))\n                startTime = floor(Int, time())\n                updateCount = 0\n            end\n            @layer begin\n                setcolor(\"black\")\n                circle(boxtopleft() + (15, 15), 15, :fill)\n                setcolor(\"white\")\n                fontsize(20)\n                text(fps, boxtopleft() + (15, 15), halign=:center, valign=:middle)\n            end\n        end\n        state = mfb_update(window, buffer)\n        sleep(1.0 / 120.0)\n        updateCount += 1\n    end\n    println(\"\\nWindow closed\\n\")\nend\n\nconst WIDTH = 800\nconst HEIGHT = 600\n\nbuffer = zeros(ARGB32, WIDTH, HEIGHT)\nd = Drawing(buffer)\nwindow = mfb_open_ex(\"MiniFB\", WIDTH, HEIGHT, MiniFB.WF_RESIZABLE)\n@async window_update_task(window, buffer, true)","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"Now, the window will display the results of any expressions you type at the REPL:","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"(Image: live graphics 1)","category":"page"},{"location":"howto/livegraphics/#Live-animations","page":"Interactive graphics and Threads","title":"Live animations","text":"","category":"section"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"If you want to do live animations in the window in a \"while\" loop, you need to call sleep() for a while to allow the window_update_task() to get some execution time. ","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"In this example you can enter \"q\" and \"return\" in the REPL to stop the animation's while loop. Using \"ctrl-c\" to stop the animation could also stop the window update task by chance.","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"(Image: live graphics 2)","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"<details closed><summary>Code for this example</summary>","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"mutable struct Ball\n    position::Point\n    velocity::Point\nend\nfunction sticks(w, h)\n    channel = Channel(10)\n    #enter \"q\" and \"return\" to stop the while loop\n    @async while true\n        kb = readline(stdin)\n        if contains(kb, \"q\")\n            put!(channel, 1)\n            break\n        end\n    end\n    colors = [ rand(1:255), rand(1:255), rand(1:255) ]\n    newcolors  = [ rand(1:255), rand(1:255), rand(1:255) ]\n    c = ARGB(colors[1]/255, colors[2]/255, colors[3]/255, 1.0)\n    balls = [ Ball( rand(BoundingBox(Point(-w/2, -h/2), Point(w/2, h/2))), rand(BoundingBox(Point(-10, -10), Point(10, 10))) ) for _ in 1:2 ] \n    while true\n        background(0, 0, 0, 0.05)\n        if colors == newcolors\n            newcolors = [ rand(1:255), rand(1:255), rand(1:255) ]\n        end\n        for (index, (col, newcol)) in enumerate(zip(colors, newcolors))\n            if col != newcol\n                col > newcol ? col -= 1 : col += 1\n                colors[index] = col\n            end\n        end\n        c = ARGB(colors[1]/255, colors[2]/255, colors[3]/255, 1.0)\n        for ball in balls\n            if !(-w/2 < ball.position.x < w/2)\n                ball.velocity = Point(-ball.velocity.x, ball.velocity.y)\n            end\n            if !(-h/2 < ball.position.y < h/2)\n                ball.velocity = Point(ball.velocity.x, -ball.velocity.y)\n            end\n            ball.position = ball.position + ball.velocity\n        end\n        setcolor(c)\n        line(balls[1].position, balls[2].position, :stroke)\n        sleep(1.0/120.0)\n        if isready(channel)\n            break\n        end\n    end\nend\n\norigin()\nsticks(WIDTH, HEIGHT)","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"</details>","category":"page"},{"location":"howto/livegraphics/#Interactive-graphics-with-multiple-drawings","page":"Interactive graphics and Threads","title":"Interactive graphics with multiple drawings","text":"","category":"section"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"This next example shows how to work with multiple drawings. We'll create three windows, then combine (AND) the contents of the first two and display them in the third.","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"(Image: multiple drawings)","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"First, we'll setup our display buffers and MiniFB windows, one for each Luxor drawing:","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"using MiniFB, Luxor, Colors, FixedPointNumbers\n\nWIDTH=500\nHEIGHT=500\n\nfunction window_update_task(window,buffer)\n    state=mfb_update(window,buffer)\n    while state == MiniFB.STATE_OK\n        state=mfb_update(window,buffer)\n        sleep(1.0/120.0)\n    end\n    println(\"\\nWindow closed\\n\")\nend\n\nwindow1 = mfb_open_ex(\"1\", WIDTH, HEIGHT, MiniFB.WF_RESIZABLE)\nbuffer1 = zeros(ARGB32, WIDTH, HEIGHT)\n@async window_update_task(window1,buffer1)\n\nwindow2 = mfb_open_ex(\"2\", WIDTH, HEIGHT, MiniFB.WF_RESIZABLE)\nbuffer2 = zeros(ARGB32, WIDTH, HEIGHT)\n@async window_update_task(window2,buffer2)\n\nwindow3 = mfb_open_ex(\"3=1+2\", WIDTH, HEIGHT, MiniFB.WF_RESIZABLE)\nbuffer3 = zeros(ARGB32, WIDTH, HEIGHT)\n@async window_update_task(window3,buffer3)","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"Buffers 1, 2, and 3 are the buffers for the three MiniFB windows. They'll appear on your display.","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"Next we'll create three Luxor drawings that connect to these buffers.","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"d1 = Drawing(buffer1)    \n\nLuxor.set_next_drawing_index()   \nd2 = Drawing(buffer2)\n\nLuxor.set_next_drawing_index()   \nd3 = Drawing(buffer3, \"julia.png\")","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"We now have three drawings which are continuously updated and visible in three separate windows. Let's start by drawing on drawing 1.","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"Luxor.set_drawing_index(1) \norigin()\nsetopacity(0.4)\nforegroundcolors = Colors.diverging_palette(\n    rand(0:360), \n    rand(0:360), \n    200, s=0.99, b=0.8)\ngsave()\nfor i in 1:500\n    sethue(foregroundcolors[rand(1:end)])\n    circle(Point(rand(-300:300), rand(-300:300)), 15, :fill)\nend\ngrestore()","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"Now let's switch to drawing 2 and draw the Julia logo:","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"Luxor.set_drawing_index(2)\norigin()\nsetopacity(1.0)\ngsave()\njulialogo(centered=true, bodycolor=colorant\"white\")\ngrestore()","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"Finally, we'll switch to drawing 3, and set its contents by ANDing the buffers of drawings 1 and 2:","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"Luxor.set_drawing_index(3)  \nbackground(\"black\")\nbuffer3 .= reinterpret(ARGB{N0f8}, \n    (reinterpret.(UInt32,buffer1) .& \n     reinterpret.(UInt32,buffer2)))","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"To finish, we'll set the opacity of each pixel to 1.0:","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"buffer3.=ARGB32.(RGB24.(buffer3))\n\nfinish()\npreview()","category":"page"},{"location":"howto/livegraphics/#Threads","page":"Interactive graphics and Threads","title":"Threads","text":"","category":"section"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"Luxor is thread safe. To run the examples below, start Julia with more than 1 thread:","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"julia> Threads.nthreads()\n4","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"As a first example, we'll produce multiple PNG files in parallel:","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"using Luxor, Colors\n\ntempdir = mktempdir(;cleanup=false)\ncd(tempdir)\n\nfunction make_drawings(i::Int)\n    println(Threads.threadid())\n    colors = [\"red\", \"green\", \"blue\", \"yellow\", \"pink\"]\n    w = 300\n    h = 300\n    filename = \"sample\" * string(i) * \".png\"\n    Drawing(w, h, :png, filename)\n    origin()\n    setcolor(colors[1 + i % 5])\n    background(0.0, 0.0, 0.0, 1.0)\n    circle(0, 0, 100, :fill)\n    finish()\n    return\nend\n\nThreads.@threads for i = 1:(2*Threads.nthreads())\n    make_drawings(i)\nend","category":"page"},{"location":"howto/livegraphics/#Advanced-threads-with-live-view","page":"Interactive graphics and Threads","title":"Advanced threads with live view","text":"","category":"section"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"To demonstrate what is possible, we again show live graphics in MiniFB windows,  but this time in different threads.","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"There are two ways to use threads with Luxor. ","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"One way is to use a single thread for each window we want to show, i.e each window we spawn and the Luxor graphics inside is a different thread. ","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"The other way to use threads is e.g. a single window, with several threads all drawing into the same buffer, which is shown in the single window. For this you need to utilize locks as shown in the second example below.","category":"page"},{"location":"howto/livegraphics/#A-thread-for-each-window","page":"Interactive graphics and Threads","title":"A thread for each window","text":"","category":"section"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"First, here's an example where each window and its graphics is a single thread. No locks or channels are needed.","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"Let's start with the header and a helper function for our animation:","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"using ThreadPools\n# the low level Threads.@spawn macro can not be used, because threads are scheduled\n# randomly into available threadids. If a thread is spawned into an already running \n# threadid, the former thread # is closed by the scheduler. So we use the better \n# ThreadPools.spawnbg to spawn the threads.\n\nusing MiniFB, Luxor, Colors, FixedPointNumbers\n\nmutable struct Ball\n    position::Point\n    velocity::Point\nend\n\nfunction step_ball(ball, w, h, r)\n    if ball.position.x - r < -w / 2 || ball.position.x + r > w / 2\n        ball.velocity = Point(-ball.velocity.x, ball.velocity.y)\n    end\n    if ball.position.y - r < -h / 2 || ball.position.y + r > h / 2\n        ball.velocity = Point(ball.velocity.x, -ball.velocity.y)\n    end\n    ball.position = ball.position + ball.velocity\n    return ball\nend","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"Open and run the first window in its own thread:","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"function window_ball()\n    w=500\n    h=500\n    r=50\n    buffer = zeros(RGB24, w, h)\n    ball=Ball(Point(0, 0), rand(BoundingBox(Point(-10, -10), Point(10, 10))))\n    Drawing(buffer)\n    origin()\n    window = mfb_open_ex(\"Ball\", w, h, MiniFB.WF_RESIZABLE)\n    state = MiniFB.STATE_OK\n    while state == MiniFB.STATE_OK\n        ball=step_ball(ball, w, h, r)\n        background(0.0, 0.0, 0.0, 1.0)\n        setcolor(\"red\")\n        circle(ball.position.x, ball.position.y, r, :fill)\n        state=mfb_update(window, buffer)\n        sleep(1.0/120.0)\n    end\n    println(\"\\nWindow closed\\n\")\nend\nspawnbg(window_ball)","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"Open and run a second window in its own thread:","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"function window_stick()\n    w=500\n    h=500\n    r=0\n    buffer = zeros(RGB24, w, h)\n    balls=[Ball(rand(BoundingBox(Point(-w/2, -h/2), \n        Point(w/2, h/2))), \n        rand(BoundingBox(Point(-10, -10), Point(10, 10)))) for _ in 1:2] \n    Drawing(buffer)\n    origin()\n    background(0.0,0.0,0.0,1.0)\n    window = mfb_open_ex(\"Sticks\", w, h, MiniFB.WF_RESIZABLE)\n    state = MiniFB.STATE_OK\n    while state == MiniFB.STATE_OK\n        background(0.0, 0.0, 0.0, 0.05)\n        setcolor(\"green\")\n        for ball in balls\n            ball=step_ball(ball, w, h, r)\n        end\n        line(balls[1].position, balls[2].position, :stroke)\n        state=mfb_update(window, buffer)\n        sleep(1.0/120.0)\n    end\n    println(\"\\nWindow closed\\n\")\nend\nspawnbg(window_stick)","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"If you have threads left you can start another thread with a third window:","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"spawnbg(window_stick)","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"If you run out of threadids, the command spawnbg(window_stick) will block the REPL until a thread is freed, e.g. by closing one of the windows.","category":"page"},{"location":"howto/livegraphics/#A-single-window-with-graphics-of-several-threads","page":"Interactive graphics and Threads","title":"A single window with graphics of several threads","text":"","category":"section"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"The next example shows a single window/buffer where several threads are drawing into it. This needs some extra caution by utilizing locks, because every thread uses the same drawing buffer. Therefore all drawing commands needs to be synchronized with lock/unlock:","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"using ThreadPools\n\nusing MiniFB, Luxor, Colors\n\nstruct Window\n    c::ReentrantLock\n    w::Int\n    h::Int\n    d::Drawing\n    buffer::Matrix{ARGB32}\n    function Window(w,h)\n        c=ReentrantLock()\n        b=zeros(ARGB32, w, h)\n        d=Drawing(b)\n        origin()\n        new(c,w,h,d,b)\n    end\nend\n\nfunction window_update_task(win::Window, showFPS=true)\n    w=win.w\n    h=win.h\n    updateCount=0\n    startTime=floor(Int, time())\n    fps=\"0\"\n    sb=zeros(ARGB32, 105, 55)\n    window = mfb_open_ex(\"MiniFB\", w, h, MiniFB.WF_RESIZABLE)\n    state=MiniFB.STATE_OK\n    set_drawing = true\n    while state == MiniFB.STATE_OK\n        lock(win.c)\n        if set_drawing\n            currentdrawing(win.d)\n            set_drawing = false\n        end\n        if showFPS\n            elapsedTime=floor(Int,time())-startTime\n            if elapsedTime > 1\n                fps=string(round(Int,updateCount/elapsedTime))\n                startTime=floor(Int,time())\n                updateCount=0\n            end\n            sb.=win.buffer[1:105, 1:55]\n            @layer begin\n                (dx,dy) = Point(0.0, 0.0) - getworldposition(Point(0.0, 0.0);centered=false)\n                setcolor(1.0, 0, 0, 0.5)\n                fontsize(50)\n                text(fps, Point(5+dx, 5+dy), halign=:left, valign = :top)\n            end\n        end\n        state=mfb_update(window,win.buffer)\n        if showFPS\n            win.buffer[1:105, 1:55].=sb\n        end\n        background(0, 0, 0, 0.05)\n        unlock(win.c)\n        sleep(1.0/120.0)\n        updateCount+=1\n    end\n    println(\"\\nWindow closed\\n\")\nend","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"That's all we need to define a window with a fps display. Let's define it and run it as a new thread:","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"win = Window(800, 600)    # the window definition\n\n# we need a function without parameter, that's what we create here:\nlet window=win\n   global t_window_update_task\n   function t_window_update_task()\n       window_update_task(window)\n   end\nend\n\n# run the task as a new thread:\nspawnbg(t_window_update_task)","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"The window with a FPS display shows up. It runs in its own thread so we can still use the REPL to create new threads which draw into this window. The most important special code here is:","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"currentdrawing(win.d)","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"We start a new thread for every drawing and because the Luxor drawings of different threads are separated from each other to ensure thread safety, we overwrite the drawing in each thread with the drawing started with","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"win=Window(800, 600)","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"and stored in the win-object. See the constructor in struct Window.","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"Let's show it:","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"mutable struct Ball\n    position::Point\n    velocity::Point\nend\n\nfunction stick(win)\n    w = win.w\n    h = win.h\n    colors = [rand(1:255), rand(1:255), rand(1:255)]\n    newcolors = [rand(1:255), rand(1:255), rand(1:255)]\n    c = ARGB(colors[1] / 255, colors[2] / 255, colors[3] / 255, 1.0)\n    balls = [Ball(\n        rand(BoundingBox(Point(-w / 2, -h / 2), Point(w / 2, h / 2))), \n        rand(BoundingBox(Point(-10, -10), Point(10, 10)))) \n            for _ in 1:2]\n    set_drawing = true\n    while true\n        if colors == newcolors\n            newcolors = [rand(1:255), rand(1:255), rand(1:255)]\n        end\n        for (index, (col, newcol)) in enumerate(zip(colors, newcolors))\n            if col != newcol\n                col > newcol ? col -= 1 : col += 1\n                colors[index] = col\n            end\n        end\n        c = ARGB(colors[1] / 255, colors[2] / 255, colors[3] / 255, 1.0)\n        for ball in balls\n            if !(-w / 2 < ball.position.x < w / 2)\n                ball.velocity = Point(-ball.velocity.x, ball.velocity.y)\n            end\n            if !(-h / 2 < ball.position.y < h / 2)\n                ball.velocity = Point(ball.velocity.x, -ball.velocity.y)\n            end\n            ball.position = ball.position + ball.velocity\n        end\n        lock(win.c)\n        if set_drawing\n            currentdrawing(win.d)\n            set_drawing = false\n        end\n        setcolor(c)\n        line(balls[1].position, balls[2].position, :stroke)\n        unlock(win.c)\n        sleep(1.0 / 60.0)\n    end\nend\n\n# again a function for calling without parameter:\nlet window=win\n   global t_stick\n   function t_stick()\n       stick(window)\n   end\nend\n\n# run the thread and let the sticks fly:\nspawnbg(t_stick)","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"Because our threads are synchronized via lock/unlock we can spawn low-level threads as much as we want and our machine allows:","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"function spawn_many()\n    tid=1:Threads.nthreads()\n    for i in tid\n        t=Task(t_stick)\n        ccall(:jl_set_task_tid, Cvoid, (Any, Cint), t, i-1)\n        schedule(t)\n    end\nend","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"Now you can repeat it as much as you dare:","category":"page"},{"location":"howto/livegraphics/","page":"Interactive graphics and Threads","title":"Interactive graphics and Threads","text":"spawn_many()","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"DocTestSetup = quote\n    using Luxor, Colors\n    end","category":"page"},{"location":"tutorial/basictutorial/#A-tutorial","page":"Geometry tutorial","title":"A tutorial","text":"","category":"section"},{"location":"tutorial/basictutorial/#Euclidean-eggs","page":"Geometry tutorial","title":"Euclidean eggs","text":"","category":"section"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"The goal of this tutorial is to do a bit of basic 'compass and ruler' Euclidean geometry, to introduce the basic concepts of Luxor drawings. For the main section of this tutorial, we'll attempt to draw Euclid's egg, which involves a bit of geometry.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"For now, you can continue to store all the drawing instructions between the @png macro's begin and end markers without using too many functions. Technically, however, working like this at the top-level in Julia (ie without storing instructions in functions which Julia can compile) isn't considered to be 'best practice', because the unit of compilation in Julia is the function. (Look up 'global scope' in the documentation.) But speed isn't going to be a priority in this section.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"@png begin","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"Define the variable radius to hold a value of 80 units (there are 72 units in a traditional inch):","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"    radius=80","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"Select gray dotted lines. To specify a color you can supply RGB (or HSB or LAB or LUV) values or use named colors, such as \"red\" or \"green\". \"gray0\" is black, and \"gray100\" is white. (For more information about colors, see Colors.jl.)","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"    setdash(\"dot\")\n    sethue(\"gray30\")","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"(You can use setcolor instead of sethue — the latter doesn't affect the current opacity setting.)","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"Next, make two points, A and B, which will lie either side of the origin point. This line uses an array comprehension - notice the square brackets enclosing a for loop.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"    A, B = [Point(x, 0) for x in [-radius, radius]]","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"x uses two values from the inner array, and a Point using each value is created and stored in its own variable. It seems hardly worth doing for two points, but it shows how you can assign more than one variable at the same time, and also how to generate points.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"With two points defined, draw a line from A to B, and stroke it.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"    line(A, B, action = :stroke)","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"Draw a stroked circle too. The center of the circle is placed at the origin. You can use the letter O as a short cut for Origin, ie the Point(0, 0).","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"    circle(O, radius, action = :stroke)\nend","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"using Luxor\nDrawing(725, 300, \"../assets/figures/tutorial-egg-1.png\")\nbackground(\"white\")\norigin()\nradius=80\nsetdash(\"dot\")\nsethue(\"gray30\")\nA, B = [Point(x, 0) for x in [-radius, radius]]\nline(A, B, action = :stroke)\ncircle(O, radius, action = :stroke)\nfinish()\nnothing","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"(Image: point example)","category":"page"},{"location":"tutorial/basictutorial/#Labels-and-dots","page":"Geometry tutorial","title":"Labels and dots","text":"","category":"section"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"It's a good idea to label points in geometrical constructions, and to draw small dots to indicate their location clearly. For the latter task, small filled circles will do. For labels, there's a special label function we can use, which positions a text string close to a point, using angles or points of the compass, so :N places the label to the north of a point.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"Edit your previous code by adding instructions to draw some labels and circles:","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"@png begin\n    radius=80\n    setdash(\"dot\")\n    sethue(\"gray30\")\n    A, B = [Point(x, 0) for x in [-radius, radius]]\n    line(A, B, action = :stroke)\n    circle(Point(0, 0), radius, action = :stroke)\n# >>>>\n    label(\"A\", :NW, A)\n    label(\"O\", :N,  O)\n    label(\"B\", :NE, B)\n\n    circle.([A, O, B], 2, action = :fill)\n    circle.([A, B], 2radius, action = :stroke)\nend","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"using Luxor\nDrawing(725, 400, \"../assets/figures/tutorial-egg-2.png\")\nbackground(\"white\")\norigin()\nradius=80\nsetdash(\"dot\")\nsethue(\"gray30\")\n\nA, B = [Point(x, 0) for x in [-radius, radius]]\nline(A, B, action = :stroke)\ncircle(O, radius, action = :stroke)\nlabel(\"A\", :NW, A)\nlabel(\"O\", :N, O)\nlabel(\"B\", :NE, B)\ncircle.([A, O, B], 2, action = :fill)\ncircle.([A, B], 2radius, action = :stroke)\nfinish()","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"(Image: point example)","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"While we could have drawn all the circles as usual, we've taken the opportunity to introduce a powerful Julia feature called broadcasting. The dot (.) just after the function name in the last two circle function calls tells Julia to apply the function to all the arguments. We supplied an array of three points, and filled circles were placed at each one. Then we supplied an array of two points and stroked circles were placed there. Notice that we didn't have to supply an array of radius values or an array of actions — in each case Julia did the necessary broadcasting (from scalar to vector) for us.","category":"page"},{"location":"tutorial/basictutorial/#Intersect-this","page":"Geometry tutorial","title":"Intersect this","text":"","category":"section"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"We're now ready to tackle the job of finding the coordinates of the two points where two circles intersect. There's a Luxor function called intersectionlinecircle that finds the point or points where a line intersects a circle. So we can find the two points where one of the circles crosses an imaginary vertical line drawn through O. Because of the symmetry, we'll only have to do circle A.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"@png begin\n    # as before\n    radius=80\n    setdash(\"dot\")\n    sethue(\"gray30\")\n    A, B = [Point(x, 0) for x in [-radius, radius]]\n    line(A, B, action = :stroke)\n    circle(O, radius, action = :stroke) # use letter O for Point(0, 0)\n\n    label(\"A\", :NW, A)\n    label(\"O\", :N,  O)\n    label(\"B\", :NE, B)\n\n    circle.([A, O, B], 2, action = :fill)\n    circle.([A, B], 2radius, action = :stroke)","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"The intersectionlinecircle takes four arguments: two points to define the line and a point/radius pair to define the circle. It returns the number of intersections (probably 0, 1, or 2), followed by the two points.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"The line is specified with two points with an x value of 0 and y values of ± twice the radius, written in Julia's math-friendly style. The circle is centered at A and has a radius of AB (which is 2radius). Assuming that there are two intersections, we feed these to circle and label for drawing and labeling using our new broadcasting superpowers.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"# >>>>\n    nints, C, D =\n        intersectionlinecircle(Point(0, -2radius), Point(0, 2radius), A, 2radius)\n\n    if nints == 2\n        circle.([C, D], 2, action = :fill)\n        label.([\"D\", \"C\"], :N, [D, C])\n    end\n\nend","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"using Luxor\nDrawing(725, 400, \"../assets/figures/tutorial-egg-3.png\")\nbackground(\"white\")\norigin()\nradius=80\nsetdash(\"dot\")\nsethue(\"gray30\")\n\nA, B = [Point(x, 0) for x in [-radius, radius]]\nline(A, B, action = :stroke)\ncircle(O, radius, action = :stroke)\nlabel(\"A\", :NW, A)\nlabel(\"O\", :N, O)\nlabel(\"B\", :NE, B)\ncircle.([A, O, B], 2, action = :fill)\ncircle.([A, B], 2radius, action = :stroke)\n\nnints, C, D = intersectionlinecircle(Point(0, -2radius), Point(0, 2radius), A, 2radius)\nif nints == 2\n    circle.([C, D], 2, action = :fill)\n    label.([\"D\", \"C\"], :N, [D, C])\nend\n\nfinish()","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"(Image: point example)","category":"page"},{"location":"tutorial/basictutorial/#The-upper-circle","page":"Geometry tutorial","title":"The upper circle","text":"","category":"section"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"Now for the trickiest part of this construction: a small circle whose center point sits on top of the inner circle and that meets the two larger circles near the point D.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"Finding this new center point C1 is easy enough, because we can again use intersectionlinecircle to find the point where the central circle crosses a line from O to D.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"Add some more lines to your code:","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"@png begin\n\n# >>>>\n\n    nints, C1, C2 = intersectionlinecircle(O, D, O, radius)\n    if nints == 2\n        circle(C1, 3, action = :fill)\n        label(\"C1\", :N, C1)\n    end\n\nend","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"using Luxor\nDrawing(725, 400, \"../assets/figures/tutorial-egg-4.png\")\nbackground(\"white\")\norigin()\nradius=80\nsetdash(\"dot\")\nsethue(\"gray30\")\n\nA, B = [Point(x, 0) for x in [-radius, radius]]\nline(A, B, action = :stroke)\ncircle(O, radius, action = :stroke)\nlabel(\"A\", :NW, A)\nlabel(\"O\", :N, O)\nlabel(\"B\", :NE, B)\ncircle.([A, O, B], 2, action = :fill)\ncircle.([A, B], 2radius, action = :stroke)\n\nnints, C, D = intersectionlinecircle(Point(0, -2radius), Point(0, 2radius), A, 2radius)\nif nints == 2\n    circle.([C, D], 2, action = :fill)\n    label.([\"D\", \"C\"], :N, [D, C])\nend\n\nnints, C1, C2 = intersectionlinecircle(O, D, O, radius)\nif nints == 2\n    circle(C1, 3, action = :fill)\n    label(\"C1\", :N, C1)\nend\nfinish()","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"(Image: point example)","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"The two other points that define this circle lie on the intersections of the large circles with imaginary lines through points A and B passing through the center point C1. We're looking for the lines A-C1-ip, where ip is somewhere on the circle between D and B, and B-C1-ip, where ip is somewhere between A and D.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"To find (and draw) these points is straightforward. We'll mark these as intermediate for now, because there are in fact four intersection points but we want just the two nearest the top:","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"# >>>>\n\n    nints, I3, I4 = intersectionlinecircle(A, C1, A, 2radius)\n    nints, I1, I2 = intersectionlinecircle(B, C1, B, 2radius)\n\n    circle.([I1, I2, I3, I4], 2, action = :fill)","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"So we can use the distance function to find the distance between two points, and it's simple enough to compare the values and choose the shortest.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"\n# >>>>\n\n    if distance(C1, I1) < distance(C1, I2)\n       ip1 = I1\n    else\n       ip1 = I2\n    end\n    if distance(C1, I3) < distance(C1, I4)\n       ip2 = I3\n    else\n       ip2 = I4\n    end\n\n    label(\"ip1\", :N, ip1)\n    label(\"ip2\", :N, ip2)\n    circle(C1, distance(C1, ip1), action = :stroke)\n\nend","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"using Luxor\nDrawing(725, 400, \"../assets/figures/tutorial-egg-5.png\")\nbackground(\"white\")\norigin()\nradius=80\nsetdash(\"dot\")\nsethue(\"gray30\")\n\nA, B = [Point(x, 0) for x in [-radius, radius]]\nline(A, B, action = :stroke)\ncircle(O, radius, action = :stroke)\nlabel(\"A\", :NW, A)\nlabel(\"O\", :N, O)\nlabel(\"B\", :NE, B)\ncircle.([A, O, B], 2, action = :fill)\ncircle.([A, B], 2radius, action = :stroke)\n\nnints, C, D = intersectionlinecircle(Point(0, -2radius), Point(0, 2radius), A, 2radius)\nif nints == 2\n    circle.([C, D], 2, action = :fill)\n    label.([\"D\", \"C\"], :N, [D, C])\nend\n\nnints, C1, C2 = intersectionlinecircle(O, D, O, radius)\nif nints == 2\n    circle(C1, 3, action = :fill)\n    label(\"C1\", :N, C1)\nend\n\n# finding two more points on the circumference\n\nnints, I3, I4 = intersectionlinecircle(A, C1, A, 2radius)\nnints, I1, I2 = intersectionlinecircle(B, C1, B, 2radius)\n\ncircle.([I1, I2, I3, I4], 2, action = :fill)\n\nif distance(C1, I1) < distance(C1, I2)\n    ip1 = I1\nelse\n   ip1 = I2\nend\nif distance(C1, I3) < distance(C1, I4)\n   ip2    = I3\nelse\n   ip2 = I4\nend\n\nlabel(\"ip1\", :N, ip1)\nlabel(\"ip2\", :N, ip2)\ncircle(C1, distance(C1, ip1), action = :stroke)\n\nfinish()","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"(Image: point example)","category":"page"},{"location":"tutorial/basictutorial/#Eggs-at-the-ready","page":"Geometry tutorial","title":"Eggs at the ready","text":"","category":"section"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"We now know all the points on the egg's perimeter, and the centers of the circular arcs. To draw the outline, we'll use the arc2r function four times. This function takes: a center point and two points that together define a circular arc, plus an action.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"The shape consists of four curves, so we'll use the :path action. Instead of immediately drawing the shape, like the :fill and :stroke actions do, this action adds a section to the current path.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"\n    label(\"ip1\", :N, ip1)\n    label(\"ip2\", :N, ip2)\n    circle(C1, distance(C1, ip1), action = :stroke)\n\n# >>>>\n\n    setline(5)\n    setdash(\"solid\")\n\n    arc2r(B,    A,  ip1, :path) # centered at B, from A to ip1\n    arc2r(C1, ip1,  ip2, :path)\n    arc2r(A,  ip2,    B, :path)\n    arc2r(O,    B,    A, :path)","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"Finally, once we've added all four sections to the path we can stroke and fill it. If you want to use separate styles for the stroke and fill, you can use a preserve version of the first action. This applies the action but keeps the path available for more actions.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"    strokepreserve()\n    setopacity(0.8)\n    sethue(\"ivory\")\n    fillpath()\nend","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"using Luxor\nDrawing(725, 400, \"../assets/figures/tutorial-egg-6.png\")\nbackground(\"white\")\norigin()\nradius=80\nsetdash(\"dot\")\nsethue(\"gray30\")\n\nA, B = [Point(x, 0) for x in [-radius, radius]]\nline(A, B, action = :stroke)\ncircle(O, radius, action = :stroke)\nlabel(\"A\", :NW, A)\nlabel(\"O\", :N, O)\nlabel(\"B\", :NE, B)\ncircle.([A, O, B], 2, action = :fill)\ncircle.([A, B], 2radius, action = :stroke)\n\nnints, C, D =\n    intersectionlinecircle(Point(0, -2radius), Point(0, 2radius), A, 2radius)\nif nints == 2\n    circle.([C, D], 2, action = :fill)\n    label.([\"D\", \"C\"], :N, [D, C])\nend\n\nnints, C1, C2 = intersectionlinecircle(O, D, O, radius)\nif nints == 2\n    circle(C1, 3, action = :fill)\n    label(\"C1\", :N, C1)\nend\n\n# finding two more points on the circumference\n\nnints, I3, I4 = intersectionlinecircle(A, C1, A, 2radius)\nnints, I1, I2 = intersectionlinecircle(B, C1, B, 2radius)\n\ncircle.([I1, I2, I3, I4], 2, action = :fill)\n\nif distance(C1, I1) < distance(C1, I2)\n    ip1 = I1\nelse\n   ip1 = I2\nend\nif distance(C1, I3) < distance(C1, I4)\n   ip2    = I3\nelse\n   ip2 = I4\nend\n\nlabel(\"ip1\", :N, ip1)\nlabel(\"ip2\", :N, ip2)\ncircle(C1, distance(C1, ip1), action = :stroke)\n\nsetline(5)\nsetdash(\"solid\")\n\narc2r(B, A, ip1, :path)\narc2r(C1, ip1, ip2, :path)\narc2r(A, ip2, B, :path)\narc2r(O, B, A, :path)\nstrokepreserve()\nsetopacity(0.8)\nsethue(\"ivory\")\nfillpath()\nfinish()","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"(Image: point example)","category":"page"},{"location":"tutorial/basictutorial/#Egg-stroke","page":"Geometry tutorial","title":"Egg stroke","text":"","category":"section"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"To be more generally useful, the above code can be boiled into a single function.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"function egg(radius, action=:none)\n    A, B = [Point(x, 0) for x in [-radius, radius]]\n    nints, C, D =\n        intersectionlinecircle(Point(0, -2radius), Point(0, 2radius), A, 2radius)\n\n    flag, C1 = intersectionlinecircle(C, D, O, radius)\n    nints, I3, I4 = intersectionlinecircle(A, C1, A, 2radius)\n    nints, I1, I2 = intersectionlinecircle(B, C1, B, 2radius)\n\n    if distance(C1, I1) < distance(C1, I2)\n        ip1 = I1\n    else\n        ip1 = I2\n    end\n    if distance(C1, I3) < distance(C1, I4)\n        ip2 = I3\n    else\n        ip2 = I4\n    end\n\n    newpath()\n    arc2r(B, A, ip1, :path)\n    arc2r(C1, ip1, ip2, :path)\n    arc2r(A, ip2, B, :path)\n    arc2r(O, B, A, :path)\n    closepath()\n\n    do_action(action)\nend","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"This keeps all the intermediate code and calculations safely hidden away, and it's now possible to draw a Euclidean egg by calling egg(100, action = :stroke), for example, where 100 is the required width (radius), and :stroke is the required action.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"(Of course, there's no error checking. This should be added if the function is to be used for any serious applications...!)","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"Notice that this function doesn't define anything about what color it is, or where it's placed. When called, the function inherits the current drawing environment: scale, rotation, position of the origin, line thickness, color, style, and so on. This lets us write code like this:","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"@png begin\n    setopacity(0.7)\n    for θ in range(0, step=π/6, length=12)\n        gsave()\n            rotate(θ)\n            translate(0, -150)\n            egg(50, :path)\n            setline(10)\n            randomhue()\n            fillpreserve()\n\n            randomhue()\n            strokepath()\n        grestore()\n    end\nend 800 800 \"eggstravaganza.png\"","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"using Luxor, Random\nRandom.seed!(42)\nDrawing(725, 500, \"../assets/figures/tutorial-egg-7.png\")\nfunction egg(radius, action=:none)\n    A, B = [Point(x, 0) for x in [-radius, radius]]\n    nints, C, D =\n        intersectionlinecircle(Point(0, -2radius), Point(0, 2radius), A, 2radius)\n\n    flag, C1 = intersectionlinecircle(C, D, O, radius)\n    nints, I3, I4 = intersectionlinecircle(A, C1, A, 2radius)\n    nints, I1, I2 = intersectionlinecircle(B, C1, B, 2radius)\n\n    if distance(C1, I1) < distance(C1, I2)\n        ip1 = I1\n    else\n        ip1 = I2\n    end\n    if distance(C1, I3) < distance(C1, I4)\n        ip2 = I3\n    else\n        ip2 = I4\n    end\n\n    newpath()\n    arc2r(B, A, ip1, :path)\n    arc2r(C1, ip1, ip2, :path)\n    arc2r(A, ip2, B, :path)\n    arc2r(O, B, A, :path)\n    closepath()\n    do_action(action)\nend\nbackground(\"white\")\norigin()\nsetopacity(0.7)\nfor θ in range(0, step=π/6, length=12)\n    gsave()\n        rotate(θ)\n        translate(0, -150)\n        egg(50, :path)\n        setline(10)\n        randomhue()\n        fillpreserve()\n\n        randomhue()\n        strokepath()\n    grestore()\nend\nfinish()","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"(Image: point example)","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"The loop runs 12 times, with theta increasing from 0 upwards in steps of π/6. But before each egg is drawn, the entire drawing environment is rotated by theta radians and then shifted along the y-axis away from the origin by -150 units (the y-axis values usually increase downwards, so, before any rotation takes place, a shift of -150 looks like an upwards shift). The randomhue function does what you expect, and the egg function is passed the :fill action and the radius.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"Notice that the four drawing instructions are encased in a gsave()/grestore() pair. Any change made to the drawing environment inside this pair is discarded after the grestore(). This allows us to make temporary changes to the scale and rotation, etc. and discard them easily once the shapes have been drawn.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"Rotations and angles are typically specified in radians. The positive x-axis (a line from the origin increasing in x) starts off heading due east from the origin, and the y-axis due south, and positive angles are clockwise (ie from the positive x-axis towards the positive y-axis). So the second egg in the previous example was drawn after the axes were rotated by π/6 radians clockwise.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"If you look closely you can tell which egg was drawn first — it's overlapped on each side by subsequent eggs.","category":"page"},{"location":"tutorial/basictutorial/#Thought-experiments","page":"Geometry tutorial","title":"Thought experiments","text":"","category":"section"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"What would happen if the translation was translate(0, 150) rather than translate(0, -150)?\nWhat would happen if the translation was translate(150, 0) rather than translate(0, -150)?\nWhat would happen if you translated each egg before you rotated the drawing environment?","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"Some useful tools for investigating the important aspects of coordinates and transformations include:","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"rulers to draw the current x and y axes\ngetrotation to get the current rotation\ngetscale to get the current scale","category":"page"},{"location":"tutorial/basictutorial/#Polyeggs","page":"Geometry tutorial","title":"Polyeggs","text":"","category":"section"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"As well as stroke and fill actions, you can use the path as a clipping region (:clip), or as the basis for more shape shifting.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"The egg function creates a path and lets you apply an action to it. It's also possible to convert the path into a polygon (an array of points), which lets you do more things with it. The following code converts the egg's path into a polygon, and then moves every other point of the polygon halfway towards the centroid.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"@png begin\n    egg(160, :path)\n    pgon = first(pathtopoly())","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"The pathtopoly function converts the current path made by egg(160, :path) into a polygon. Those smooth curves have been approximated by a series of straight line segments. The first function is used because pathtopoly returns an array of one or more polygons (paths can consist of a series of loops), and we know that we need only the single path here.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"    pc = polycentroid(pgon)\n    circle(pc, 5, action = :fill)","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"polycentroid finds the centroid of the new polygon.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"This loop steps through the points and moves every odd-numbered one halfway towards the centroid. between finds a point midway between two specified points. Finally the poly function draws the array of points.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"    for pt in 1:2:length(pgon)\n        pgon[pt] = between(pc, pgon[pt], 0.5)\n    end\n    poly(pgon, action = :stroke)\nend","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"using Luxor\nDrawing(725, 500, \"../assets/figures/tutorial-egg-8.png\")\nfunction egg(radius, action=:none)\n    A, B = [Point(x, 0) for x in [-radius, radius]]\n    nints, C, D =\n        intersectionlinecircle(Point(0, -2radius), Point(0, 2radius), A, 2radius)\n\n    flag, C1 = intersectionlinecircle(C, D, O, radius)\n    nints, I3, I4 = intersectionlinecircle(A, C1, A, 2radius)\n    nints, I1, I2 = intersectionlinecircle(B, C1, B, 2radius)\n\n    if distance(C1, I1) < distance(C1, I2)\n        ip1 = I1\n    else\n        ip1 = I2\n    end\n    if distance(C1, I3) < distance(C1, I4)\n        ip2    = I3\n    else\n        ip2 = I4\n    end\n\n    newpath()\n    arc2r(B, A, ip1, :path)\n    arc2r(C1, ip1, ip2, :path)\n    arc2r(A, ip2, B, :path)\n    arc2r(O, B, A, :path)\n    closepath()\n    do_action(action)\nend\nbackground(\"white\")\norigin()\negg(160, :path)\nsethue(\"black\")\npgon = first(pathtopoly())\npc = polycentroid(pgon)\ncircle(pc, 5, action = :fill)\n\nfor pt in 1:2:length(pgon)\n    pgon[pt] = between(pc, pgon[pt], 0.5)\nend\npoly(pgon, action = :stroke)\nfinish()","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"(Image: point example)","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"The uneven appearance of the interior points here looks to be a result of the default line join settings. Experiment with setlinejoin(\"round\") to see if this makes the geometry look tidier.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"For a final experiment with our egg function, here's Luxor's offsetpoly function struggling to draw around the spiky egg-based polygon.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"@png begin\n    egg(80, :path)\n    pgon = first(pathtopoly()) |> unique\n    pc = polycentroid(pgon)\n\n    for pt in 1:2:length(pgon)\n        pgon[pt] = between(pc, pgon[pt], 0.8)\n    end\n\n    for i in 30:-3:-8\n        randomhue()\n        op = offsetpoly(pgon, i)\n        poly(op, action = :stroke, close=true)\n    end\nend 800 800 \"spike-egg.png\"","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"using Luxor, Random\nDrawing(725, 600, \"../assets/figures/tutorial-egg-9.png\")\nfunction egg(radius, action=:none)\n    A, B = [Point(x, 0) for x in [-radius, radius]]\n    nints, C, D =\n        intersectionlinecircle(Point(0, -2radius), Point(0, 2radius), A, 2radius)\n\n    flag, C1 = intersectionlinecircle(C, D, O, radius)\n    nints, I3, I4 = intersectionlinecircle(A, C1, A, 2radius)\n    nints, I1, I2 = intersectionlinecircle(B, C1, B, 2radius)\n\n    if distance(C1, I1) < distance(C1, I2)\n        ip1 = I1\n    else\n        ip1 = I2\n    end\n    if distance(C1, I3) < distance(C1, I4)\n        ip2    = I3\n    else\n        ip2 = I4\n    end\n\n    newpath()\n    arc2r(B, A, ip1, :path)\n    arc2r(C1, ip1, ip2, :path)\n    arc2r(A, ip2, B, :path)\n    arc2r(O, B, A, :path)\n    closepath()\n    do_action(action)\nend\nbackground(\"white\")\norigin()\nRandom.seed!(42)\negg(80, :path)\npgon = first(pathtopoly()) |> unique\npc = polycentroid(pgon)\ncircle(pc, 5, action = :fill)\n\nfor pt in 1:2:length(pgon)\n    pgon[pt] = between(pc, pgon[pt], 0.8)\nend\n\nfor i in 30:-3:-8\n    randomhue()\n    op = offsetpoly(pgon, i)\n    poly(op, action = :stroke, close=true)\nend\n\nfinish()","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"(Image: point example)","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"The small changes in the regularity of the points created by the path-to-polygon conversion and the varying number of samples it made are continually amplified in successive outlinings.","category":"page"},{"location":"tutorial/basictutorial/#Clipping","page":"Geometry tutorial","title":"Clipping","text":"","category":"section"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"A useful feature of Luxor is that you can use shapes as a clipping mask. Graphics can be hidden when they stray outside the boundaries of the mask.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"In this example, the egg (assuming you're still in the same Julia session in which you've defined the egg function) isn't drawn, but is defined to act as a clipping mask. Every graphic shape that you draw now is clipped where it crosses the mask. This is specified by the :clip action which is passed to the do_action function at the end of the egg.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"Here, the graphics are provided by the ngon function, which draws regular n-sided polygons.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"using Luxor, Colors\n@svg begin\n    setopacity(0.5)\n    eg(a) = egg(150, a)\n    sethue(\"gold\")\n    eg(:fill)\n    eg(:clip)\n    gsave()\n       for i in 360:-4:1\n           sethue(Colors.HSV(i, 1.0, 0.8))\n           rotate(π/30)\n           ngon(O, i, 5, 0, action = :stroke)\n       end\n    grestore()\n    clipreset()\n    sethue(\"red\")\n    eg(:stroke)\nend","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"using Luxor, Colors\nDrawing(725, 620, \"../assets/figures/tutorial-egg-10.png\")\norigin()\nbackground(\"white\")\nfunction egg(radius, action=:none)\n    A, B = [Point(x, 0) for x in [-radius, radius]]\n    nints, C, D =\n        intersectionlinecircle(Point(0, -2radius), Point(0, 2radius), A, 2radius)\n\n    flag, C1 = intersectionlinecircle(C, D, O, radius)\n    nints, I3, I4 = intersectionlinecircle(A, C1, A, 2radius)\n    nints, I1, I2 = intersectionlinecircle(B, C1, B, 2radius)\n\n    if distance(C1, I1) < distance(C1, I2)\n        ip1 = I1\n    else\n        ip1 = I2\n    end\n    if distance(C1, I3) < distance(C1, I4)\n        ip2    = I3\n    else\n        ip2 = I4\n    end\n\n    newpath()\n    arc2r(B, A, ip1, :path)\n    arc2r(C1, ip1, ip2, :path)\n    arc2r(A, ip2, B, :path)\n    arc2r(O, B, A, :path)\n    closepath()\n    do_action(action)\nend\nsetopacity(0.5)\neg(a) = egg(150, a)\nsethue(\"gold\")\neg(:fill)\neg(:clip)\ngsave()\n   for i in 360:-4:1\n       sethue(Colors.HSV(i, 1.0, 0.8))\n       rotate(π/30)\n       ngon(O, i, 5, 0, action = :stroke)\n   end\ngrestore()\nclipreset()\nsethue(\"red\")\neg(:stroke)\nfinish()","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"(Image: clip example)","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"It's good practice to add a matching clipreset after the clipping has been completed. Unbalanced clipping can lead to unpredictable results.","category":"page"},{"location":"tutorial/basictutorial/","page":"Geometry tutorial","title":"Geometry tutorial","text":"Good luck with your explorations!","category":"page"},{"location":"explanation/luxorcairo/#Luxor-and-Cairo","page":"Luxor and Cairo","title":"Luxor and Cairo","text":"","category":"section"},{"location":"explanation/luxorcairo/","page":"Luxor and Cairo","title":"Luxor and Cairo","text":"The aim of Luxor is to provide an easy to use \"scripting-like\" interface to Cairo.jl.","category":"page"},{"location":"explanation/luxorcairo/","page":"Luxor and Cairo","title":"Luxor and Cairo","text":"note: Note\nLuxor.jl doesn't implement every function provided in Cairo.jl. Cairo.jl doesn't implement every function provided by the Cairo API.","category":"page"},{"location":"explanation/luxorcairo/","page":"Luxor and Cairo","title":"Luxor and Cairo","text":"As an example of the difference between Luxor and Cairo, compare the two scripts below. Below left is one of the original example files in the Cairo.jl repository. On the right is a fairly literal conversion into a Luxor script.","category":"page"},{"location":"explanation/luxorcairo/","page":"Luxor and Cairo","title":"Luxor and Cairo","text":"(Image: luxor and cairo)","category":"page"},{"location":"explanation/luxorcairo/","page":"Luxor and Cairo","title":"Luxor and Cairo","text":"They both produce this image:","category":"page"},{"location":"explanation/luxorcairo/","page":"Luxor and Cairo","title":"Luxor and Cairo","text":"(Image: sample arc)","category":"page"},{"location":"explanation/luxorcairo/","page":"Luxor and Cairo","title":"Luxor and Cairo","text":"For convenience, and to provide a simpler interface, Luxor introduces Points and dispenses with Contexts.","category":"page"},{"location":"explanation/luxorcairo/","page":"Luxor and Cairo","title":"Luxor and Cairo","text":"Both Cairo and Luxor use the same coordinate system (although the Luxor @- macros position the 0/0 origin at the center of the canvas). So although Cairo has to calculate the midpoint of the drawing in line 13, Luxor has to calculate the position of the top left corner in line 28.","category":"page"},{"location":"explanation/luxorcairo/","page":"Luxor and Cairo","title":"Luxor and Cairo","text":"A slighty more Luxor-idiomatic version of the code would be:","category":"page"},{"location":"explanation/luxorcairo/","page":"Luxor and Cairo","title":"Luxor and Cairo","text":"using Luxor\n\n@png begin\n    background(0.8, 0.8, 0.8)\n\n    setline(10)\n    setcolor(\"black\")\n    arc(centerpt, 100, π/4, π, :stroke)\n\n    setcolor(1, 0.2, 0.2, 0.6)\n    setline(6.0)\n\n    circle(centerpt, 10.0, :fill)\n\n    poly([polar(100, π), O, polar(100, π/4)], :stroke)\n\n    setcolor(\"black\")\n    text(Libc.strftime(time()), boxtopleft(BoundingBox()) + (0,12))\n\nend 256 256 \"/tmp/sample_arc_luxor_2.png\"","category":"page"},{"location":"explanation/luxorcairo/","page":"Luxor and Cairo","title":"Luxor and Cairo","text":"If you want to know more about how drawing in Cairo (and by extension, Luxor) works, refer to the Cairo documentation.","category":"page"},{"location":"explanation/luxorcairo/#Adding-Cairo-functions","page":"Luxor and Cairo","title":"Adding Cairo functions","text":"","category":"section"},{"location":"explanation/luxorcairo/","page":"Luxor and Cairo","title":"Luxor and Cairo","text":"If a Cairo function isn't yet supported in Cairo.jl or Luxor.jl, a temporary workround is to add a direct call to the Cairo library in your Luxor script.","category":"page"},{"location":"explanation/luxorcairo/","page":"Luxor and Cairo","title":"Luxor and Cairo","text":"For example, the Cairo function to return the extents of the current path when stroked (cairo_stroke_extents) isn't yet available in Julia's Cairo.jl, but you can add it with code like this:","category":"page"},{"location":"explanation/luxorcairo/","page":"Luxor and Cairo","title":"Luxor and Cairo","text":"using Luxor\n\nfunction stroke_extents()\n    dx1 = Cdouble[0]\n    dx2 = Cdouble[0]\n    dy1 = Cdouble[0]\n    dy2 = Cdouble[0]\n    ccall((:cairo_stroke_extents, Luxor.Cairo.libcairo),\n        Nothing, (Ptr{Nothing}, Ptr{Cdouble}, Ptr{Cdouble},\n            Ptr{Cdouble}, Ptr{Cdouble}),\n        Luxor._get_current_cr().ptr, dx1, dy1, dx2, dy2)\n\n    return BoundingBox(Point(dx1[1], dy1[1]), Point(dx2[1], dy2[1]))\nend","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"DocTestSetup = quote\n    using Luxor, Colors\n    end","category":"page"},{"location":"howto/colors-styles/#Colors-and-styles","page":"Use colors and styles","title":"Colors and styles","text":"","category":"section"},{"location":"howto/colors-styles/#Color-and-opacity","page":"Use colors and styles","title":"Color and opacity","text":"","category":"section"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"For color definitions and conversions, you can use Colors.jl.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"setcolor and sethue will apply a single color to all new graphics.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"setblend will apply a smooth transition between two or more colors to all new graphics.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"setmesh will apply a color mesh to all new graphics.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"The difference between the setcolor and sethue functions is that sethue doesn't change the current alpha opacity (transparency), so you can change the current color without changing the current alpha opacity (transparency) value.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"Named colors, such as \"gold\", or \"lavender\", can be found in Colors.color_names dictionary.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"using Luxor, Colors # hide\nDrawing(800, 800, \"../assets/figures/colors.svg\") # hide\n\norigin() # hide\nbackground(\"white\") # hide\nfontsize(8)\ncols = sort(collect(Colors.color_names))\nncols = 15\nnrows = convert(Int, ceil(length(cols) / ncols))\ntable = Table(nrows, ncols, 800/ncols, 800/nrows)\ngamma = 2.2\nfor n in 1:length(cols)\n    col = cols[n][1]\n    r, g, b = sethue(col)\n    box(table[n], table.colwidths[1], table.rowheights[1], action=:fill)\n    luminance = 0.2126 * r^gamma + 0.7152 * g^gamma + 0.0722 * b^gamma\n    (luminance > 0.5^gamma) ? sethue(\"black\") : sethue(\"white\")\n    text(string(cols[n][1]), table[n], halign=:center, valign=:middle)\nend\nfinish() # hide\n\nnothing #hide","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"(Image: line endings)","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"(To make the label stand out against the background, the luminance is calculated, then used to choose the label's color.)","category":"page"},{"location":"howto/colors-styles/#Line-styles","page":"Use colors and styles","title":"Line styles","text":"","category":"section"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"There are set- functions for controlling subsequent lines' width, end shape, join behavior, and dash pattern:","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"using Luxor # hide\nDrawing(400, 250, \"../assets/figures/line-ends.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\ntranslate(-100, -60) # hide\nfontsize(18) # hide\nfor l in 1:3\n    sethue(\"black\")\n    setline(20)\n    setlinecap([\"butt\", \"square\", \"round\"][l])\n    textcentred([\"butt\", \"square\", \"round\"][l], 80l, 80)\n    setlinejoin([\"round\", \"miter\", \"bevel\"][l])\n    textcentred([\"round\", \"miter\", \"bevel\"][l], 80l, 120)\n    poly(ngon(Point(80l, 0), 20, 3, 0, vertices=true), action=:strokepreserve, close=false)\n    sethue(\"white\")\n    setline(1)\n    strokepath()\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"(Image: line endings)","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"using Luxor # hide\nDrawing(600, 250, \"../assets/figures/dashes.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nfontsize(14) # hide\nsethue(\"black\") # hide\n\npatterns = [\"solid\", \"dotted\", \"dot\", \"dotdashed\", \"longdashed\",\n  \"shortdashed\", \"dash\", \"dashed\", \"dotdotdashed\", \"dotdotdotdashed\"]\nsetline(12)\n\ntable = Table(fill(20, length(patterns)), [50, 300])\ntext.(patterns, table[:, 1], halign=:right, valign=:middle)\n\nfor p in 1:length(patterns)\n    setdash(patterns[p])\n    pt = table[p, 2]\n    line(pt - (150, 0), pt + (150, 0), :stroke)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"(Image: dashes)","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"To define more complicated dash patterns, pass a vector to setdash.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"dashes = [50.0,  # ink\n          10.0,  # skip\n          10.0,  # ink\n          10.0   # skip\n          ]\nsetdash(dashes)","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"using Luxor # hide\nDrawing(600, 180, \"../assets/figures/moredashes.svg\") # hide\nbackground(\"white\") # hide\norigin() # hide\nfunction dashing()\n    fontsize(12) # hide\n    sethue(\"black\") # hide\n    setline(8)\n    setlinecap(\"butt\")\n    patterns = [10, 4, 50, 25, 14, 100]\n    table = Table(fill(20, length(patterns)), [40, 325])\n    for p in 1:length(patterns)\n        setdash(patterns)\n        pt = table[p, 2]\n        text(string(patterns), table[p, 1], halign=:right, valign=:middle)        \n        line(pt - (150, 0), pt + (200, 0), :stroke)\n        patterns = circshift(patterns, 1)\n        pop!(patterns)\n    end\nend\n\ndashing()\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"(Image: more dashes)","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"Notice that odd-numbered patterns flip the ink and skip values each time through.","category":"page"},{"location":"howto/colors-styles/#Gradient-blends","page":"Use colors and styles","title":"Gradient blends","text":"","category":"section"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"In Luxor, a blend is a smoothly changing color gradient.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"Use setblend to select a blend in the same way that you'd use setcolor and sethue to select a solid color.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"You can make linear or radial blends. Use blend in either case.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"After setblend(), the current blend affects all subsequent stroked and filled graphics.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"To create a simple linear blend between two colors, supply two points and two colors to blend:","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"using Luxor # hide\nDrawing(600, 200, \"../assets/figures/color-blends-basic.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\norangeblue = blend(Point(-200, 0), Point(200, 0), \"orange\", \"blue\")\nsetblend(orangeblue)\nbox(O, 400, 100, action = :fill)\nrulers()\n\ntranslate(0, -70)\nrule(O) # stroked line\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"(Image: linear blend)","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"And for a radial blend, provide two point/radius pairs and two colors:","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"using Luxor # hide\nDrawing(600, 200, \"../assets/figures/color-blends-radial.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\ngreenmagenta = blend(Point(0, 0), 5, Point(0, 0), 150, \"green\", \"magenta\")\nsetblend(greenmagenta)\nbox(O, 400, 200, action = :fill)\nrulers()\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"(Image: radial blends)","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"You can also use blend to create an empty blend. Then you use addstop to define the locations of specific colors along the blend, where 0 is the start, and 1 is the end.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"using Luxor # hide\nDrawing(600, 200, \"../assets/figures/color-blends-scratch.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\ngoldblend = blend(Point(-200, 0), Point(200, 0))\naddstop(goldblend, 0.0,  \"gold4\")\naddstop(goldblend, 0.25, \"gold1\")\naddstop(goldblend, 0.5,  \"gold3\")\naddstop(goldblend, 0.75, \"darkgoldenrod4\")\naddstop(goldblend, 1.0,  \"gold2\")\nsetblend(goldblend)\nbox(O, 400, 200, action = :fill)\nrulers()\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"(Image: blends from scratch)","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"When you define blends, the location of the x/y axes (eg the current workspace as defined by translate, etc.), is important. In the first of the two following examples, the blend is selected before the axes are moved with translate(pos). The blend 'samples' the original location of the blend's definition.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"using Luxor # hide\nDrawing(600, 200, \"../assets/figures/color-blends-translate-1.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\ngoldblend = blend(Point(0, 0), Point(200, 0))\naddstop(goldblend, 0.0,  \"gold4\")\naddstop(goldblend, 0.25, \"gold1\")\naddstop(goldblend, 0.5,  \"gold3\")\naddstop(goldblend, 0.75, \"darkgoldenrod4\")\naddstop(goldblend, 1.0,  \"gold2\")\nsetblend(goldblend)\ntiles = Tiler(600, 200, 1, 5, margin=10)\nfor (pos, n) in tiles\n    gsave()\n    setblend(goldblend)\n    translate(pos)\n    ellipse(O, tiles.tilewidth, tiles.tilewidth, action = :fill)\n    grestore()\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"(Image: blends 1)","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"By default, outside the range of the original blend's definition, the same color is used, no matter how far away from the origin you go. But in the next example, the blend is relocated to the current axes, which have just been moved to the center of the tile. The blend refers to 0/0 each time, which is at the center of shape.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"using Luxor # hide\nDrawing(600, 200, \"../assets/figures/color-blends-translate-2.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\ngoldblend = blend(Point(0, 0), Point(200, 0))\naddstop(goldblend, 0.0,  \"gold4\")\naddstop(goldblend, 0.25, \"gold1\")\naddstop(goldblend, 0.5,  \"gold3\")\naddstop(goldblend, 0.75, \"darkgoldenrod4\")\naddstop(goldblend, 1.0,  \"gold2\")\nsetblend(goldblend)\ntiles = Tiler(600, 200, 1, 5, margin=10)\nfor (pos, n) in tiles\n    gsave()\n    translate(pos)\n    setblend(goldblend)\n    ellipse(O, tiles.tilewidth, tiles.tilewidth, action = :fill)\n    grestore()\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"(Image: blends 2)","category":"page"},{"location":"howto/colors-styles/#Using-[blendadjust](@ref)","page":"Use colors and styles","title":"Using blendadjust","text":"","category":"section"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"You can use blendadjust to modify the blend so that objects scaled and positioned after the blend was defined are rendered correctly.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"using Luxor # hide\nDrawing(600, 250, \"../assets/figures/blend-adjust.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetline(20)\n\n# first line\nblendgoldmagenta = blend(Point(-100, 0), Point(100, 0), \"gold\", \"magenta\")\nsetblend(blendgoldmagenta)\nline(Point(-100, -50), Point(100, -50))\nstrokepath()\n\n# second line\nblendadjust(blendgoldmagenta, Point(50, 0), 0.5, 0.5)\nline(O, Point(100, 0))\nstrokepath()\n\n# third line\nblendadjust(blendgoldmagenta, Point(-50, 50), 0.5, 0.5)\nline(Point(-100, 50), Point(0, 50))\nstrokepath()\n\n# fourth line\ngsave()\ntranslate(0, 100)\nscale(0.5, 0.5)\nsetblend(blendgoldmagenta)\nline(Point(-100, 0), Point(100, 0))\nstrokepath()\ngrestore()\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"(Image: blends adjust)","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"The blend is defined to span 200 units, horizontally centered at 0/0. The top line is also 200 units long and centered horizontally at 0/0, so the blend is rendered exactly as you'd hope.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"The second line is only half as long, at 100 units, centered at 50/0, so blendadjust is used to relocate the blend's center to the point 50/0 and scale it by 0.5 (100/200).","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"The third line is also 100 units long, centered at -50/0, so again blendadjust is used to relocate the blend's center and scale it.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"The fourth line shows that you can translate and scale the axes instead of adjusting the blend, if you use setblend again in the new scene.","category":"page"},{"location":"howto/colors-styles/#Blend-extensions","page":"Use colors and styles","title":"Blend extensions","text":"","category":"section"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"Use setblendextend() to control what happens when the shape you're drawing occupies an area larger than the blend you're using. In this example, the four possible modes are used to draw the same 150 unit radius circle using a much smaller 30 unit radial blend that starts at orange, and passes through green, to blue. If the blend is smaller than the shape, then a mode of \"none\" won't fill the entire shape, just the area inside the boundary of the blend.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"using Luxor, Colors # hide\n\nfunction drawcircle_with_mode(extendmode)\n    setdash(\"dot\")\n    circle(O, 150, :stroke)\n    a_blend = blend(O, 0,  O, 30, \"orange\", \"midnightblue\")\n    addstop(a_blend, 0.5, \"green\")\n    setblend(a_blend)\n    setblendextend(a_blend, extendmode)    \n    circle(O, 150, action = :fill)\n    sethue(\"black\")\n    text(string(extendmode), Point(0, -tiles.tileheight/2), halign=:center)\nend\n\nd = Drawing(800, 800, :png) # hide\norigin() # hide\nbackground(\"grey40\") # hide\ntiles = Tiler(750, 750, 2, 2) # hide\nfontsize(30) # hide\n\n@layer begin\n    translate(first(tiles[1]))\n    drawcircle_with_mode(\"none\")\nend\n\n@layer begin\n    translate(first(tiles[2]))\n    drawcircle_with_mode(\"repeat\")\nend\n\n@layer begin\n    translate(first(tiles[3]))\n    drawcircle_with_mode(\"reflect\")\nend\n\n@layer begin\n    translate(first(tiles[4]))\n    drawcircle_with_mode(\"pad\")\nend\nfinish() # hide\nd # hide","category":"page"},{"location":"howto/colors-styles/#Compositing-operators","page":"Use colors and styles","title":"Compositing operators","text":"","category":"section"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"Graphics software provides ways to modify how the virtual \"ink\" is applied to previously-drawn graphic elements. In PhotoShop and other software, the compositing process is done using what are called blend modes.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"Use setmode to set the blending/compositing mode of subsequent graphics.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"The following examples place a blue circle with 0.7 opacity on top of a red circle.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"using Luxor # hide\nd = Drawing(600, 600, :png) # hide\norigin()\n# transparent, no background\nfontsize(15)\nsetline(1)\ntiles = Tiler(600, 600, 4, 5, margin=30)\nmodes = length(Luxor.blendingmodes)\nsetcolor(\"black\")\nfor (pos, n) in tiles\n    n > modes && break\n    gsave()\n    translate(pos)\n    box(O, tiles.tilewidth-10, tiles.tileheight-10, :clip)\n\n    # calculate points for circles\n    diag = (Point(-tiles.tilewidth/2, -tiles.tileheight/2),\n            Point(tiles.tilewidth/2,  tiles.tileheight/2))\n    upper = between(diag, 0.45)\n    lower = between(diag, 0.55)\n\n    # first red shape uses default blend operator\n    setcolor(0.7, 0, 0, .7)\n    circle(upper, tiles.tilewidth/4, action = :fill)\n\n    # second blue shape shows results of blend operator\n    setcolor(0, 0, 0.9, 0.7)\n    blendingmode = Luxor.blendingmodes[mod1(n, modes)]\n    setmode(blendingmode)\n    circle(lower, tiles.tilewidth/4, action = :fill)\n\n    clipreset()\n    grestore()\n\n    gsave()\n    translate(pos)\n    sethue(\"antiquewhite\")\n    txt = Luxor.blendingmodes[mod1(n, modes)]\n    pos = O + (0, tiles.tilewidth/2)\n    box(pos, textextents(txt)[3] + 5, 25, action = :fill)\n    sethue(\"black\")\n    text(txt, pos, halign=:center, valign=:middle)\n    grestore()\nend\nfinish() # hide\nd # hide","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"Notice in this example that clipping was used to restrict the area affected by the blending process.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"In Cairo, these blend modes are called operators. For a more detailed explanation, refer to the Cairo documentation.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"You can access the list of modes with the unexported symbol Luxor.blendingmodes.","category":"page"},{"location":"howto/colors-styles/#Meshes","page":"Use colors and styles","title":"Meshes","text":"","category":"section"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"A mesh provides smooth shading between three or four colors across a region defined by lines or curves.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"To create a mesh, use the mesh function and assign the resulting mesh object to a variable. To use a mesh, pass the mesh object variable to the setmesh function.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"The mesh function accepts either an array of Bézier paths or a polygon.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"This basic example obtains a polygon from the drawing area using box(BoundingBox()... and uses the four corners of the mesh and the four colors in the array to build the mesh. The paint function fills the drawing.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"using Luxor, Colors # hide\nDrawing(600, 600, \"../assets/figures/mesh-basic.png\") # hide\norigin() # hide\n\ngarishmesh = mesh(\n    box(BoundingBox(), vertices=true),\n    [\"purple\", \"green\", \"yellow\", \"red\"])\n\nsetmesh(garishmesh)\n\npaint()\n\nsetline(2)\nsethue(\"white\")\nhypotrochoid(180, 81, 130, :stroke)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"(Image: mesh 1)","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"The next example uses a Bézier path conversion of a square as the outline of the mesh. Because the box to be filled is larger than the mesh's outlines, not all the box is filled.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"using Luxor, Colors # hide\nDrawing(600, 600, \"../assets/figures/mesh1.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetcolor(\"grey50\")\ncircle.([Point(x, y) for x in -200:25:200, y in -200:25:200], 10, action = :fill)\n\nbp = makebezierpath(box(O, 300, 300, vertices=true), smoothing=.4)\nsetline(3)\nsethue(\"black\")\n\ndrawbezierpath(bp, :stroke)\nmesh1 = mesh(bp, [\n    Colors.RGBA(1, 0, 0, 1),   # bottom left, red\n    Colors.RGBA(1, 1, 1, 0.0), # top left, transparent\n    Colors.RGB(0, 0, 1),       # top right, blue\n    Colors.RGB(1, 0, 1)        # bottom right, purple\n    ])\nsetmesh(mesh1)\nbox(O, 500, 500, action = :fillpreserve)\nsethue(\"grey50\")\nstrokepath()\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"(Image: mesh 1)","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"The second example uses a polygon defined by ngon as the outline of the mesh. The mesh is drawn when the path is stroked.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"using Luxor # hide\nDrawing(600, 600, \"../assets/figures/mesh2.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\npl = ngon(O, 250, 3, π/6, vertices=true)\nmesh1 = mesh(pl, [\n    \"purple\",\n    \"green\",\n    \"yellow\"\n    ])\nsetmesh(mesh1)\nsetline(180)\npoly(pl, :strokepreserve, close=true)\nsetline(5)\nsethue(\"black\")\nstrokepath()\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"(Image: mesh 2)","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"So far these meshes have contained a single defined area - a single 'patch'. It's possible to construct a mesh that consists of more than one patch. The following example uses add_mesh_patch to build a single mesh consisting of 100 smaller patches, which are placed next to each other but don't always define the same colors at identical control points.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"using Luxor, Colors, Random # hide\n\nd = Drawing(500, 500, :png) # hide\norigin() # hide\nRandom.seed!(1) # hide\ntiles = Tiler(500, 500, 10, 10, margin=0)\n\nthe_mesh = mesh(rect(first(tiles[1]), 10, 10), [\"red\"])\n\ncol1 = RGB(rand(), rand(), rand())\ncol2 = RGB(rand(), rand(), rand())\ncol3 = RGB(rand(), rand(), rand())\ncol4 = RGB(rand(), rand(), rand())\nfor (pos, n) in tiles\n    bx = box(\n        pos - (tiles.tilewidth/2, tiles.tileheight/2),\n        pos + (tiles.tilewidth/2, tiles.tileheight/2),\n        vertices = true)\n    add_mesh_patch(the_mesh, bx,\n        Random.shuffle!([col1, col2, col3, col4]))\nend\nsetmesh(the_mesh)\npaint()\nfinish() # hide\nd # hide","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"The next example constructs a conical mesh from many triangular patches, where each patch shows a different area of the HSB color space. Any graphic drawn after setmesh(), such as the hypotrochoid, is drawn using the mesh.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"using Luxor, Colors\n\n@drawsvg begin\n    radius = 300\n    L = 300\n    mesh1 = mesh([Point(0, 0), polar(radius, 0), polar(radius, 2π/100)], [RGBA(0, 0, 0, 0)])\n    sethue(\"red\")\n    for θ in range(0, 2π, length=L)\n        t = [O, O + polar(radius, θ), O + polar(radius, θ + 2π/L)]\n        add_mesh_patch(mesh1, t,\n            [\n            HSB(rescale(θ, 0, 2π, 0, 360), 0.9, 1),\n            HSB(rescale(θ, 0, 2π, 0, 360), 0.9, 1),\n            HSB(rescale(θ, 0, 2π, 0, 360), 0.9, 1),\n            ])\n    end\n    setmesh(mesh1)\n    hypotrochoid(350, 155, 100, :stroke)\nend","category":"page"},{"location":"howto/colors-styles/#Masks","page":"Use colors and styles","title":"Masks","text":"","category":"section"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"A simple mask function lets you use a circular or rectangular shape to control graphics that are drawn over it. mask takes a position and a shape, and returns a value between 0 and 1 for that position, depending on its position relative to the shape.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"In the first example, the gray color of each tile is determined by its location relative to the center of the masking circle (O, bw/2); the value is 1.0 at the center, and 0.0 at the circumference. The value could be used to control opacity, shape, or anything else that is relevant to graphics at a particular position.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"using Luxor # hide\nDrawing(610, 610, \"../assets/figures/mask.png\") # hide\norigin() # hide\ntiles = Tiler(600, 600, 15, 15, margin=0)\nbw = boxwidth(BoundingBox())\nfor (pos, n) in tiles\n    setgray(mask(pos, O, bw/2))\n    box(pos, tiles.tilewidth, tiles.tileheight, action = :fillstroke)\nend\n\nsethue(\"white\")\ncircle(O, bw/2, :stroke)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"(Image: mask)","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"The second example uses the distance of each tile relative to the rectangle O, bw, bw to determine the gray color.","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"using Luxor # hide\nDrawing(600, 600, \"../assets/figures/mask1.png\") # hide\norigin() # hide\n\ntiles = Tiler(600, 600, 30, 30)\n\nbw = boxwidth(BoundingBox())\nbh = boxheight(BoundingBox())\nfor (pos, n) in tiles\n    mv = mask(pos, O, bw, bh, easingfunction=easeinoutcubic)\n    setgray(mv)\n    box(pos, tiles.tilewidth, tiles.tileheight, action = :fillstroke)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/colors-styles/","page":"Use colors and styles","title":"Use colors and styles","text":"(Image: mask1)","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"DocTestSetup = quote\n    using Luxor, Colors\n    end","category":"page"},{"location":"tutorial/quickstart/#Design-a-logo","page":"Design a logo","title":"Design a logo","text":"","category":"section"},{"location":"tutorial/quickstart/#Logo-beginnings","page":"Design a logo","title":"Logo beginnings","text":"","category":"section"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"The new (and currently fictitious) organization JuliaFission has just asked you to design a new logo for them. They're something to do with atoms and particles, perhaps? So we'll design a new logo for them using some basic shapes; perhaps colored circles in some kind of spiral formation would look suitably \"atomic\".","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"Let's try out some ideas.","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"using Luxor\nsvgimage = @drawsvg begin\nsetcolor(\"red\")\ncircle(Point(0, 0), 100, action = :fill)\nend 500 500","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"using Luxor\nDrawing(500, 500, \"my-drawing.svg\")\norigin()\nsetcolor(\"red\")\ncircle(Point(0, 0), 100, action = :fill)\nfinish()\npreview()","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"svgimage # hide","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"This short piece of code does the following things:","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"makes a new drawing 500 units square, and will save it in the file \"my-drawing.svg\" in SVG format.\nmoves the zero point from the top left to the center. Graphics applications usually start measuring from the top left (occasionally from the bottom left), but it's easier to work out the positions of things if you start at the center. The origin() function moves the 0/0 point to the center of the drawing.\nselects one of the 200 or so named colors (defined in Colors.jl)\ndraws a circle at x = 0, y = 0, with radius 100 units, and fills it with the current color\nfinishes the drawing and displays it on the screen","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"In case you're wondering, the units are points (as in font sizes), and there are 72 points in an inch, just over 3 per millimeter. The y-axis points down the page. If you want to be reminded of where the x and y axes are, use the rulers function.","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"The action=:fill at the end of circle uses one of a set of symbols that let you use the shape you've created in different ways. There's the :stroke action, which draws around the edges but doesn't fill the shape with color. You might also meet the :fillstroke, :fillpreserve, :strokepreserve, :clip, and :path actions.","category":"page"},{"location":"tutorial/quickstart/#Circles-in-a-spiral","page":"Design a logo","title":"Circles in a spiral","text":"","category":"section"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"We want more than just one circle. We'll define a triangular shape, and place a circle at each corner. The ngon function creates regular polygons (eg triangles, squares, pentagons, etc.), and the vertices=true keyword doesn't draw the shape, it just provides the corner points - just what we want.","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"using Luxor\nsvgimage = @drawsvg begin\n\nsetcolor(\"red\")\ncorners = ngon(Point(0, 0), 80, 3, vertices=true)\ncircle.(corners, 10, action = :fill)\n\nend 500 500","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"# using Luxor\nDrawing(500, 500, \"my-drawing.svg\")\norigin()\nsetcolor(\"red\")\ncorners = ngon(Point(0, 0), 80, 3, vertices=true)\ncircle.(corners, 10, action = :fill)\nfinish()\npreview()","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"svgimage # hide","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"Notice the \".\" after circle. This broadcasts the circle() function over the corners, thus drawing a 10-unit red-filled circle at every point.","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"The arguments to ngon are usually centerpoint, radius, and the number of sides. Try changing the third argument from 3 (triangle) to 4 (square) or 31 (traikontagon?).","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"To create a spiral of circles, we want to repeat this \"draw a circle at each vertex of a triangle\" procedure more than once. A simple loop will do: we'll rotate the drawing by i * 5° (deg2rad(5) radians) each time (so 5°, 10°, 15°, 20°, 25°, and 30°), and at the same time increase the size of the polygon by multiples of 10:","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"using Luxor\nsvgimage = @drawsvg begin\n\nsetcolor(\"red\")\nfor i in 1:6\n    rotate(i * deg2rad(5))\n    corners = ngon(Point(0, 0), 80 + 10i, 3, vertices=true)\n    circle.(corners, 10, action = :fill)\nend\n\nend 500 500","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"Drawing(500, 500, \"my-drawing.svg\")\norigin()\n\nsetcolor(\"red\")\nfor i in 1:6\n    rotate(i * deg2rad(5))\n    corners = ngon(Point(0, 0), 80 + 10i, 3, vertices=true)\n    circle.(corners, 10, action = :fill)\nend\n\nfinish()\npreview()","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"svgimage # hide","category":"page"},{"location":"tutorial/quickstart/#Just-add-color","page":"Design a logo","title":"Just add color","text":"","category":"section"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"The colors used in the Julia logo are available as constants in Luxor, so we can make two changes that cycle through them. The first new line creates the set of Julia colors; then the setcolor function then works through them. mod1 (get the nth element of an array) is the 1-based version of the mod function, essential for working with Julia and its 1-based indexing, such that mod1(4, end) gets the last value of a four element array (whereas mod(4, end) would fail, since it would return 0, and colors[0] would be an error).","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"using Luxor, Colors\nsvgimage = @drawsvg begin\n\nconst colors = (Luxor.julia_green, Luxor.julia_red,Luxor.julia_purple, Luxor.julia_blue)\n\nfor i in 1:6\n    setcolor(colors[mod1(i, end)])\n    rotate(i * deg2rad(5))\n    corners = ngon(Point(0, 0), 80 + 10i, 3, vertices=true)\n    circle.(corners, 10, action = :fill)\nend\n\nend 500 500","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"using Luxor\nusing Colors\n\nDrawing(500, 500, \"my-drawing.svg\")\norigin()\n\nconst colors = (Luxor.julia_green, Luxor.julia_red,Luxor.julia_purple, Luxor.julia_blue)\n\nfor i in 1:6\n    setcolor(colors[mod1(i, end)])\n    rotate(i * deg2rad(5))\n    corners = ngon(Point(0, 0), 80 + 10i, 3, vertices=true)\n    circle.(corners, 10, action = :fill)\nend\n\nfinish()\npreview()\n","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"svgimage # hide","category":"page"},{"location":"tutorial/quickstart/#Taking-particles-seriously","page":"Design a logo","title":"Taking particles seriously","text":"","category":"section"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"The flat circles are a bit dull, so let's write a function that draws the circles as ‘particles’. ","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"The drawcircle() function draws lots of circular disks on top of each other, but each one is drawn with a slightly smaller radius and a slightly lighter shade of the incoming color. The rescale function in Luxor provides an easy way to map or adjust values from one range to another. Here, it's used to change both the color and the size of the disks as the loop counter goes from 5 down to 1.","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"Also, let's make them get larger as they spiral outwards, by adding 4i to the radius when called by drawcircle().","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"using Luxor, Colors\n\nconst colors = (Luxor.julia_green, Luxor.julia_red,Luxor.julia_purple, Luxor.julia_blue)\n\nfunction drawcircle(pos, radius, n)\n    c = colors[mod1(n, end)]\n    for i in 5:-0.1:1\n        setcolor(rescale(i, 5, 1, 0.5, 3) .* c)\n        circle(pos + (i/2, i/2), rescale(i, 5, 1, radius, radius/6), action = :fill)\n    end\nend\n\nsvgimage = @drawsvg begin\n    for i in 1:6\n        rotate(i * deg2rad(5))\n        corners = ngon(Point(0, 0), 80 + 10i, 3, vertices=true)\n        drawcircle.(corners, 10 + 4i, i)\n    end\nend 500 500","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"function drawcircle(pos, radius, n)\n    c = colors[mod1(n, end)]\n    for i in 5:-0.1:1\n        # increase color from 0.5 to 3 as i drops from 5 to 1\n        setcolor(rescale(i, 5, 1, 0.5, 3) .* c)\n        # decrease radius from radius to radius/6\n        diskradius = rescale(i, 5, 1, radius, radius/6)\n        circle(pos + (i/2, i/2), diskradius, action = :fill)\n    end\nend\n\nDrawing(500, 500, \"my-drawing.svg\")\norigin()\n\nfor i in 1:6\n    rotate(i * deg2rad(5))\n    corners = ngon(Point(0, 0), 80 + 10i, 3, vertices=true)\n    drawcircle.(corners, 10 + 4i, i)\nend\n\nfinish()\npreview()","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"svgimage # hide","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"This is looking quite promising. But here’s the thing: in a parallel universe, you might already have made this in no time at all using Adobe Illustrator or Inkscape. But with this Luxor code, you can try all kinds of different variations with almost immediate results - you can “walk through the parameter space”, either manually or via code, and see what effects you get. You don’t have to redraw everything with different angles and radii...","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"So here's what a pentagonal theme with more circles looks like:","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"using Luxor, Colors\n\nconst colors = (Luxor.julia_green, Luxor.julia_red,Luxor.julia_purple, Luxor.julia_blue)\n\nfunction drawcircle(pos, radius, n)\n    c = colors[mod1(n, end)]\n    for i in 5:-0.1:1\n        setcolor(rescale(i, 5, 1, 0.5, 3) .* c)\n        circle(pos + (i/2, i/2), rescale(i, 5, 1, radius, radius/6), action = :fill)\n    end\nend\n\nsvgimage = @drawsvg begin\n    for i in 1:12\n        rotate(i * deg2rad(1.5))\n        corners = ngon(Point(0, 0), 10 + 12i, 5, vertices=true)\n        drawcircle.(corners, 5 + 2i, i)\n    end\nend 500 500","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"Drawing(500, 500, \"my-drawing.svg\")\norigin()\n\nfor i in 1:12\n    rotate(i * deg2rad(1.5))\n    corners = ngon(Point(0, 0), 10 + 12i, 5, vertices=true)\n    drawcircle.(corners, 5 + 2i, i)\nend\n\nfinish()\npreview()","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"svgimage # hide","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"To tidy up, it's a good idea to move the code into functions (to avoid running too much in global scope), and do a bit of housekeeping.","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"Also, a background for the icon would look good. squircle is useful for drawing shapes that occupy the space between pointy dull rectangles and space-inefficient circles.","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"The complete final script looks like this:","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"using Luxor, Colors\n\nconst colors = (Luxor.julia_green, Luxor.julia_red, Luxor.julia_purple, Luxor.julia_blue)\n\nfunction drawcircle(pos, radius, n)\n    c = colors[mod1(n, end)]\n    for i in 5:-.1:1\n        setcolor(rescale(i, 5, 1, 0.5, 3) .* c)\n        circle(pos + (i/2, i/2), rescale(i, 5, 1, radius, radius/6), action = :fill)\n    end\nend\n\nfunction main(filename)\n    @drawsvg begin\n        setcolor(0.2, 0.2, 0.3)\n        squircle(O, 240, 240, rt=0.5, action = :fill)\n        for i in 1:12\n            rotate(i * deg2rad(1.5))\n            corners = ngon(Point(0, 0), 10 + 12i, 5, vertices=true)\n            drawcircle.(corners, 5 + 2i, i)\n        end\n    end 500 500\nend\n\nsvgimage = main(\"my-drawing.svg\")","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"using Luxor, Colors\n\nconst colors = (Luxor.julia_green, Luxor.julia_red,Luxor.julia_purple, Luxor.julia_blue)\n\nfunction drawcircle(pos, radius, n)\n    c = colors[mod1(n, end)]\n    for i in 5:-.1:1\n        setcolor(rescale(i, 5, 1, 0.5, 3) .* c)\n        diskradius = rescale(i, 5, 1, radius, radius/6)\n        circle(pos + (i/2, i/2), diskradius, action = :fill)\n    end\nend\n\nfunction main(filename)\n    Drawing(500, 500, filename)\n    origin()\n    setcolor(0.2, 0.2, 0.3)\n    squircle(O, 240, 240, rt=0.5, action = :fill)\n    for i in 1:12\n        rotate(i * deg2rad(1.5))\n        corners = ngon(Point(0, 0), 10 + 12i, 5, vertices=true)\n        drawcircle.(corners, 5 + 2i, i)\n    end\n    finish()\n    preview()\nend\n\nmain(\"my-drawing.svg\")","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"svgimage # hide","category":"page"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"So, did the JuliaFission organization like their logo? Who knows? - they may still be debating how accurate the representation of an atom should be... But if not, we can always recycle some of these ideas for future projects. 😃","category":"page"},{"location":"tutorial/quickstart/#Extra-credit","page":"Design a logo","title":"Extra credit","text":"","category":"section"},{"location":"tutorial/quickstart/#.-Randomize","page":"Design a logo","title":"1. Randomize","text":"","category":"section"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"Try refactoring your code so that you can automatically run through various parameter ranges. You could create many drawings with automatically-generated  filenames...","category":"page"},{"location":"tutorial/quickstart/#.-Remember-the-random-values","page":"Design a logo","title":"2. Remember the random values","text":"","category":"section"},{"location":"tutorial/quickstart/","page":"Design a logo","title":"Design a logo","text":"Using random numbers is a great way to find new patterns and shapes; but unless you know what values were used, you can't easily reproduce them. It's frustrating to produce something really good but not know what values were used to make it. So modify the code so that the random numbers are remembered, and drawn on the screen (you can use the text(string, position) function),","category":"page"},{"location":"explanation/contributing/#How-can-you-contribute?","page":"Contributing","title":"How can you contribute?","text":"","category":"section"},{"location":"explanation/contributing/","page":"Contributing","title":"Contributing","text":"If you know any geometry you probably know more than me, so there are plenty of improvements to algorithms waiting to be made. There are some TODO comments sprinkled through the code, but plenty more opportunities for improvement.","category":"page"},{"location":"explanation/contributing/","page":"Contributing","title":"Contributing","text":"Update the code, most of which was written for Julia versions 0.2, v0.3 and 0.4 (remember when broadcasting wasn't a thing?) so there are probably many areas where the code could take more advantage of version 1.","category":"page"},{"location":"explanation/contributing/","page":"Contributing","title":"Contributing","text":"There can always be more tests, as the present tests are mainly visual, showing that something works, but there should be much more testing of things that shouldn't work - inappropriate input, overlapping polygons, coincident or collinear points, anticlockwise polygons, etc.","category":"page"},{"location":"explanation/contributing/","page":"Contributing","title":"Contributing","text":"More systematic error-handling particularly of geometry errors would be a good idea, rather than sprinkling throw(error())s around when things look wrong.","category":"page"},{"location":"howto/polygons/#Polygons-and-paths","page":"Work with polygons","title":"Polygons and paths","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"For drawing shapes, Luxor provides polygons and paths.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"A polygon is an ordered collection of Points stored in an array.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"A path is a sequence of one or more straight and curved (circular arc or Bézier curve) segments. Paths can consist of subpaths. Luxor maintains a 'current path', to which you can add lines and curves until you finish with a stroke or fill instruction.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"You can store a path in a Path type, which contains path elements.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"Luxor also provides a BezierPath type, which is an array of four-point tuples, each of which is a Bézier cubic curve section.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"create convert draw info edit\npolygons    \nngon polysmooth poly isinside simplify\nngonside polytopath prettypoly polyperimeter polysplit\nstar  polysmooth polyarea polyportion\npolycross   polycentroid polyremainder\noffsetpoly   BoundingBox polysortbyangle\nhypotrochoid   ispolyclockwise polysortbydistance\nepitrochoid   ispolyconvex polyclip\npolyrotate!   ispointonpoly polymove!\npolyfit    polyscale!\npolyhull    \n    polyreflect!\n    polysample\n    polytriangulate\n    insertvertices!\n    polymorph\npaths    \nstorepath    \ngetpath pathtopoly drawpath pathlength pathsample\ngetpathflat    \nBezier paths    \nmakebezierpath pathtobezierpaths drawbezierpath  trimbezier\npathtobezierpaths bezierpathtopoly brush  splitbezier\nBezierPath bezierpathtopath bezigon  \nBezierPathSegment    \nbeziersegmentangles    ","category":"page"},{"location":"howto/polygons/#Regular-polygons-(\"ngons\")","page":"Work with polygons","title":"Regular polygons (\"ngons\")","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"A polygon is an array of points. The points can be joined with straight lines.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"You can make regular polygons — from triangles, pentagons, hexagons, septagons, heptagons, octagons, nonagons, decagons, and on-and-on-agons — with ngon.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor, Colors # hide\nDrawing(700, 600, \"../assets/figures/n-gon.png\") # hide\n\norigin() # hide\nbackground(\"white\") # hide\ncols = distinguishable_colors(10)\nsetline(2)\nfontsize(12)\ntiles = Tiler(700, 600, 3, 3)\n\nfor (pos, n) in tiles\n    @layer begin\n        translate(pos)\n\n        p = ngon(Point(0, 0), 80, n, vertices=true)\n\n        sethue(cols[n])\n\n        poly(p, action = :fill, close=true)\n        sethue(\"black\")\n        poly(p, action = :stroke, close=true)\n\n        circle(Point(0, 0), 4, action = :fill)\n\n        label.([string(i) for i in 1:n], slope.(O, p), p, offset=5)\n    end\nend\n\nfinish() # hide\n\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"The initial orientation of the polygon defaults to 0.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: n-gons)","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"If you want to specify the side length rather than the circumradius, use ngonside.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor # hide\nDrawing(500, 600, \"../assets/figures/ngonside.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\n\nsetline(2) # hide\nfor i in 20:-1:3\n    sethue(i/20, 0.5, 0.7)\n    ngonside(Point(0, 0), 75, i, 0, action = :fill)\n    sethue(\"black\")\n    ngonside(Point(0, 0), 75, i, 0, action = :stroke)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: stars)","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"The functions return the vertices, or you can use the vertices=true option.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"ngon(Point(0, 0), 10, 5)","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":" Point(3.0901699437494745, 9.510565162951535)\n Point(-8.090169943749473, 5.877852522924733)\n Point(-8.090169943749475, -5.87785252292473)\n Point(3.0901699437494723, -9.510565162951536)\n Point(10.0, -2.4492935982947065e-15)","category":"page"},{"location":"howto/polygons/#Polygons","page":"Work with polygons","title":"Polygons","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"Use poly to draw lines connecting the points and/or just fill the area:","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor, Random # hide\nDrawing(600, 250, \"../assets/figures/simplepoly.png\") # hide\nbackground(\"white\") # hide\nRandom.seed!(42) # hide\norigin() # hide\nsethue(\"orchid4\") # hide\ntiles = Tiler(600, 250, 1, 2, margin=20)\ntile1, tile2 = collect(tiles)\n\nrandompoints = [Point(rand(-100:100), rand(-100:100)) for i in 1:10]\n\ngsave()\ntranslate(tile1[1])\npoly(randompoints, action = :stroke)\ngrestore()\n\ngsave()\ntranslate(tile2[1])\npoly(randompoints, action = :fill)\ngrestore()\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: simple poly)","category":"page"},{"location":"howto/polygons/#Holes","page":"Work with polygons","title":"Holes","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"To form a hole in a polygon, you reverse the direction of the hole compared to the outer shape. When converted to paths (which happens as part of the drawing process), the reversed polygon forms a hole when drawn.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"In this example, the first nut is made by reversing the list of points, the second by using the keyword argument when constructing the shape, and the third when drawing the polygon as a path.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor # hide\nd = Drawing(600, 300, :svg) # hide\nbackground(\"antiquewhite\") # hide\norigin() # hide\n\n# nut 1\n\ntranslate(-100, 0)\n\nnut = ngon(O, 120, 6, vertices=true)\nhole = reverse(ngon(O, 70, 6, vertices=true))\n\npoly.((nut, hole), action = :path)\nfillpath()\n\n# nut 2\n\ntranslate(100, 0)\n\nsethue(\"purple\")\nnut = ngon(O, 120, 6, vertices=true)\nhole = ngon(O, 70, 6, reversepath=true, vertices=true)\n\npoly(nut, action = :path)\npoly(hole, action = :path)\nfillpath()\n\n# nut 3\n\ntranslate(100, 0)\n\nsethue(\"orange\")\nnut = ngon(O, 120, 6, vertices=true)\nhole = ngon(O, 70, 6, vertices=true)\n\npoly(nut, action = :path)\nnewsubpath()\npoly(hole, reversepath=true, action = :path)\nfillpath()\n\nfinish() # hide\nd # hide","category":"page"},{"location":"howto/polygons/#Pretty-polygons","page":"Work with polygons","title":"Pretty polygons","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"The prettypoly function can place graphics at each vertex of a polygon. After the polygon action, the supplied vertexfunction function is evaluated at each vertex. For example, to mark each vertex of a polygon with a randomly-colored circle:","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor # hide\nDrawing(400, 250, \"../assets/figures/prettypolybasic.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsethue(\"steelblue4\") # hide\n\napoly = star(O, 70, 7, 0.6, 0, vertices=true)\nprettypoly(apoly, action=:fill, () ->\n        begin\n            randomhue()\n            circle(O, 10, action=:fill)\n        end,\n    close=true)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: prettypoly)","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"An optional keyword argument vertexlabels lets you pass a function that can number each vertex. The function can use two arguments, the current vertex number, and the total number of points in the polygon:","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor # hide\nDrawing(400, 250, \"../assets/figures/prettypolyvertex.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsethue(\"steelblue4\") # hide\n\napoly = star(O, 80, 5, 0.6, 0, vertices=true)\nprettypoly(apoly,\n    :stroke,\n    vertexlabels = (n, l) -> (text(string(n, \" of \", l), halign=:center)),\n    close=true)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: prettypoly)","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"Recursive decoration is possible:","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor, Random # hide\nDrawing(400, 260, \"../assets/figures/prettypolyrecursive.png\") # hide\nbackground(\"white\") # hide\nRandom.seed!(42) # hide\norigin() # hide\nsethue(\"magenta\") # hide\nsetopacity(0.5) # hide\n\ndecorate(pos, p, level) = begin\n    if level < 4\n        randomhue()\n        scale(0.25, 0.25)\n        prettypoly(p, action = :fill, () -> decorate(pos, p, level+1), close=true)\n    end\nend\n\napoly = star(O, 100, 7, 0.6, 0, vertices=true)\nprettypoly(apoly, action = :fill, () -> decorate(O, apoly, 1), close=true)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: prettypoly)","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"Polygons can be simplified using the Douglas-Peucker algorithm (non-recursive version), via simplify.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor # hide\nDrawing(600, 500, \"../assets/figures/simplify.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsethue(\"black\") # hide\nsetline(1) # hide\nfontsize(20) # hide\ntranslate(0, -120) # hide\nsincurve = [Point(6x, 80sin(x)) for x in -5π:π/20:5π]\nprettypoly(collect(sincurve), action = :stroke,\n    () -> begin\n            sethue(\"red\")\n            circle(O, 3, action = :fill)\n          end)\ntext(string(\"number of points: \", length(collect(sincurve))), 0, 100)\ntranslate(0, 200)\nsimplercurve = simplify(collect(sincurve), 0.5)\nprettypoly(simplercurve, action = :stroke,\n    () -> begin\n            sethue(\"red\")\n            circle(O, 3, action = :fill)\n          end)\ntext(string(\"number of points: \", length(simplercurve)), 0, 100)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: simplify)","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"The isinside function returns true if a point is inside a polygon.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor # hide\nDrawing(500, 500, \"../assets/figures/isinside.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\n\napolygon = star(O, 200, 8, 0.5, 0, vertices=true)\nfor pt in collect(first.(Table(30, 30, 15, 15)))\n    sethue(noise(pt.x/600, pt.y/600), noise(pt.x/300, pt.y/300), noise(pt.x/250, pt.y/250))\n    isinside(pt, apolygon, allowonedge=true) ? circle(pt, 8, action = :fill) : circle(pt, 3, action = :fill)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: isinside)","category":"page"},{"location":"howto/polygons/#Quickly-changing-polygons","page":"Work with polygons","title":"Quickly changing polygons","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"If you want to quickly and permanently modify a polygon, there's polymove!, polyscale!, polyreflect!, and polyrotate!.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor # hide\nDrawing(400, 350, \"../assets/figures/polychange.png\") # hide\norigin() # hide\n\nsethue(\"magenta\") # hide\nshape = star(O, 10, 5, 0.5, 0, vertices=true)\n\ncircle(O, 3, action = :stroke)\n\npolymove!(shape, O, O + (0, 50))\n\npoly(shape, action = :stroke, close=true)\n\nfor i in 1:20\n    poly(polyrotate!(shape, π/5), action = :fill, close=true)\n    polyscale!(shape, 19//18)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"The polygon is continually modified (notice the ! in the function names).","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: poly changing)","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor, Random # hide\nDrawing(400, 350, \"../assets/figures/polyreflect.png\") # hide\norigin() # hide\nRandom.seed!(34) # hide\nsetopacity(0.7) # hide\nsethue(\"grey60\") # hide\npgon = randompointarray(BoundingBox()/2 ..., 10)\npolymove!(pgon, O, Point(-80, 0))\npoly(pgon, action = :fill, close=true)\n# reflect in y axis:\npolyreflect!(pgon, Point(0, 0), Point(0, 100))\nsethue(\"blue\")\npoly(pgon, action = :fill, close=true)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: poly reflect)","category":"page"},{"location":"howto/polygons/#Other-functions","page":"Work with polygons","title":"Other functions","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"There are a number of experimental polygon functions. These won't work well for polygons that aren't simple or where the sides intersect each other, but they sometimes do a reasonable job. For example, here's polysplit:","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor, Random # hide\nDrawing(400, 150, \"../assets/figures/polysplit.png\") # hide\norigin() # hide\nsetopacity(0.7) # hide\nRandom.seed!(42) # hide\nsethue(\"black\") # hide\ns = squircle(O, 60, 60, vertices=true)\npt1 = Point(0, -120)\npt2 = Point(0, 120)\nline(pt1, pt2, action = :stroke)\npoly1, poly2 = polysplit(s, pt1, pt2)\nrandomhue()\npoly(poly1, action = :fill)\nrandomhue()\npoly(poly2, action = :fill)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: polysplit)","category":"page"},{"location":"howto/polygons/#Smoothing-polygons","page":"Work with polygons","title":"Smoothing polygons","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"Because polygons can have sharp corners, the experimental polysmooth function attempts to insert arcs at the corners and draw the result.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"The original polygon is shown in red; the smoothed polygon is shown on top:","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor, Random # hide\nDrawing(600, 250, \"../assets/figures/polysmooth.svg\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetopacity(0.5) # hide\nRandom.seed!(42) # hide\nsetline(0.7) # hide\ntiles = Tiler(600, 250, 1, 5, margin=10)\nfor (pos, n) in tiles\n    p = star(pos, tiles.tilewidth/2 - 2, 5, 0.3, 0, vertices=true)\n    sethue(\"red\")\n    poly(p, close=true, action = :stroke)\n    sethue(\"black\")\n    polysmooth(p, n * 2, action = :fill)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: polysmooth)","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"The final polygon shows that you can get unexpected results if you attempt to smooth corners by more than the possible amount. The debug=true option draws the circles if you want to find out what's going wrong, or if you want to explore the effect in more detail.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor, Random # hide\nDrawing(600, 250, \"../assets/figures/polysmooth-pathological.svg\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetopacity(0.75) # hide\nRandom.seed!(42) # hide\nsetline(1) # hide\np = star(O, 60, 5, 0.35, 0, vertices=true)\nsetdash(\"dot\")\nsethue(\"red\")\nprettypoly(p, close=true, action = :stroke)\nsetdash(\"solid\")\nsethue(\"black\")\npolysmooth(p, 40, action = :fill, debug=true)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: polysmooth)","category":"page"},{"location":"howto/polygons/#Offsetting-polygons","page":"Work with polygons","title":"Offsetting polygons","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"There are three methods for offsetpoly, a function which constructs a new polygon that's offset from an existing one.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"offsetpoly(plist, d) treats the plist of points as a polygon  with n vertices joined by n lines with offset d on both  sides.\noffsetpoly(plist, startoffset=d1, endoffset=d2) treats the plist of points as a polyline with n vertices joined by n-1 lines, where the offset varies from startoffset to endoffset.\noffsetpoly(plist, f::function) applies a function f at each vertex of the polyline to determine the width of the offset polygon at that point.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"The first method is good for making closed shapes larger or smaller. The other methods are useful for building shapes around an open linear spine.","category":"page"},{"location":"howto/polygons/#:-n-vertices-joined-by-n-lines","page":"Work with polygons","title":"1: n vertices joined by n lines","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"The offsetpoly(plist, d) method constructs a closed polygon outside or inside an existing polygon, at distance d.  The last vertex in plist as assumed to be be connected to the first.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"In the following example, the dotted red polygon is the original, the black polygons have positive offsets and surround the original, the cyan polygons have negative offsets and run inside the original. Use poly to draw the result.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor, Random # hide\nDrawing(600, 250, \"../assets/figures/polyoffset-simple.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nRandom.seed!(42) # hide\nsetline(1.5) # hide\n\np = star(O, 45, 5, 0.5, 0, vertices=true)\nsethue(\"red\")\nsetdash(\"dot\")\npoly(p, action = :stroke, close=true)\nsetdash(\"solid\")\nsethue(\"black\")\n\npoly(offsetpoly(p, 20), action = :stroke, close=true)\npoly(offsetpoly(p, 25), action = :stroke, close=true)\npoly(offsetpoly(p, 30), action = :stroke, close=true)\npoly(offsetpoly(p, 35), action = :stroke, close=true)\n\nsethue(\"darkcyan\")\n\npoly(offsetpoly(p, -10), action = :stroke, close=true)\npoly(offsetpoly(p, -15), action = :stroke, close=true)\npoly(offsetpoly(p, -20), action = :stroke, close=true)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: offset poly 2)","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"The function is intended for simple cases, and it can go wrong if pushed too far. Sometimes the offset distances can be larger than the polygon segments, and things will start to go wrong. In this example, the offset goes so far negative that the polygon overshoots the origin, becomes inverted and starts getting larger again.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: offset poly problem)","category":"page"},{"location":"howto/polygons/#n-vertices-joined-by-n-1-lines","page":"Work with polygons","title":"2 n vertices joined by n-1 lines","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"The offsetpoly(plist) method constructs a polygon around a line joining the lines in plist. At the start of the line, the polygon will be startoffset units on each side; by the end of the line, the polygon will be endoffset units on each side. The last vertex isn't joined to the first, hence n-1.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"In the following example, the original spine is drawn in orange, on top of the black polygon that's constructed to be offset 2 units on each side at the start and 30 units on each side at the end.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor # hide\nDrawing(800, 500, \"../assets/figures/polyoffset-open.png\") # hide\norigin() # hide\nbackground(\"purple\") # hide\nsetline(2) # hide\n\nspine = [Point(20 + 40x, 15sin(2x)) for x in 0:.1:4π]\n\nfor θ in range(0, 2π, step=π/12)\n    @layer begin\n        sethue(\"black\")\n        rotate(θ)\n        poly(offsetpoly(spine, startoffset=1, endoffset=30), action = :fill)\n        sethue(\"orange\")\n        poly(spine, action = :stroke)\n    end\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: offset poly open)","category":"page"},{"location":"howto/polygons/#Using-an-offset-control-function","page":"Work with polygons","title":"Using an offset-control function","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"This method accepts a keyword argument that allows you to control the way the offsets are applied, using the easing functionality built in to Luxor (see Animation helper functions).","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"By default the function is lineartween, so the offset changes linearly between the startoffset and the endoffset values. With other easing functions, this change is modulated. For example, the easeinoutquad function moves between start and end values using a quadratic motion.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor # hide\nDrawing(800, 500, \"../assets/figures/polyoffset-easing.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetline(2) # hide\nsetlinejoin(\"round\") # hide\n\nspine = between.(O - (200, 0), O + (200, 0), 0:0.025:1)\n\nsethue(\"red\")\nprettypoly(spine, action = :stroke)\n\nsethue(\"black\")\npg = offsetpoly(spine, startoffset=0, endoffset=200, easingfunction=easeinoutquad)\nprettypoly(pg, action = :stroke, close=true)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: offset poly easing)","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"But in the next example, the function f(t, b, c, d) (the Luxor standard four-argument easing function) is defined to run from 0 to 2 and back again as t goes from  0 to 1, so the initial and final offsets are 'eased' to 0, and at the middle of the polygon the offsets at that location are 'eased' to 2 × the offset value at that point.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor # hide\nDrawing(800, 200, \"../assets/figures/polyoffset-easing1.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetline(2) # hide\nsetlinejoin(\"round\") # hide\n\nspine = [Point(20x, 15sin(x)) for x in -4π:pi/24:4pi]\n\nf(t, b, c, d) = 2sin(t * π)\n\npg = offsetpoly(spine, startoffset=1, endoffset=10, easingfunction=f)\nsethue(\"black\")\npoly(pg, action = :fill)\n\nsethue(\"white\")\npoly(spine, action = :stroke)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: offset poly easing 1)","category":"page"},{"location":"howto/polygons/#:-Applying-a-function","page":"Work with polygons","title":"3: Applying a function","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"This method generates offset widths using the supplied function. The value of the supplied function f at f(0, θ) determines the start offset on each side, and f(1, θ) determines the finishing offset on each side. The width at the middle vertex will be f(0.5, θ) (on each side). θ is provided as the current slope of the polyline at that point.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"This example uses a simple sine curve in f() to vary the width of the spiral from beginning to end.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor, Colors\n\nf(x, θ) =  10 + 40sin(x * π)\n\n@drawsvg begin\n\nspine = spiral(30, 1.3, vertices=true)\nps = polysample(spine, 250, include_first=true, closed=false)\npgon = offsetpoly(ps, f)\npoly(pgon, action = :stroke)\n\nsetmesh(mesh(box(BoundingBox(pgon)),\n    [\n    RGB(Luxor.julia_red...),\n    RGB(Luxor.julia_blue...),\n    RGB(Luxor.julia_green...),\n    RGB(Luxor.julia_purple...),\n    ]))\npoly(pgon, action = :fill)\n\nend","category":"page"},{"location":"howto/polygons/#Fitting-splines","page":"Work with polygons","title":"Fitting splines","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"The experimental polyfit function constructs a B-spline that follows the points approximately.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor, Random # hide\nDrawing(600, 250, \"../assets/figures/polyfit.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nRandom.seed!(42) # hide\n\npts = [Point(x, rand(-100:100)) for x in -280:30:280]\nsetopacity(0.7)\nsethue(\"red\")\nprettypoly(pts, () -> circle(O, 5, action = :fill))\nsethue(\"darkmagenta\")\npoly(polyfit(pts, 200), action = :stroke)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: offset poly)","category":"page"},{"location":"howto/polygons/#Converting-paths-to-polygons","page":"Work with polygons","title":"Converting paths to polygons","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"You can convert the current path to an array of polygons, using pathtopoly.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"In the next example, the path consists of a number of paths, some of which are subpaths, which form the holes.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor # hide\nDrawing(800, 300, \"../assets/figures/path-to-poly.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nfontsize(60) # hide\ntranslate(-300, -50) # hide\ntextpath(\"get polygons from paths\")\nplist = pathtopoly()\nsetline(0.5) # hide\nfor (n, pgon) in enumerate(plist)\n    randomhue()\n    prettypoly(pgon, action = :stroke, close=true)\n    gsave()\n    translate(0, 100)\n    poly(polysortbyangle(pgon, polycentroid(pgon)), action = :stroke, close=true)\n    grestore()\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: path to polygon)","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"The pathtopoly function calls getpathflat to convert the current path to an array of polygons, with each curved section flattened to line segments.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"The getpath function gets the current path as an array of elements, lines, and unflattened curves.","category":"page"},{"location":"howto/polygons/#Bezigons","page":"Work with polygons","title":"Bezigons","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"A bezigon is like a polygon, but the sides can be Bézier paths instead of straight lines. Supply the corners and sides to the bezigon function.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor, Colors # hide\n@drawsvg begin # hide\nbackground(\"black\") # hide\ncorners = [Point(10, 0), Point(200, 0)]\nsides = [\n    [Point(70, -40), Point(150, -50)],\n    [Point(150, 50), Point(70, 40)],\n]\nfor i in 1:10\n    sethue(HSV(36i, .7, .7))\n    rotate(2π / 10)\n    bezigon(corners, sides, :fill)\nend\nsethue(\"white\")\ncircle.([corners..., sides[1]..., sides[2]...], 7, :fill)\nend 600 400 # hide","category":"page"},{"location":"howto/polygons/#Polygons-to-Bézier-paths-and-back-again","page":"Work with polygons","title":"Polygons to Bézier paths and back again","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"Use the makebezierpath and drawbezierpath functions to make and draw Bézier paths, and pathtobezierpaths to convert the current path to an array of Bézier paths.  ","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"A BezierPath type contains a sequence of BezierPathSegments; each curve segment is defined by four points: two end points and their control points.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"    (Point(-129.904, 75.0),        # start point\n     Point(-162.38, 18.75),        # ^ control point\n     Point(-64.9519, -150.0),      # v control point\n     Point(-2.75546e-14, -150.0)), # end point\n    (Point(-2.75546e-14, -150.0),\n     Point(64.9519, -150.0),\n     Point(162.38, 18.75),\n     Point(129.904, 75.0)),\n    (Point(129.904, 75.0),\n     Point(97.4279, 131.25),\n     Point(-97.4279, 131.25),\n     Point(-129.904, 75.0)\n     ),\n     ...","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"Bézier paths are different from ordinary paths in that they don't usually contain straight line segments. However, by setting the two control points to be the same as their matching start/end points, you create straight line sections.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"makebezierpath takes the points in a polygon and converts each line segment into one Bézier curve. drawbezierpath draws the resulting sequence.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor # hide\nDrawing(600, 320, \"../assets/figures/abezierpath.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsetline(1.5) # hide\nsetgray(0.5) # hide\npts = ngon(O, 150, 3, pi/6, vertices=true)\nbezpath = makebezierpath(pts)\npoly(pts, action = :stroke)\nfor (p1, c1, c2, p2) in bezpath[1:end-1]\n    circle.([p1, p2], 4, action = :stroke)\n    circle.([c1, c2], 2, action = :fill)\n    line(p1, c1, action = :stroke)\n    line(p2, c2, action = :stroke)\nend\nsethue(\"black\")\nsetline(3)\ndrawbezierpath(bezpath, action = :stroke, close=false)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: path to polygon)","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor, Random # hide\nDrawing(600, 320, \"../assets/figures/bezierpaths.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nRandom.seed!(3) # hide\ntiles = Tiler(600, 300, 1, 4, margin=20)\nfor (pos, n) in tiles\n    @layer begin\n        translate(pos)\n        pts = polysortbyangle(\n                randompointarray(\n                    Point(-tiles.tilewidth/2, -tiles.tilewidth/2),\n                    Point(tiles.tilewidth/2, tiles.tilewidth/2),\n                    4))\n        setopacity(0.7)\n        sethue(\"black\")\n        prettypoly(pts, action = :stroke, close=true)\n        randomhue()\n        drawbezierpath(makebezierpath(pts), action = :fill)\n    end\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: path to polygon)","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"You can convert a Bézier path to a polygon (an array of points), using the bezierpathtopoly function. This chops up the curves into a series of straight line segments. An optional steps keyword lets you specify how many line segments are used to approximate each Bézier segment.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"In this example, the original star is drawn in a dotted gray line, then converted to a Bézier path (drawn in orange), then the Bézier path is converted (with low resolution) to a polygon but offset by 20 units before being drawn (in blue).","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor, Random # hide\nDrawing(600, 600, \"../assets/figures/bezierpathtopoly.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nRandom.seed!(3) # hide\n\npgon = star(O, 250, 5, 0.6, 0, vertices=true)\n\n@layer begin\n    setgrey(0.5)\n    setdash(\"dot\")\n    poly(pgon, action = :stroke, close=true)\n    setline(5)\nend\n\nsetline(4)\n\nsethue(\"orangered\")\n\nnp = makebezierpath(pgon)    \ndrawbezierpath(np, action = :stroke)\n\nsethue(\"steelblue\")\np = bezierpathtopoly(np, steps=3)    \n\nq1 = offsetpoly(p, 20)\nprettypoly(q1, action = :stroke, close=true)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: path to polygon)","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"You can convert the current path to an array of BezierPaths using the pathtobezierpaths function.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"In the next example, the letter \"a\" is placed at the current position (set by move) and then converted to an array of Bézier paths. Each Bézier path is drawn first of all in gray, then the control points of segment are drawn (in orange) showing how they affect the curvature.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor # hide\nDrawing(600, 400, \"../assets/figures/pathtobezierpaths.png\") # hide\nbackground(\"ivory\") # hide\norigin() # hide\nst = \"a\"\nthefontsize = 500\nfontsize(thefontsize)\nsethue(\"red\")\ntex = textextents(st)\nmove(-tex[3]/2, tex[4]/2)\ntextpath(st)\nnbps = pathtobezierpaths()\nsetline(1.5)\nfor nbp in nbps\n    sethue(\"grey80\")\n    drawbezierpath(nbp, action = :stroke)\n    for p in nbp\n        sethue(\"darkorange\")\n        circle(p[2], 2.0, action = :fill)\n        circle(p[3], 2.0, action = :fill)\n        line(p[2], p[1], action = :stroke)\n        line(p[3], p[4], action = :stroke)\n        if p[1] != p[4]\n            sethue(\"black\")\n            circle(p[1], 2.0, action = :fill)\n            circle(p[4], 2.0, action = :fill)\n        end\n    end\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: path to polygon)","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"beziersegmentangles lets you define a Bézier path segment by specifying the angles the control handles make with the base line.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor # hide\nDrawing(600, 400, \"../assets/figures/beziersegmentangles.svg\") # hide\nbackground(\"ivory\") # hide\norigin() # hide\n\nsetline(.5)\n\n@layer begin\n    rule.(O, (0, (π/2)))\nend\n\nP = O\nQ = O + (200, 0)\nsethue(\"black\")\n\npts = beziersegmentangles(P, Q,\n    out = deg2rad(60),\n    in  = 2π - deg2rad(45))\n\n@layer begin\n    setline(2)\n    sethue(\"purple\")\n    drawbezierpath(pts, action = :stroke)\nend\n\nsethue(\"grey50\")\nline(O, pts[2], action = :stroke)\nline(Q, pts[3], action = :stroke)\nfontsize(15)\ncircle.((P, pts[2], pts[3], Q), 5, action = :fill)\nlabel.((\"P\", \"Q\"), :ne, (P, Q))\ntext(\"60°\", P + (40, 20))\ntext(\"135°\", Q + (10, 20))\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: bezier segment angles)","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"There are some functions that can modify Bezier path segments. For example, trimbezier chops portions off each end:","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor # hide\nd = Drawing(600, 400, :svg) # hide\nbackground(\"ivory\") # hide\norigin() # hide\n\nsetline(2)\n\nbez  = BezierPathSegment(ngon(O, 150, 4, vertices=true)...)\ndrawbezierpath(bez, action = :stroke)\n\nsetopacity(0.4)\nsethue(\"red\")\nsetline(20)\ntrimbez = trimbezier(bez, 0.2, 0.8)\ndrawbezierpath(trimbez, action = :stroke)\n\nsetline(40)\nsethue(\"purple\")\ntrimbez = trimbezier(trimbez, 0.2, 0.8)\ndrawbezierpath(trimbez, action = :stroke)\n\nfinish() # hide\nd # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"When working with Bézier curves it's usual to consider the curve in terms of a parameter t going from 0.0 to 1.0.  ","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"splitbezier can split a segment into two shorter segments.","category":"page"},{"location":"howto/polygons/#Brush-strokes","page":"Work with polygons","title":"Brush strokes","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"The brush function builds Bezier paths in a quasi-random fashion, that could look like brush strokes. The optional keyword arguments allow a range of different effects.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"You can pass a function that can adjust various drawing settings before the shapes are drawn.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor, Random # hide\n\nbrushα(nbpb) = begin\n    setline(1)\n    setopacity(0.3)\n    drawbezierpath(nbpb, action = :stroke)\n    sethue(0.2, 0.3, rand(0.3:0.01:0.65))\n    return nbpb\nend\n\nfunction numberit(pos, n)\n    @layer begin\n        sethue(\"black\")\n        text(string(n), pos)\n    end    \nend\n\nDrawing(800, 700, \"../assets/figures/brush1.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nRandom.seed!(42) # hide\nt  = Tiler(800, 700, 5, 1)\nsethue(\"orange3\")\nfontsize(20)\nfor (pos, n) in t\n    start, finish = pos - (200, 0), pos + (200, 0)\n    if n == 1\n        # five brush strokes\n        brush(start, finish, 1)\n        numberit(pos, n)\n    elseif n == 2\n        # minwidth and maxwidth control the, er, width\n         brush(start, finish, 5, minwidth = -5, maxwidth = 2)\n         numberit(pos, n)\n    elseif n == 3\n        # dont have to have transparent strokes\n         brush(start, finish, 20, minwidth = .2, randomopacity = false)\n         numberit(pos, n)\n    elseif n == 4\n        # twist and adjust handles to taste\n         brush(start, finish, minwidth = -.1, maxwidth = .2,\n             twist = 2, highhandle = 2, tidystart=false)\n         numberit(pos, n)    \n    elseif n == 5   \n        # call a function to modify each stroke\n        brush(start, finish, 1, minwidth = -2.2, maxwidth = .8,\n            lowhandle = -.4, highhandle = 1.5, twist = .5,  \n            strokefunction = brushα)\n        numberit(pos, n)\n    end\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: brush 1)","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"For more information (and more than you probably wanted to know) about Luxor's Bézier paths, visit https://cormullion.github.io/pages/2018-06-20-bezier/.","category":"page"},{"location":"howto/polygons/#Polygon-information","page":"Work with polygons","title":"Polygon information","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"polyperimeter calculates the length of a polygon's perimeter.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor, Random # hide\nDrawing(600, 250, \"../assets/figures/polyperimeter.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nRandom.seed!(42) # hide\nsetline(1.5) # hide\nsethue(\"black\") # hide\nfontsize(20) # hide\np = box(O, 50, 50, vertices=true)\npoly(p, action = :stroke)\ntext(string(round(polyperimeter(p, closed=false))), O.x, O.y + 60)\n\ntranslate(200, 0)\n\npoly(p, action = :stroke, close=true)\ntext(string(round(polyperimeter(p, closed=true))), O.x, O.y + 60)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: polyperimeter)","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"To find the \"left-most\" point, ie the point with the lowest x coordinate, you can use built-in extrema() function, to return the left-most and right-most points. (This is because, when you compare points, the x coordinate is tested first.) To find the \"lowest\" points, ie the points with the lowest y value, you could find the y extrema and use it to find the index:","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"findfirst(pt -> isequal(pt.y, first(extrema(pt -> pt.y, pts))), pts)\n# 13","category":"page"},{"location":"howto/polygons/#Convex-hull","page":"Work with polygons","title":"Convex hull","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"A convex hull of a polygon is the subset of points such that, when connected with straight lines, the resulting shape contains every point of the polygon.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"Use polyhull to find the convex hull of an array of points.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor # hide\nd = Drawing(800, 500, :svg) # hide\norigin() # hide\nsetline(4)\n\njuliacircles(130) # draw in color\n\n# get points\njuliacircles(130, action=:path)\npoints  = simplify(pathtopoly()[1], 2)\n\nhull = polyhull(points)\n\nsethue(\"gold2\")\n\npoly(hull, close=true, action = :stroke)\n\nfinish() # hide\nd # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"In this example, the points forming the Julia logo (converted from a path to a polygon) are contained inside the convex hull.","category":"page"},{"location":"howto/polygons/#Polygon-selection-and-modification","page":"Work with polygons","title":"Polygon selection and modification","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"There are Luxor functions to return the first part or last part of a polygon. You can also ask for a resampling of a polygon, choosing either to increase the number of points (which places new points to the \"lines\" joining the vertices) or decrease them (which changes the shape of the polygon). It's also possible to insert vertices automatically.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"polyportion and polyremainder return part of a polygon depending on the fraction you supply. For example, polyportion(p, 0.5) returns the first half of polygon p, polyremainder(p, .75) returns the last quarter of it.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor, Random # hide\nDrawing(600, 250, \"../assets/figures/polyportion.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nRandom.seed!(42) # hide\nsetline(1.5) # hide\nsethue(\"black\") # hide\nfontsize(20) # hide\n\np = ngon(O, 100, 7, 0, vertices=true)\npoly(p, action = :stroke, close=true)\nsetopacity(0.75)\n\nsetline(20)\nsethue(\"red\")\npoly(polyportion(p, 0.25), action = :stroke)\n\nsetline(10)\nsethue(\"green\")\npoly(polyportion(p, 0.5), action = :stroke)\n\nsetline(5)\nsethue(\"blue\")\npoly(polyportion(p, 0.75), action = :stroke)\n\nsetline(1)\ncircle(polyremainder(p, 0.75)[1], 5, action = :stroke) # first point\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: polyportion)","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"You can insert vertices in the edges of a polygon with insertvertices!. For example, this code inserts a new vertex into each side of a polygon five times. The polygon ends up with 128 vertices.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor # hide\nDrawing(600, 250, \"../assets/figures/insertvertices.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetline(1) # hide\nsethue(\"black\") # hide\n\npts = box(O, 500, 200, vertices=true)\nprettypoly(pts, action = :stroke, close=true)\n\nfor i in 1:5\n    insertvertices!(pts)\n    prettypoly(pts, action = :stroke, close=true)\n    fontsize(16)\n    label(string(length(pts)), :ne, pts[1], offset=10)\n    scale(0.8)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: poly insert vertices)","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"To resample a polygon, use polysample. In this example, the same four-sided polygon is resampled at multiples of 4, with different circle radii at each multiple. This adds more points to the new copy of the original polygon.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor # hide\nDrawing(600, 250, \"../assets/figures/polysample.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetline(1) # hide\nsethue(\"black\") # hide\n\npts = ngon(O, 100, 4, vertices=true)\nfor (n, npoints) in enumerate(reverse([4, 8, 16, 32, 48]))\n    prettypoly(polysample(pts, npoints),\n        :stroke, close=true,\n        () -> begin\n                circle(O, 2n, action = :stroke)\n              end)\nend    \n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: polysampling)","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"There is a closed option, which determines whether or not the final edge (the one that would join the final vertex to the first), is included in the sampling. In the following example, the original polygon is drawn in black, then sampled as a closed polygon (in blue), then as a non-closed one (magenta).","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor # hide\nDrawing(600, 250, \"../assets/figures/polysample2.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetline(1) # hide\nsethue(\"black\") # hide\nfontsize(8) # hide\n\ntranslate(0, -50) # hide\nsetline(1) # hide\nsethue(\"black\") # hide\n\n# original polygon\n\nnumbervertices(l, n) = label(string(l), :N, O)\ndrawvertices() = ngon(O, 3, 4, 0, action = :fill)\n\npts = [Point(30x, 20sin(x)) for x in -2π:π/6:2π]\n\n# 1: drawn as defined\n\nprettypoly(pts, action = :stroke, drawvertices, vertexlabels = numbervertices)\n\ntranslate(0, 50)\n\n\n# 2: resampled as closed\n\nnpoints = 40\n\nsethue(\"cornflowerblue\")\nprettypoly(polysample(pts, npoints, closed=true), action = :stroke, drawvertices,\n    vertexlabels = numbervertices)\n\ntranslate(0, 50)\n\n# 3: resampled as open\n\nsethue(\"magenta\")\nprettypoly(polysample(pts, npoints, closed=false), action = :stroke, drawvertices,\n    vertexlabels = numbervertices)\n\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: polysampling 2)","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"note: Note\nIn Luxor, you'll meet close and closed options. close is an instruction to path-drawing functions, that says \"join the most recent point to the first point\". Whereas, closed is an indication that the polygons or paths should be treated as being closed rather than open, ie whether that last segment joining the end point to the first is used for calculations.","category":"page"},{"location":"howto/polygons/#Polygon-side-lengths","page":"Work with polygons","title":"Polygon side lengths","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"polydistances returns an array of the accumulated side lengths of a polygon.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"julia> p = ngon(O, 100, 7, 0, vertices=true);\njulia> polydistances(p)\n8-element Array{Real,1}:\n   0.0000\n  86.7767\n 173.553\n 260.33\n 347.107\n 433.884\n 520.66\n 607.437","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"It's used by polyportion and polyremainder, and you can pre-calculate and pass them to these functions via keyword arguments for performance. By default the result includes the final closing segment (closed=true).","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"These functions also make use of the nearestindex, which returns a tuple of: the index of the nearest value in an array of distances to a given value; and the excess value.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"In this example, we want to find a point halfway round the perimeter of a triangle. Use nearestindex to find the index of the nearest vertex (nidx, 2), and the surplus length, (over, 100).","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor # hide\nDrawing(650, 250, \"../assets/figures/nearestindex.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\n\nsethue(\"black\") # hide\nsetline(0.5) # hide\n\np = ngonside(O, 200, 3, vertices=true)\nprettypoly(p, action = :stroke, close=true, vertexlabels = (n, l) -> label(string(n), :NW, offset=10))\n\n# distances array\nda = polydistances(p)\n\nnidx, over = nearestindex(da, polyperimeter(p)/2)\n\nsethue(\"red\")\ncircle(p[nidx], 5, action = :stroke)\n\narrow(p[nidx],\n      between(p[nidx], p[nidx+1], over/distance(p[nidx], p[nidx+1])),\n      linewidth=2)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: nearestindex)","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"Of course, it's much easier to do polyportion(p, 0.5).","category":"page"},{"location":"howto/polygons/#Area-of-polygon","page":"Work with polygons","title":"Area of polygon","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"Use polyarea to find the area of a polygon. Of course, this only works for simple polygons; polygons that intersect themselves or have holes are not correctly processed.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"This code draws some regular polygons and calculates their area, perimeter, and shows how near the ratio of perimeter over radius approaches 2π.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor # hide\nDrawing(650, 500, \"../assets/figures/polyarea.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nfontsize(13) # hide\nfontface(\"Georgia\")\nsethue(\"black\")\nsetline(0.25)\nouterframe = Table([500], [400, 200])\ntotal = 30\nproperties = Table(fill(15, total), [20, 85, 85], outerframe[1, 2])\nradius = 55\nsethue(\"grey20\")\nfor i in 3:total\n    global radius\n    text(string(i), properties[i, 1], halign=:right)\n    p = ngon(outerframe[1], radius, i, 0, vertices=true)\n    prettypoly(p, action = :stroke, close=true, () -> (sethue(\"red\"); circle(O, 2, action = :fill)))\n    pa = polyarea(p)\n    pp = polyperimeter(p)\n    ppoverradius = pp/radius\n    text(string(Int(round(pa, digits=0))), properties[i, 2], halign=:left)\n    text(string(round(ppoverradius, digits=6)), properties[i, 3], halign=:left)\n    radius += 5\nend\n\nfontsize(10)\n[text([\"Sides\", \"Area\", \"Perimeter/Radius\"][n], pt, halign=:center)\n    for (pt, n) in Table([20], [20, 85, 85], outerframe[2] - (0, 220))]\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: poly area)","category":"page"},{"location":"howto/polygons/#Morphing-polygons","page":"Work with polygons","title":"Morphing polygons","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"\"morph\" means to make one thing turn into another. The experimental polymorph function can gradually turn one polygon into another.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"You supply two polygons and a value k between 0 and 1. For example, if the value of k is 0.5, the shape is about halfway between the two polygons.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"polymorph() always returns an array of polygons.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"By default, the polygons are assumed to be closed, suitable for filling.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"But in this example, each of the two wavy-line polygons are open rather than closed, so you can pass false values to the closed argument, and the polygons won't be treated as closed shapes.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor # hide\n@drawsvg begin # hide\nbackground(\"black\") # hide\nsetline(1.5) # hide\nrotate(π/2)\nfromshape  = [Point(90x, -230 + 50sin(3x)) for x in range(-π, π, length=250)]\ntoshape  = [Point(90x, 230 + 50sin(-3x)) for x in range(-π, π, length=250)]\nfor i in 0:0.03:1\n    sethue(1 - i, i/4 + 0.2, 1 - i/4)\n    morph = polymorph(fromshape, toshape, i,\n        easingfunction=easeinoutcubic,\n        closed=(false, false))\n    poly(first(morph), action = :stroke)\nend\nend # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"Sometimes polygons consist of two or more loops - this is how holes work. So polymorph() accepts both simple polygons and arrays of polygons, but always returns an array of polygons.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"In the next example, fromshape, the circle, is an array holding a single vector of Points (pathtopoly() returns an array of polygons), and toshape, the line, is a simple vector of points (the minimum of three points). In this case, with just simple polygons, only the first element of the result of the polymorph() function is needed.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor # hide\n@drawsvg begin # hide\nbackground(\"black\") # hide\nsetline(0.5) # hide\ncirclepath(O, 200, action = :path)\nfromshape = pathtopoly()\ntoshape = [Point(0, -250), O, Point(0, 250)] # minimum of 3\nfor i in 0:0.015:1\n    sethue(i, 1 - i, i/2 + 0.5)\n    morph = polymorph(fromshape, toshape, i, easingfunction=easeinoutsine)\n    poly(first(morph), action = :stroke, close=true)\nend\nend # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"In the next example, a square morphs into a hexagon.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor # hide\n@drawsvg begin # hide\nbackground(0.15, 0.15, 0.1) # hide\npgon1 = ngon(O, 80, 4,  vertices = true)\npgon2 = ngon(O, 270, 6, vertices = true)\nsethue(\"cyan\")\nsetline(1)\nfor i in 0:0.05:1.0\n    sethue(i, 1 - i, 0.5)\n    poly(first(polymorph(pgon1, pgon2, i)),\n        action = :stroke,\n        close = true)\nend\nend 600 600 # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"In the next example, an octagon with a square hole morphs into a square with an octagonal hole.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor # hide\n@drawsvg begin # hide\nbackground(0.15, 0.15, 0.1) # hide\n# build first polygon\nngon(O + (-350, 0), 40, 8, π, action = :path)\nnewsubpath()\nbox(O + (-350, 0), 30, 30, reversepath=true, action = :path)\npgon1 = pathtopoly()\n\n# build second polygon\nnewpath()\nbox(O + (350, 0), 60, 60, action = :path)\nnewsubpath()\nngon(O + (350, 0), 20, 8, π, reversepath=true, action = :path)\npgon2 = pathtopoly()\n\n# draw morphs\nsethue(\"cyan\")\nsetline(1)\nfor i in 0:0.1:1.0\n    sethue(i, 1 - i, 0.5)\n    poly.(polymorph(pgon1, pgon2, i),\n        action=:path,\n        close=true)\n    fillpath()\nend\nend 850 250 # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"Because both polygons have reversed subpaths (holes), the polygons should be drawn using :path and fillpath().","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"The next example animates a morph between two programming languages.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor, Colors\n\nfunction frame(scene, framenumber)\n    background(\"black\")\n\n    fontface(\"JuliaMono\")\n    fontsize(120)\n\n    textoutlines(\"\", O + (0, 0), halign=:center, valign=:middle)\n    python_logo = pathtopoly()\n\n    textoutlines(\"\", O + (0, 0), halign=:center, valign=:middle)\n    julia_logo = pathtopoly()\n\n    fontface(\"WorkSans-Black\")\n    fontsize(130)\n    textoutlines(\"Python\", O + (0, -100), halign=:center, valign=:middle, action = :path)\n    fromtext = pathtopoly()\n\n    textoutlines(\"Julia\", O + (0, 100), halign=:center, valign=:middle, action = :path)\n    totext   = pathtopoly()\n\n    newpath()\n    sethue(\"cyan\")\n\n    eased_n = scene.easingfunction(framenumber - scene.framerange.start,\n      0, 1, scene.framerange.stop - scene.framerange.start)\n\n    i = sin(eased_n * π)\n    poly.(polymorph(fromtext, totext, i, easingfunction=easingflat, samples=200),\n        action=:path,\n        close=true)\n    strokepath()\n\n    pm = polymorph(python_logo, julia_logo, i)\n    for p in pm\n        poly(p, action = :path)\n    end\n    fillpath()\nend\n\namovie = Movie(600, 400, \"p to j\")\nanimate(amovie,\n    Scene(amovie, frame, 1:200,\n        easingfunction = easeinoutsine),\n    creategif = true,\n    pathname = \"/tmp/python-julia.gif\")","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: python julia animation)","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"The \"Python\" path has 9 loops, whereas \"Julia\" has 8. The polymorph() function tries to work around this - notice how the ninth loop, \"n\", morphs down to nothing. If you don't want this to happen, set the kludge keyword to false. In this particular case, you could increase the number of loops in totext to match by using a lower-case \"j\".","category":"page"},{"location":"howto/polygons/#Other-polygon-operations","page":"Work with polygons","title":"Other polygon operations","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"These functions are still in development. Expect varying degrees of success when using them.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"polyclip() returns the region of a source polygon that lies inside a clipping polygon. In this example, each intersecting piece is created by clipping one of the \"circles\" with another (each circle is an 80-sided polygon).","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor, Colors\n@drawsvg begin\n    background(\"black\")\n\n    npoints = 80\n    D = 140\n    pts = ngon(O, 110, 3, π / 6, vertices=true)\n\n    circle1 = ngon(pts[1], D, npoints, vertices=true)\n    circle2 = ngon(pts[2], D, npoints, vertices=true)\n    circle3 = ngon(pts[3], D, npoints, vertices=true)\n    \n    sethue(\"cyan\"); poly(circle1, :fill)\n    sethue(\"magenta\"); poly(circle2, :fill)\n    sethue(\"yellow\"); poly(circle3, :fill)\n\n    sethue(\"blue\")\n    pc1 = polyclip(circle1, circle2)\n    poly(pc1, :fill, close=true)\n    \n    sethue(\"red\")\n    pc2 = polyclip(circle1, circle3)\n    poly(pc2, :fill, close=true)\n    \n    sethue(\"green\")\n    pc3 = polyclip(circle2, circle3)\n    poly(pc3, :fill, close=true)\n\n    pc4 = polyclip(pc1, pc2) # or polyclip(pc1, pc3) ... \n    \n    sethue(\"white\")\n    poly(pc4, :fill, close=true)\nend","category":"page"},{"location":"howto/polygons/#Intersections","page":"Work with polygons","title":"Intersections","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"intersectlinepoly(pt1, pt2, polygon) returns an array containing the points where a line from pt1 to pt2 crosses the perimeter of the polygon.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor, Random # hide\nDrawing(600, 550, \"../assets/figures/linepolyintersections.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nRandom.seed!(5) # hide\nsetline(0.3)\nsethue(\"thistle\")\nc = star(O, 120, 7, 0.2, vertices=true)\npoly(c, action = :fillstroke, close=true)\nfor n in 1:15\n    pt1 = Point(rand(-250:250, 2)...)\n    pt2 = Point(rand(-250:250, 2)...)\n    ips = intersectlinepoly(pt1, pt2, c)\n    if !isempty(ips)\n            sethue(\"grey20\")\n            line(pt1, pt2, action = :stroke)\n            randomhue()\n            circle.(ips, 2, action = :fill)\n    else\n        sethue(\"grey80\")\n        line(pt1, pt2, action = :stroke)\n    end\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: line/polygon intersections)","category":"page"},{"location":"howto/polygons/#Triangulation","page":"Work with polygons","title":"Triangulation","text":"","category":"section"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"Use polytriangulate to join the vertices of a polygon to form triangles. It returns an array of triangular polygons.","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"using Luxor, Random # hide\nDrawing(600, 550, \"../assets/figures/polytriangulate.png\") # hide\n\norigin() # hide\nbackground(\"white\") # hide\nfontsize(18) # hide\n\npts = ngon(O, 200, 7, vertices=true)\ntriangles = polytriangulate(pts)\n\nfor (n, tri) in enumerate(triangles)\n    sethue([Luxor.julia_purple,\n            Luxor.julia_blue,\n            Luxor.julia_red,  \n            Luxor.julia_green\n            ][mod1(n, end)])\n    poly(offsetpoly(tri, -2), action = :fill, close = true)\n    sethue(\"white\")\n    text(string(n), polycentroid(tri), halign=:center)\nend\n\nsethue(\"red\")\nsetline(3)\npoly(pts, action = :stroke, close=true)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/polygons/","page":"Work with polygons","title":"Work with polygons","text":"(Image: polygon triangulation)","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"DocTestSetup = quote\n    using Luxor, Colors\n    end","category":"page"},{"location":"howto/animation/#Animation-helper-functions","page":"Make animations","title":"Animation helper functions","text":"","category":"section"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"note: Note\nJavis.jl is the best way to make animated graphics  with Julia.","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"Luxor provides some functions to help you create animations—at least, it provides some assistance in creating lots of individual frames that can later be stitched together to form a moving animation, such as a GIF or MP4.","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"There are four steps to creating an animation.","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"1 Use Movie to create a Movie object which determines the title and dimensions.","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"2 Define some functions that draw the graphics for specific frames.","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"3 Define one or more Scenes that call these functions for specific frames.","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"4 Call the animate(movie::Movie, scenes) function, passing in the scenes. This creates all the frames and saves them in a temporary directory. ffmpeg can build an animated GIF from the frames.","category":"page"},{"location":"howto/animation/#Example","page":"Make animations","title":"Example","text":"","category":"section"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"demo = Movie(400, 400, \"test\")\n\nfunction backdrop(scene, framenumber)\n    background(\"black\")\nend\n\nfunction frame(scene, framenumber)\n    sethue(Colors.HSV(framenumber, 1, 1))\n    eased_n = scene.easingfunction(framenumber, 0, 1, scene.framerange.stop)\n    circle(polar(100, -π/2 - (eased_n * 2π)), 80, :fill)\n    text(string(\"frame $framenumber of $(scene.framerange.stop)\"),\n        Point(O.x, O.y-190),\n        halign=:center)\n    text(scene.opts,\n        boxbottomcenter(BoundingBox()),\n        halign=:center,\n        valign=:bottom)\nend\n\nanimate(demo, [\n    Scene(demo, backdrop, 0:359),\n    Scene(demo, frame, 0:359,\n        easingfunction=easeinoutcubic,\n        optarg=\"made with Julia\")\n    ],\n    creategif=true)","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"(Image: animation example)","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"In this example, the movie uses two scenes, each specifying a function to draw frames from 0 to 359. For each frame numbered 0 to 359, the graphics are drawn by both the backdrop and frame functions, in that order. A drawing is automatically created (in PNG format) and centered (origin) so you can start drawing immediately. The finish function is automatically called when all the drawing functions in the scenes have completed, and the process starts afresh for the next frame. The second scene, calling the frame function, shows how you can pass optional information to the function.","category":"page"},{"location":"howto/animation/#Making-the-animation","page":"Make animations","title":"Making the animation","text":"","category":"section"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"You can build animations automatically using ffmpeg. The creategif option for the animate function runs ffmpeg when the frames have all been generated. ","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"Inside animate, the first pass creates a GIF color palette, the second builds the file:","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"run(`ffmpeg -f image2 -i $(tempdirectory)/%10d.png -vf palettegen\n    -y $(seq.stitle)-palette.png`)\n\nrun(`ffmpeg -framerate 30 -f image2 -i $(tempdirectory)/%10d.png\n    -i $(seq.stitle)-palette.png -lavfi paletteuse -y /tmp/$(seq.stitle).gif`)","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"Many movie editing programs, such as Final Cut Pro, will also let you import sequences of still images into a movie timeline.","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"ffmpeg has literally hundreds of options, which include codec selection, framerate adjustment and color palette tweaking. If you want to use a custom ffmpeg command, you can use code such as this:","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"using Luxor, FFMPEG\n\n...\n\n# store the frames in a temp directory\ntempdirectory = \"/tmp/temp/\"\n\nanimate(movie, [\n        Scene(movie, frame, 1:50)\n    ], \n    creategif=false, # don't have to create the GIF here\n    tempdirectory=tempdirectory)\n\n# run a custom ffmpeg command\nFFMPEG.ffmpeg_exe(`-r 30 -f image2 -i $(tempdirectory)/%10d.png -c:v libx264 -r 30 -pix_fmt yuv420p -y /tmp/animation.mp4`)\n","category":"page"},{"location":"howto/animation/#Passing-information-to-the-frame()-function","page":"Make animations","title":"Passing information to the frame() function","text":"","category":"section"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"If you want to pass information to the frame function, such as an array of values, try these two approaches.","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"Either, call the enhanced frame() function with extra arguments with (s, f) -> frame(s, f, databuffer):","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"function frame(scene, framenumber, databuffer)\n    eased_n = scene.easingfunction(framenumber - scene.framerange.start,\n        0, 1, scene.framerange.stop - scene.framerange.start)\n    w = size(databuffer, 1)\n    h = size(databuffer, 2)\n    for c in 1:w, r in 1:h\n        rs = rescale(r, 1, h, 0, 2π)\n        cs = rescale(c, 1, h, 0, 2π)\n        databuffer[r, c] = HSV(360((sin(2rs) * cos(2cs)) * sin(eased_n * 2π)), 0.7, 0.7)\n    end\n    placeimage(databuffer, Point(-w / 2, -h / 2))\nend\n\nfunction main()\n    databuffer = zeros(ARGB32, 250, 250)\n    demo = Movie(250, 250, \"buffer\")\n    animate(demo, [\n            Scene(demo, (s, f) -> frame(s, f, databuffer),\n                0:100)\n        ],\n        tempdirectory=\"/tmp/tempdir\",\n        creategif=true, \n        pathname=\"/tmp/t.gif\")\nend","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"Or, use the optarg keyword argument for Scene(), and access it using scene.opts keyword.","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"function frame(scene, framenumber)\n    databuffer = scene.opts\n    eased_n = scene.easingfunction(framenumber - scene.framerange.start,\n        0, 1, scene.framerange.stop - scene.framerange.start)\n    w = size(databuffer, 1)\n    h = size(databuffer, 2)\n    for c in 1:w, r in 1:h\n        rs = rescale(r, 1, h, 0, 2π)\n        cs = rescale(c, 1, h, 0, 2π)\n        databuffer[r, c] = HSV(360((sin(2rs) * cos(2cs)) * sin(eased_n * 2π)), 0.7, 0.7)\n    end\n    placeimage(databuffer, Point(-w / 2, -h / 2))\nend\n\nfunction main()\n    databuffer = zeros(ARGB32, 250, 250)\n    demo = Movie(250, 250, \"buffer\")\n    animate(demo, [Scene(demo, frame, optarg=databuffer, 0:100)],\n        tempdirectory=\"/tmp/tempdir\",\n        creategif=true,\n        pathname=\"/tmp/t.gif\")\nend","category":"page"},{"location":"howto/animation/#Animating-paths","page":"Make animations","title":"Animating paths","text":"","category":"section"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"A useful function to help with animations is drawpath. This has a method that accepts a value between 0 and 1 that draws a portion of a Path object.","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"For example, the purple stroke is about half the length of the path.","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"using Luxor # hide\n\nd = Drawing(600, 250, :svg) # hide\nbackground(\"antiquewhite\") # hide\norigin() # hide\n\nfontsize(300)\ntextpath(\"s\", O, halign=:center, valign=:middle)\ns = storepath()\ndrawpath(s, action=:stroke)\n\nsethue(\"purple\")\nsetline(10)\nsetopacity(0.5)\npt = drawpath(s, 0.5, action=:stroke) # return final pt\n\nsetcolor(\"red\")\ncircle(pt, 5, :fill)\nfinish() # hide\nd # hide","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"It's also useful for animating text paths.","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"(Image: text animation)","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"which uses code like this:","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"...\nf =  # a value between 0 and 1\ntextpath(\"Thank you for using\", pt, halign=:center)\ntp = storepath()\ndrawpath(tp, f, :stroke)\n...","category":"page"},{"location":"howto/animation/#Easing-functions","page":"Make animations","title":"Easing functions","text":"","category":"section"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"Transitions for animations often use non-constant and non-linear motions, and these are usually provided by easing functions. Luxor defines some of the basic easing functions and they're listed in the (unexported) array Luxor.easingfunctions. Each scene can have one easing function.","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"List of easing functions\neasingflat\nlineartween\neaseinquad\neaseoutquad\neaseinoutquad\neaseincubic\neaseoutcubic\neaseinoutcubic\neaseinquart\neaseoutquart\neaseinoutquart\neaseinquint\neaseoutquint\neaseinoutquint\neaseinsine\neaseoutsine\neaseinoutsine\neaseinexpo\neaseoutexpo\neaseinoutexpo\neaseincirc\neaseoutcirc\neaseinoutcirc\neaseinoutinversequad\neaseinoutbezier","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"Most easing functions have names constructed like this:","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"ease[in|out|inout][expo|circ|quad|cubic|quart|quint]","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"and there's an easingflat linear transition.","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"using Luxor # hide\nfunction draweasingfunction(f, pos, w, h)\n    @layer begin\n        translate(pos)\n        setline(0.5)\n        sethue(\"black\")\n        box(O, w, h, :stroke)\n        sethue(\"purple\")\n        for i in 0:0.005:1.0\n            circle(Point(-w/2, h/2) + Point(w * i, -f(i, 0, h, 1)), 1, :fill)\n        end\n        sethue(\"black\")\n        text(replace(string(f), \"Luxor.\" => \"\"), Point(0, h/2 - 20), halign=:center)\n    end\nend\n\nDrawing(800, 650, \"../assets/figures/easingfunctions.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nt = Tiler(650, 650, 5, 5)\nmargin=5\nfontsize(10)\nfontface(\"JuliaMono-Regular\")\nfor (pos, n) in t\n    n > length(Luxor.easingfunctions) && continue\n    draweasingfunction(Luxor.easingfunctions[n], pos,\n        t.tilewidth-margin, t.tileheight-margin)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"In these graphs, the horizontal axis is time (between 0 and 1), and the vertical axis is the parameter value (between 0 and 1).","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"(Image: easing function summary)","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"One way to use an easing function in a frame-making function is like this:","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"function moveobject(scene, framenumber)\n    background(\"white\")\n    ...\n    easedframenumber = scene.easingfunction(framenumber, 0, 1, scene.framerange.stop)\n    ...","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"This takes the current frame number, compares it with the end frame number of the scene, then adjusts it.","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"In the next example, the purple dot has sinusoidal easing motion, the green has cubic, and the red has quintic. They all traverse the drawing extent in the same time, but have different accelerations and decelerations.","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"(Image: animation easing example)","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"fastandfurious = Movie(400, 100, \"easingtests\")\nbackdrop(scene, framenumber) =  background(\"black\")\nfunction frame1(scene, framenumber)\n    sethue(\"purple\")\n    eased_n = scene.easingfunction(framenumber, 0, 1, scene.framerange.stop)\n    circle(Point(-180 + (360 * eased_n), -20), 10, :fill)\nend\nfunction frame2(scene, framenumber)\n    sethue(\"green\")\n    eased_n = scene.easingfunction(framenumber, 0, 1, scene.framerange.stop)\n    circle(Point(-180 + (360 * eased_n), 0), 10, :fill)\nend\nfunction frame3(scene, framenumber)\n    sethue(\"red\")\n    eased_n = scene.easingfunction(framenumber, 0, 1, scene.framerange.stop)\n    circle(Point(-180 + (360 * eased_n), 20), 10, :fill)\nend\nanimate(fastandfurious, [\n    Scene(fastandfurious, backdrop, 0:200),\n    Scene(fastandfurious, frame1,   0:200, easingfunction=easeinsine),\n    Scene(fastandfurious, frame2,   0:200, easingfunction=easeinoutcubic),\n    Scene(fastandfurious, frame3,   0:200, easingfunction=easeinoutquint)\n    ],\n    creategif=true)","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"Here's the definition of one of the easing functions:","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"function easeoutquad(t, b, c, d)\n    t /= d\n    return -c * t * (t - 2) + b\nend","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"Here:","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"t is the current time (framenumber) of the transition\nb is the beginning value of the property\nc is the change between the beginning and destination value of the property\nd is the total length of the transition","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"The easeinoutbezier function accepts two additional arguments, two normalized control points of a normalized Bezier curve from Point(0, 0) to Point(1, 1). You can use these to define the shape of a custom easing transition. The Bezier curve's y coordinate determines the acceleration. [?]","category":"page"},{"location":"howto/animation/","page":"Make animations","title":"Make animations","text":"(Image: animation of bezier easing)","category":"page"},{"location":"howto/clipping/","page":"Clip graphics","title":"Clip graphics","text":"DocTestSetup = quote\n    using Luxor, Colors\n    end","category":"page"},{"location":"howto/clipping/#Clipping","page":"Clip graphics","title":"Clipping","text":"","category":"section"},{"location":"howto/clipping/","page":"Clip graphics","title":"Clip graphics","text":"There's two types of clipping in Luxor: polygon clipping and visual clipping.","category":"page"},{"location":"howto/clipping/#Polygon-clipping","page":"Clip graphics","title":"Polygon clipping","text":"","category":"section"},{"location":"howto/clipping/","page":"Clip graphics","title":"Clip graphics","text":"Use polyclip to clip one polygon by another. The clipping polygon must be convex (every interior angle is less than or equal to 180°). ","category":"page"},{"location":"howto/clipping/","page":"Clip graphics","title":"Clip graphics","text":"using Luxor # hide\n@drawsvg begin # hide\ns = hypotrochoid(160, 48, 88, vertices=true)\nsetline(0.5)\nsethue(\"grey60\")\npoly(s, :stroke)\nc = box(O, 260, 250)\npoly(c, :stroke, close=true)\nsethue(\"gold\")\nsetline(2)\npoly(polyclip(s, c), :stroke, close=true)\nend 600 400  # hide","category":"page"},{"location":"howto/clipping/#Visual-clipping","page":"Clip graphics","title":"Visual clipping","text":"","category":"section"},{"location":"howto/clipping/","page":"Clip graphics","title":"Clip graphics","text":"Use clip to turn the current path into a clipping region, masking any graphics outside the path. clippreserve keeps the current path, but also uses it as a clipping region. clipreset resets it. :clip is also an action for drawing functions like circle.","category":"page"},{"location":"howto/clipping/","page":"Clip graphics","title":"Clip graphics","text":"using Luxor # hide\nDrawing(400, 250, \"../assets/figures/simpleclip.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsetline(3) # hide\nsethue(\"grey50\")\nsetdash(\"dotted\")\ncircle(O, 100, :stroke)\ncircle(O, 100, :clip)\nsethue(\"magenta\")\nbox(O, 125, 200, :fill)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/clipping/","page":"Clip graphics","title":"Clip graphics","text":"(Image: simple clip)","category":"page"},{"location":"howto/clipping/","page":"Clip graphics","title":"Clip graphics","text":"This example uses the built-in function that draws the Julia logo. The clip action lets you use the shapes as a mask for clipping subsequent graphics, which in this example are randomly-colored circles:","category":"page"},{"location":"howto/clipping/","page":"Clip graphics","title":"Clip graphics","text":"(Image: julia logo mask)","category":"page"},{"location":"howto/clipping/","page":"Clip graphics","title":"Clip graphics","text":"function draw(x, y)\n    foregroundcolors = Colors.diverging_palette(rand(0:360), rand(0:360), 200, s = 0.99, b=0.8)\n    gsave()\n    translate(x-100, y)\n    julialogo(action=:clip)\n    for i in 1:500\n        sethue(foregroundcolors[rand(1:end)])\n        circle(rand(-50:350), rand(0:300), 15, :fill)\n    end\n    grestore()\nend\n\ncurrentwidth = 500 # pts\ncurrentheight = 500 # pts\nDrawing(currentwidth, currentheight, \"clipping-tests.pdf\")\norigin()\nbackground(\"white\")\nsetopacity(.4)\ndraw(0, 0)\nfinish()\npreview()","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"DocTestSetup = quote\n    using Luxor, Colors, Images\n    end","category":"page"},{"location":"tutorial/pixels/#Playing-with-pixels","page":"Playing with pixels","title":"Playing with pixels","text":"","category":"section"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"As well as working with PNG, SVG, and PDF drawings, Luxor lets you play directly with pixels, and combine these freely with vector graphics and text.","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"This section is a quick walkthrough of some functions you can use to control pixels. You'll need the Images.jl package as well as Luxor.jl.","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"When you create a new Luxor drawing with Drawing(), you can choose to use the contents of an existing Julia array as the drawing surface, rather than a PNG or SVG.","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"using Luxor, Colors, Images\nA = zeros(ARGB32, 400, 800)\nDrawing(A)","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"The array A should be a matrix where each element is an ARGB32 value. ARGB32 is a way of fitting four integers (using 8 bits for alpha, 8 bits for Red, 8 for Green, and 8 for Blue) into a 32-bit number between 0 and 4,294,967,296 - a 32 bit unsigned integer. The ARGB32 type is provided by the Images.jl package (or ColorTypes.jl).","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"You can set and get the values of pixels by treating the drawing's array like a standard Julia array. So we can inspect pixels like this:","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"julia> A[10, 200]  # row 10, column 200\nARGB32(0.0N0f8,0.0N0f8,0.0N0f8,0.0N0f8)","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"and set them like this:","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"julia> A[10, 200] = colorant\"red\"\nRGB{N0f8}(1.0, 0.0, 0.0)","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"or even like this:","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"julia> A[200:250, 100:250] .= colorant\"green\"\njulia> A[300:350, 50:450] .= colorant\"blue\"\njulia> [A[rand(1:(400 * 800))] = RGB(rand(), rand(), rand()) for i in 1:800]","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"Because this is an array rather than a PNG/SVG, we could either use Images.jl to display it in a notebook or code editor such as VS-Code.","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"using Luxor, Colors, Images # hide\nA = zeros(ARGB32, 400, 800) # hide\nDrawing(A) # hide\nA[200:250, 100:250] .= colorant\"green\" # hide\nA[300:350, 50:450] .= colorant\"blue\" # hide\n[A[rand(1:(400 * 800))] = RGB(rand(), rand(), rand()) for i in 1:800] # hide\nA","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"Or, to display it in Luxor, start a new drawing, and use placeimage() to position the array on the drawing:","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"using Luxor, Colors # hide\nA = zeros(ARGB32, 400, 800) \nDrawing(A) \nA[200:250, 100:250] .= colorant\"green\" \nA[300:350, 50:450] .= colorant\"blue\" \n[A[rand(1:(400 * 800))] = RGB(rand(), rand(), rand()) for i in 1:800] \nfinish()\nDrawing(800, 400, :png)\nbackground(\"brown\")\norigin()\nplaceimage(A, Point(-400, -200))\nrulers()\nfinish()\npreview()","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"Here's some code that sets the HSV color of each pixel to the value of some arbitrary maths function operating on complex numbers:","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"using Luxor, Colors, Images\nA = zeros(ARGB32, 400, 800)\nDrawing(A)\nf(z) = (z + 3)^3 / ((z + 2im) * (z - 2im)^2)\n\nfunction pixelcolor(r, c;\n        rows = 100,\n        cols = 100)\n    z = rescale(r, 1, rows, -2π, 2π) + rescale(c, 2π, cols, -2π, 2π) * im\n    n = f(z)\n    h = 360rescale(angle(n), 0, 2π)\n    s = abs(sin(π / 2 * real(f(z))))\n    v = abs(sin(2π * real(f(z))))\n    return HSV(h, s, v)\nend\nfor r in 1:size(A, 1), c in 1:size(A, 2)\n    A[r, c] = pixelcolor(r, c, rows = 400, cols = 800)\nend\nA","category":"page"},{"location":"tutorial/pixels/#Rows-and-columns,-height-and-width","page":"Playing with pixels","title":"Rows and columns, height and width","text":"","category":"section"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"A quick note about the two coordinate systems at work here.","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"Locations in arrays and images are typically specified with row and column values, or perhaps just a single index value. Because arrays are column-major in Julia, the address A[10, 200] is \"row 10, column 200 of A\".","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"Locations on plots and Luxor drawings are typically specified as Cartesian x and y coordinates. So Point(10, 200) would identify a point 10 units along the x-axis and 200 along the y-axis from the origin, In Luxor, like most computer graphics systems, the y-axis points vertically down the drawing. ","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"The origin point of an array or image is the first pixel - usually drawn at the top left. In Luxor, the origin point (0/0) of a drawing (if created by Drawing()) is also at the top left, until you move it, or use the origin() function. (The @draw macros also set the origin at the centre of the drawing, for your convenience.)","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"When you're working on a pixel array drawing, you might find it useful to define a transformation matrix that converts vector graphics coordinates from the conventional x/across/width - y/down/height to the pixel array's row/down/height, column/across/width convention, as used for array access. Here, the transform() function defines a matrix that flips the x and y coordinates, and shifts the origin to the \"center\" of the array. ","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"Now you can specify the location of text and graphics using more typical vector-graphics coordinates - the text is placed at Point(0, h/2 - 30), ie centered, 30 units above the bottom edge.","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"using Luxor, Colors\nA = zeros(ARGB32, 400, 800)\nDrawing(A)\nf(z) = (z + 3)^3 / ((z + 2im) * (z - 2im)^2)\nfunction pixelcolor(r, c;\n        rows=100,\n        cols=100)\n    z = rescale(r, 1, rows, -2π, 2π) + rescale(c, 2π, cols, -2π, 2π) * im\n    n = f(z)\n    h = 360rescale(angle(n), 0, 2π)\n    s = abs(sin(π / 2 * real(f(z)))) # * (sin(π * imag(f(z)))))\n    v = abs(sin(2π * real(f(z))))\n    return HSV(h, s, v)\nend\nfor r in 1:size(A, 1), c in 1:size(A, 2)\n    A[r, c] = pixelcolor(r, c, rows=400, cols=800)\nend\nw, h = 800, 400\ntransform([0 1 1 0 h/2 w/2])\nfontsize(18)\nsethue(\"white\")\ntext(\"f(z) = (z + 3)^3 / ((z + 2im) * (z - 2im)^2)\",\n    Point(0, h/2 - 30), halign=:center)\nA","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"A disadvantage is that BoundingBox() functions don't work, because they're not yet aware of transformation matrices.","category":"page"},{"location":"tutorial/pixels/#Array-as-image","page":"Playing with pixels","title":"Array as image","text":"","category":"section"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"An alternative way of using pixel arrays is to add them to a PNG or SVG drawing using placeimage. For example, create a new drawing, and this time add the array A to the drawing. You can use it like any other image, such as clipping it by the Julia logo:","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"# with A defined as above\nw, h = 800, 400\nDrawing(800, 400, :png)\norigin()\nplaceimage(A, O - (w / 2, h / 2), alpha=0.3)\njulialogo(centered=true, action=:clip)\nplaceimage(A, O - (w / 2, h / 2))\nclipreset()\njulialogo(centered=true, action=:path)\nsethue(\"white\")\nstrokepath()\nfinish()\npreview()","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"using Luxor, Colors\nA = zeros(ARGB32, 400, 800)\nw, h = 800, 400\nDrawing(A)\nf(z) = (z + 3)^3 / ((z + 2im) * (z - 2im)^2)\nfunction pixelcolor(r, c;\n    rows=100,\n    cols=100)\n    z = rescale(r, 1, rows, -2π, 2π) + rescale(c, 2π, cols, -2π, 2π) * im\n    n = f(z)\n    h = 360rescale(angle(n), 0, 2π)\n    s = abs(sin(π / 2 * real(f(z)))) # * (sin(π * imag(f(z)))))\n    v = abs(sin(2π * real(f(z))))\n    return HSV(h, s, v)\nend\nfor r in 1:size(A, 1), c in 1:size(A, 2)\n    A[r, c] = pixelcolor(r, c, rows=400, cols=800)\nend\ntransform([0 1 1 0 h/2 w/2])\nfontsize(18)\nsethue(\"white\")\ntext(\"f(z) = (z + 3)^3 / ((z + 2im) * (z - 2im)^2)\",\n    O + (0, h / 2 - 20), halign=:center)\nfinish()\n\nd = Drawing(800, 400, :png)\norigin()\nplaceimage(A, O - (w / 2, h / 2), alpha=0.4)\njulialogo(centered=true, action=:clip)\nplaceimage(A, O - (w / 2, h / 2))\nclipreset()\njulialogo(centered=true, action=:path)\nsethue(\"white\")\nstrokepath()\nfinish()","category":"page"},{"location":"tutorial/pixels/","page":"Playing with pixels","title":"Playing with pixels","text":"d # hide","category":"page"},{"location":"explanation/perfectpixels/#Perfect-pixels-and-anti-aliasing","page":"Perfect pixels and antialising","title":"Perfect pixels and anti-aliasing","text":"","category":"section"},{"location":"explanation/perfectpixels/#Anti-aliasing","page":"Perfect pixels and antialising","title":"Anti-aliasing","text":"","category":"section"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"The process of converting precise graphic shapes to a grid of pixels is automatically performed by Luxor when you save the drawing as a PNG file. If you make an SVG or PDF drawing, this process is carried out at a later stage, by the application you use to view or display the file.","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"It's usually better to defer this conversion as long as possible. Of course, eventually - unless you're using a pen plotter or laser cutter - your smooth outlines will have to be converted (\"rasterized\") to a grid of colored pixels for their final journey to the analogue world.","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"The conversion to PNG includes \"anti-aliasing\", which gradually changes the colors of pixels along a boundary so as to avoid the grid-like \"staircase\" effect. You can, to some extent, adjust the amount of anti-aliasing used when you make drawings in Luxor.","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"using Luxor, Colors\nfunction make_matrix(;\n        antialias=0)\n    d = Drawing(20, 20, :image)\n    setantialias(antialias)\n    origin()\n    setcolor(\"red\")\n    circle(Point(0, 0), 5, :fill)\n    mat = image_as_matrix()\n    finish()\n    return mat\nend\n\nfunction drawmatrix(A;\n        cellsize = (10, 10))\n    table = Table(size(A)..., cellsize...)\n    for i in CartesianIndices(A)\n        r, c = Tuple(i)\n        sethue(A[r, c])\n        box(table, r, c, :fill)\n        sethue(\"black\")\n        box(table, r, c, :stroke)\n    end\nend\n\nfunction draw(antialias)\n    mat = make_matrix(antialias=antialias)\n    @drawsvg begin\n        background(\"black\")\n        drawmatrix(mat, cellsize = 1 .* size(mat))\n        c = length(unique(color.(mat)))\n        sethue(\"white\")\n        fontsize(8)\n        text(\"number of colors used: $c\", boxbottomcenter(BoundingBox() * 0.9), halign=:center)\n    end 300 300\nend","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"The setantialias function lets you specify the anti-aliasing amount as an integer constant between 0 and 6 to be used for rendering subsequent paths. The Cairo documentation describes the different values as follows:","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"Value Name Description\n0 CAIRO_ANTIALIAS_DEFAULT Use the default anti-aliasing for the subsystem and target device\n1 CAIRO_ANTIALIAS_NONE Use a bilevel alpha mask\n2 CAIRO_ANTIALIAS_GRAY Perform single-color anti-aliasing (using shades of gray for black text on a white background, for example)\n3 CAIRO_ANTIALIAS_SUBPIXEL Perform anti-aliasing by taking advantage of the order of subpixel elements on devices such as LCD panels\n4 CAIRO_ANTIALIAS_FAST Hint that the backend should perform some anti-aliasing but prefer speed over quality\n5 CAIRO_ANTIALIAS_GOOD The backend should balance quality against performance\n6 CAIRO_ANTIALIAS_BEST Hint that the backend should render at the highest quality, sacrificing speed if necessary","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"To show the anti-aliasing in action, the following code generates a red circle:","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"Drawing(20, 20, :image)\nsetantialias(0)\norigin()\nsetcolor(\"red\")\ncircle(Point(0, 0), 5, :fill)\nmat = image_as_matrix()\nfinish()","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"This matrix is now redrawn larger to show the effects of anti-aliasing better. Here's the default anti-aliasing value of 0:","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"draw(0) # hide","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"and you can see that Luxor used 18 different shades of red to add some smoothness to this circle.","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"Here’s the result of the bilevel mask or “none” setting (setantialias(1)):","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"draw(1) # hide","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"Here Luxor used just two colors to draw the circle.","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"The other values produce the same effects as the default (0), apart from 4 (\"speed over quality\"):","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"draw(4) # hide","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"which uses 12 rather than 16 colors.","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"The anti-aliasing process can vary according to the OS and device you're using. The Cairo documentation stresses this more than once:","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"The value is a hint, and a particular backend may or may not support a particular value. [...] The values make no guarantee on how the backend will perform its rasterisation (if it even rasterises!) [...] The interpretation of CAIRO_ANTIALIAS_DEFAULT is left entirely up to the backend [...]","category":"page"},{"location":"explanation/perfectpixels/#Text","page":"Perfect pixels and antialising","title":"Text","text":"","category":"section"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"The anti-aliasing described above does not apply to text.","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"Text rendering is much more platform-dependent than graphics; Windows, MacOS, and Linux all have their own methods for rendering and rasterizing fonts, and currently there is no interface to the underlying font rendering APIs in Luxor.","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"Consider the following code, which makes an image of the letter \"a\" and redraws it larger:","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"using Luxor\n\nfunction make_matrix()\n    Drawing(40, 40, :image)\n    background(1, 1, 1, 1)\n    setantialias(0)\n    origin()\n    setcolor(0, 0, 0, 1)\n    fontsize(40)\n    text(\"a\", halign=:center, valign=:middle)\n    matrix = image_as_matrix()\n    finish()\n    return matrix\nend\n\nfunction draw()\n    matrix = make_matrix()\n    @png begin\n        background(0, 0, 0, 1)\n        table = Table(size(matrix)..., (15, 15))\n        for i in CartesianIndices(matrix)\n            r, c = Tuple(i)\n            setcolor(matrix[r, c])\n            box(table, r, c, :fillstroke)\n        end\n    end 400 400 \"alias-test.png\"\nend","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"The output varies depending on the computer, operating system, and rendering settings.","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"Here’s the MacOS standard rendering:","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"(Image: macos alias text)","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"Here’s Linux Gnome’s standard anti-aliasing:","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"(Image: linux gnome alias text)","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"On Windows systems, and on some Linux desktops, text can be displayed using a subpixel rendering process, which switches the red, green, and blue components of pixels on or off where they meet the edges of text in an attempt to provide a “smoother” appearance.","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"Here’s Linux KDE RGB anti-aliasing:","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"(Image: linux kde rgb alias text)","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"Windows Cleartype anti-aliasing:","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"(Image: windows cleartype alias text)","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"In addition, Windows and some Linux systems use font hinting, a process in which the outlines of text glyphs are shifted so as to align better on the rectangular grid of pixels.","category":"page"},{"location":"explanation/perfectpixels/","page":"Perfect pixels and antialising","title":"Perfect pixels and antialising","text":"If you want text to be rendered precisely (and in a specified color) it might be worth investigating Luxor’s textoutlines function, which converts text to vector-based outlines. These are then rendered with the anti-aliasing settings described above for graphics.","category":"page"},{"location":"howto/createdrawings/#Create-a-Drawing","page":"Create drawings","title":"Create a Drawing","text":"","category":"section"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"In Luxor you always work with a current drawing, so the first thing to do is to create one.","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"To create a drawing, and optionally specify the filename, type, and dimensions, use the Drawing constructor function.","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"To finish a drawing and close the file, use finish.","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"Ff the drawing doesn't appear automatically in your notebook or editing environment, you can type preview to see it.","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"(Image: jupyter)","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"If you're using VS Code, then PNG and SVG drawings should automatically appear in the Plots pane, if it's enabled. In a Pluto notebook, output appears above the cell. In a notebook environment, output appears in the next notebook cell.","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"(Image: juno)","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"note: Note\nSVGs are text-based, and can get quite big. Up to a certain size, SVGs will preview as easily and quickly as PNGs. As they get larger, though, they'll take longer, and it won't be long before they'll take longer to preview than to create in the first place. Very large drawings in SVG format might not display at all.","category":"page"},{"location":"howto/createdrawings/#Quick-drawings-with-macros","page":"Create drawings","title":"Quick drawings with macros","text":"","category":"section"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"The @draw, @svg, @drawsvg, @png, and @pdf macros are designed to let you quickly create graphics without having to provide the usual boiler-plate functions.","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"note: Note\nThe macros are shortcuts, designed to make it quick and easy to get started. You can save keystrokes and time, but, for full control over all parameters, use Drawing.","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"For example, this:","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"@svg circle(Point(0, 0), 20, action = :stroke) 50 50","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"is equivalent to this:","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"Drawing(50, 50, \"luxor-drawing-(timestamp).svg\")\norigin()\nbackground(\"white\")\nsethue(\"black\")\ncircle(Point(0, 0), 20, action = :stroke)\nfinish()\npreview()","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"You can omit the width and height (thus defaulting to 600 by 600, except for @imagematrix), and you don't have to specify a filename (you'll get time-stamped files in the current working directory). For multiple lines, use either:","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"@svg begin\n    setline(10)\n    sethue(\"purple\")\n    circle(Point(0, 0), 20, action = :fill)\nend","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"or (less nicely):","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"@svg (setline(10);\n      sethue(\"purple\");\n      circle(Point(0, 0), 20, action = :fill)\n     )","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"If you don't specify a size, the defaults are usually 600 by 600. If you don't specify a file name, files created with the macros are placed in your current working directory as luxor-drawing- followed by a time stamp. You don't even have to specify the suffix:","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"@svg juliacircles(150) 400 400 \"test\" # saves in \"test.svg\"","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"If you want to create drawings with transparent backgrounds, or use variables to specify filenames, you have to use the longer form, rather than the macros:","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"Drawing()\nbackground(1, 1, 1, 0)\norigin()\nsetline(30)\nsethue(\"green\") # assumes current opacity\nbox(BoundingBox() - 50, action = :stroke)\nfinish()\npreview()","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"(Image: transparent background)","category":"page"},{"location":"howto/createdrawings/#In-memory-drawings","page":"Create drawings","title":"In-memory drawings","text":"","category":"section"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"You can choose to store drawings in memory rather than use files. The advantage is that in-memory drawings are quicker, and the results can be passed as Julia data. Also, it's useful in some restricted environments to not have to worry about writing files.","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"This syntax for the Drawing function:","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"Drawing(width, height, surfacetype, [filename])","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"lets you supply surfacetype as a symbol (:svg, :png, :image, or :rec). This creates a new drawing of the given surface type and stores the image only in memory if no filename is supplied.","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"The @draw macro (equivalent to Drawing(..., :png) creates a PNG drawing in-memory (not saved in a file). You should see it displayed if you're working in a suitable environment (VSCode, Jupyter, Pluto).","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"The SVG equivalent of @draw is @drawsvg.","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"Use svgstring() to extract the SVG drawing's source as text.","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"If you want to generate SVG code without making a drawing, use @savesvg instead of @drawsvg.","category":"page"},{"location":"howto/createdrawings/#Concatenating-SVG-drawings","page":"Create drawings","title":"Concatenating SVG drawings","text":"","category":"section"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"The Julia functions hcat() and vcat() can concatenate two SVG drawings horizontally or vertically.","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"using Luxor\n\nd1 = @drawsvg begin\n    sethue(\"blue\")\n    paint()\n     end 200 100\n\nd2 = @drawsvg begin\n    sethue(\"yellow\")\n    paint()\n    end 200 100\n\nvcat(d1, d2)","category":"page"},{"location":"howto/createdrawings/#Interactive-drawings","page":"Create drawings","title":"Interactive drawings","text":"","category":"section"},{"location":"howto/createdrawings/#Using-Pluto","page":"Create drawings","title":"Using Pluto","text":"","category":"section"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"Pluto notebooks typically display the final result of a piece of code in a cell. So there are various ways you can organize your drawing code. For example:","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"using Luxor, PlutoUI, Colors\n\n@bind x Slider(0:0.1:12)\n\n@bind y Slider(1:12)\n\n@draw begin\n    setopacity(0.8)\n    for i in 0:0.1:1\n        sethue(HSB(360i, .8, .8))\n        squircle(O, 50, 50, action = :fill, rt = x * i)\n        rotate(2π/y)\n    end\nend 100 100","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"or","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"begin\n    d = Drawing(800, 800, :svg)\n    origin()\n    for (n, m) in enumerate(exp10.(range(0.0, 2, step=0.2)))\n        setmesh(mesh(convert(Vector{Point}, BoundingBox()/m),\n            [\"darkviolet\",\"gold2\", \"firebrick2\", \"slateblue4\"]))\n        rotate(π/7)\n        paint()\n    end\n    finish()\n    d\nend","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"(Image: pluto examples)","category":"page"},{"location":"howto/createdrawings/#Using-Jupyter-notebooks-(IJulia-and-Interact)","page":"Create drawings","title":"Using Jupyter notebooks (IJulia and Interact)","text":"","category":"section"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"Currently, you should use an in-memory SVG drawing to display graphics if you're using Interact.jl. This example provides an HSB color widget.","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"using Interact, Colors, Luxor\n@manipulate for h in 0:360, s in 0:0.01:1, b in 0:0.01:1\n    d = Drawing(300, 300, :svg)\n    sethue(Colors.HSB(h, s, b))\n    origin()\n    circle(Point(0, 0), 100, action = :fill)  \n    circle(polar(110, deg2rad(h)), 10, action = :fill)\n    sethue(\"black\")\n    label(string(h, \"°\"), deg2rad(h), polar(120, deg2rad(h)))\n        finish()\n    d\nend","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"(Image: interactive)","category":"page"},{"location":"howto/createdrawings/#Drawing-pixels","page":"Create drawings","title":"Drawing pixels","text":"","category":"section"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"The Drawing() function accepts an array of ARGB32 values as a drawing surface.","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"ARGB32 is a type of 32 bit unsigned integer that combines four values (8 bits for alpha, 8 bits for Red, 8 for Green, and 8 for Blue) into a 32-bit number between 0 and 4,294,967,296. ARGB32 is defined in ColorTypes.jl, and is available in Luxor.jl via Colors.jl, as Luxor.Colors.ARGB32, or, if you're using Colors.jl or Images.jl, directly as ARGB32.","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"using Luxor\n\nA = zeros(Luxor.Colors.ARGB32, 150, 600) # 150 rows, 600 columns\n\nDrawing(A)\n\nfor i in 1:15:150\n    A[i:i+10, 1:600] .= Luxor.Colors.RGB(rand(), rand(), rand())\nend\n\norigin()\n\nfor i in 1:100\n    randomhue()\n    ngon(rand(BoundingBox()), 15, 4, 0, :fill)\nend\n\nfinish()","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"(Image: buffer drawing)","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"As a standard Julia array, A will be shown as an image in your notebook or editor if you're using Images.jl.","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"note: Note\nIn this example the array uses Julian \"column-major\" array addressing. Luxor functions use the Point type on a Cartesian coordinate system, where the origin is (by default) at the top left of the drawing. Locations along the x-axis correspond to the column indices of the array, locations along the y-axis correspond to the rows of the array (until you use the origin() function, for example).","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"You can also create a pixel array on a PNG drawing when saved as a file:","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"using Luxor\nusing Images\n\nA = zeros(ARGB32, 50, 50)\n\nDrawing(A, \"/tmp/t.png\")\nfor p in eachindex(A)\n    A[p] = RGBA(rand(), rand(), rand(), 1)\nend\nfinish()\npreview()","category":"page"},{"location":"howto/createdrawings/#Extracting-the-drawing-as-an-image","page":"Create drawings","title":"Extracting the drawing as an image","text":"","category":"section"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"If you create a drawing using Drawing(w, h, :png), you can use the image_as_matrix function at any stage in the drawing process to extract the drawing in its current state as a matrix of pixels.","category":"page"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"See the Drawings as image matrices section for more information.","category":"page"},{"location":"howto/createdrawings/#Recordings","page":"Create drawings","title":"Recordings","text":"","category":"section"},{"location":"howto/createdrawings/","page":"Create drawings","title":"Create drawings","text":"The :rec option for Drawing() creates a recording surface in memory. You can then use snapshot(filename, ...) to copy the drawing into a file. See Snapshots.","category":"page"},{"location":"explanation/pathspolygons/#Paths-versus-polygons","page":"Paths vs Polygon","title":"Paths versus polygons","text":"","category":"section"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"When drawing in Luxor you'll usually be creating paths and polygons. It can be easy to confuse the two.","category":"page"},{"location":"explanation/pathspolygons/#Drawing-graphics-as-paths","page":"Paths vs Polygon","title":"Drawing graphics as paths","text":"","category":"section"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"Luxor draws graphics onto the current drawing using paths.","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"There's always a current path. It starts off being empty.","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"A path can contain one or more sequences of straight lines and Bézier curves. You add straight lines to the current path using functions like line(), and add Bezier curves using functions like curve(). You can continue the path at a different location of the drawing using move().","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"Luxor keeps track of the current path, the current point, and the current graphics state (color, line thickness, and so on), in response to the functions you call.","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"When called, the following function creates a single path consisting of three separate shapes - a line, a rectangular box, and a circle. The move() function as used here is essentially a \"pick up the pen and move it elsewhere\" instruction. line() adds a straight line segment to the current path. The circle() function adds four Bézier curves that provide a good approximation to a circle.","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"function make_path()\n    move(Point(-220, 50))\n    line(Point(-170, -50))\n    line(Point(-120, 50))\n    move(Point(0, 0))\n    box(O, 100, 100, :path)\n    move(Point(180, 0) + polar(40, 0)) # pt on circumference\n    circle(Point(180, 0), 40, :path)\nend","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"using Luxor\n\nfunction make_path()\n    move(Point(-220, 50))\n    line(Point(-170, -50))\n    line(Point(-120, 50))\n    move(Point(0, 0))\n    box(O, 100, 100, :path)\n    move(Point(180, 0) + polar(40, 0))\n    circle(Point(180, 0), 40, :path)\nend\n\nd = @drawsvg begin\n    background(\"antiquewhite\")\n\n    sethue(\"rebeccapurple\")\n    translate(0, -120)\n    make_path()\n    strokepath()\n\n    translate(0, 120)\n    sethue(\"orange\")\n    make_path()\n    fillpath()\n\n    translate(0, 120)\n    make_path()\n    clip()\n    sethue(\"green\")\n    rule.(between.(O - (250, 0), O + (250, 0), 0:0.01:1), -π/3)\n    end 800 500","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"d # hide","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"When you run this function, the path is added to the drawing. The top path, in purple, is drawn when strokepath() is called. Each of the three shapes is stroked with the same current settings (color, line thickness, dash pattern, and so on).","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"After calling the function again, the middle row shows the effect of calling fillpath() on the new path. It fills each of the three shapes in the path with orange.","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"Finally, after calling the function again,  the clip() function turns this new path into a clipping path. The rule() function draws green ruled lines, which are clipped by the outlines of the shapes in the path.","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"You can construct paths using functions like move(), line(), arc(), and curve(), plus any Luxor function that lets you specify the :path (\"add to path\") action as a keyword argument or parameter.","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"Many functions in Luxor have an action keyword argument or parameter. If you want to add that shape to the current path, use :path. If you want to both add the shape and finish and draw the current path, use one of stroke, fill, etc.  ","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"After the path is stroked or filled, it's emptied out, ready for you to start over again. There's always a current path. But you can also use one of the '-preserve' varsions, fillpreserve()/:fillpreserve or strokepreserve()/:strokepreserve to continue working with the currently defined path after drawing it. You can also convert the path to a clipping path using :clip/clip().","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"As you can see, a single path can contain multiple separate graphic shapes.","category":"page"},{"location":"explanation/pathspolygons/#Holes","page":"Paths vs Polygon","title":"Holes","text":"","category":"section"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"If you want a path to contain holes, you add the hole shapes to the current path after reversing their direction. For example, to put a square hole inside a circle, first create a circular shape, then draw a square shape inside, making sure that the square runs in the opposite direction to the circle. When you finally fill the path, the interior shape forms a hole.","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"using Luxor # hide\nd = @drawsvg begin # hide\nbackground(\"antiquewhite\") # hide\nsethue(\"purple\")\ncircle(O, 200, :path)\nbox(O, 100, 100, :path, reversepath=true)\nfillpath()\nend 800 500 # hide\nd # hide","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"If you're constructing the path from simple path commands, this is easy, and the functions that provide a reversepath keyword argument can help. If not, you can do things like this:","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"circle(O, 100, :path)                 # add a circle to the current path\npoly(reverse(box(O, 50, 50)), :path)  # create polygon, add to current path after reversing\nfillpath()                            # finally fill the two-part path","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"Many methods, including box(), crescent(), ellipse(), epitrochoid(), hypotrochoid(), ngon(), polycross(), rect(), squircle(), and star(), offer a vertices keyword argument. With these you can specify vertices=true to return a list of points instead of constructing a path.","category":"page"},{"location":"explanation/pathspolygons/#Path-objects","page":"Paths vs Polygon","title":"Path objects","text":"","category":"section"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"Sometimes it's useful to be able to store a path, rather than just construct it on the drawing. It might also be useful to draw it later, under different circumstances, and perhaps more than once. To do this, you can use the storepath() and drawpath() functions.","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"Consider this code that uses storepath():","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"move(Point(-220, 50))\nline(Point(-170, -50))\nline(Point(-120, 50))\nmove(Point(0, 0))\nbox(O, 100, 100, :path)\nmove(Point(180, 0) + polar(40, 0)) # pt on circumference\ncircle(Point(180, 0), 40, :path)\n\npathexample # save Path","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"pathexample now contains the path, stored in a Luxor object of type Path. The current path is still present.","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"julia> pathexample\nPath([\n PathMove(Point(-220.0, 50.0)),\n PathLine(Point(-170.0, -50.0)),\n PathLine(Point(-120.0, 50.0)),\n PathMove(Point(-50.0, 50.0)),\n PathLine(Point(-50.0, -50.0)),\n PathLine(Point(50.0, -50.0)),\n PathLine(Point(50.0, 50.0)),\n PathClose(),\n PathMove(Point(220.0, 0.0)),\n PathCurve(Point(220.0, 22.08984375), Point(202.08984375, 40.0), Point(180.0, 40.0)),\n PathCurve(Point(157.91015625, 40.0), Point(140.0, 22.08984375), Point(140.0, 0.0)),\n PathCurve(Point(140.0, -22.08984375), Point(157.91015625, -40.0), Point(180.0, -40.0)),\n PathCurve(Point(202.08984375, -40.0), Point(220.0, -22.08984375), Point(220.0, 0.0))\n])","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"It's now possible to draw this stored path at a later time. For example, this code builds a path, saves it as pathexample, then draws a number of rotated copies:","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"using Luxor\nd = @draw begin\n    move(Point(-220, 50))\n    line(Point(-170, -50))\n    line(Point(-120, 50))\n    move(Point(0, 0))\n    box(O, 100, 100, :path)\n    move(Point(180, 0) + polar(40, 0))\n    circle(Point(180, 0), 40, :path)\n\n    pathexample = storepath() # store the path\n\n    rotate(-π/2)\n    for i in -200:50:200\n        @layer begin\n            randomhue()\n            translate(0, i)\n            drawpath(pathexample, :stroke)\n        end\n    end\nend\nd # hide","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"See also Stored paths.","category":"page"},{"location":"explanation/pathspolygons/#Polygons","page":"Paths vs Polygon","title":"Polygons","text":"","category":"section"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"A polygon is a plain Vector (Array) of Points. There are no lines or curves, just 2D coordinates in the form of Points. When a polygon is eventually drawn, it's converted into a path, and the points are connected with short straight lines.","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"One important difference between polygons and paths is that paths can contain Bézier curves.","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"The pathtopoly() function extracts the current path that Luxor is in the process of constructing and returns an array of Vectors of points - a set of one or more polygons (remember that a single path can contain multiple shapes). Internally this function uses getpathflat(), which is similar to getpath() but it returns a Luxor path object in which all Bézier curve segments have been reduced to sequences of short straight lines.","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"So:","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"circle(O, 100, :path)\np = pathtopoly()\npoly(first(p), :stroke)","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"is more or less equivalent to:","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"ngon(O, 100, 129, 0, :stroke)    # a 129agon with radius 100","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"Luxor draws as many short straight lines as necessary (here about 129) so as to render the curve smooth at reasonable magnifications.","category":"page"},{"location":"explanation/pathspolygons/","page":"Paths vs Polygon","title":"Paths vs Polygon","text":"Note that methods to functions might vary in how they operate: whereas box(Point(0, 0), 50, 50) returns a polygon (a list of points), box(Point(0, 0), 50, 50, :path) adds a rectangle to the current path and returns a polygon. However, box(Point(0, 0), 50, 50, 5 ... ) constructs a path with Bézier-curved corners, so this method doesn't return any vertex information - you'll have to flatten the Béziers via getpathflat() or obtain the path with intact Béziers via getpath().","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"DocTestSetup = quote\n    using Luxor, Colors, Random\n    end","category":"page"},{"location":"howto/geometrytools/#Geometry-tools","page":"Use geometry tools","title":"Geometry tools","text":"","category":"section"},{"location":"howto/geometrytools/#Lines-and-distances","page":"Use geometry tools","title":"Lines and distances","text":"","category":"section"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"You can find the midpoint between two points using midpoint.","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"The following code places a small pentagon (using ngon) at the midpoint of each side of a larger pentagon:","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"using Luxor # hide\nDrawing(700, 220, \"../assets/figures/midpoint.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsethue(\"red\")\nngon(O, 100, 5, 0, action = :stroke)\n\nsethue(\"darkgreen\")\np5 = ngon(O, 100, 5, 0, vertices=true)\n\nfor i in eachindex(p5)\n    pt1 = p5[mod1(i, 5)]\n    pt2 = p5[mod1(i + 1, 5)]\n    ngon(midpoint(pt1, pt2), 20, 5, 0, action = :fill)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"(Image: arc)","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"A more general function, between, finds for a value x between 0 and 1 the corresponding point on a line defined by two points. So midpoint(p1, p2) and between(p1, p2, 0.5) should return the same point.","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"using Luxor # hide\nDrawing(700, 150, \"../assets/figures/betweenpoint.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsethue(\"red\")\np1 = Point(-150, 0)\np2 = Point(150, 40)\nline(p1, p2)\nstrokepath()\nfor i in -0.5:0.1:1.5\n    randomhue()\n    circle(between(p1, p2, i), 5, action = :fill)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"(Image: arc)","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"Values less than 0.0 and greater than 1.0 appear to work well too, placing the point on the line if extended.","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"center3pts finds the radius and center point of a circle passing through three points which you can then use with functions such as circle or arc2r.","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"perpendicular finds the foot of a perpendicular line which lies on a line through two points perpendicular to a another point.","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"using Luxor # hide\nd = @drawsvg begin # hide\nA, B = Point(-150, 0), Point(150, 50)\n\nsethue(\"grey50\")\nfontsize(18)\nsetline(4)\n\nline(A, B, action = :stroke)\n\n# point perpendicular to line\nC = Point(-50, -80)\nD = perpendicular(A, B, C)\n\n# line perpendicular to line\nE, F = perpendicular(A, B)\n\n# point perpendicular to extended line\nG = Point(230, -200)\nH = perpendicular(A, B, G)\n\nsethue(\"grey50\")\nlabel.(string.([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\"]),\n    :ne, offset=10,\n    (A, B, C, D, E, F, G, H))\n\nsethue(\"red\")\narrow(C, D)\nsethue(\"green\")\narrow(E, F)\nsethue(\"orange\")\narrow(G, H)\nsethue(\"purple\")\ncircle.([A, B, C, D, E, F, G, H], 4, action = :fill)\nend # hide\nd # hide","category":"page"},{"location":"howto/geometrytools/#Points-and-arcs","page":"Use geometry tools","title":"Points and arcs","text":"","category":"section"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"Use isarcclockwise(c, p1, p2) to check whether an arc centered at c running from p1 to p2 is clockwise.","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"The pointinverse function finds the inverse of a point relative to a reference circle (centerpoint and radius). In the following example, each vertex on the shape inside the circle is linked by an arrow to its inverse outside the circle.","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"using Luxor, Colors # hide\nd = @drawsvg begin\norigin() # hide\nbackground(\"antiquewhite\") # hide\nsetline(1) # hide\nradius = 60\ncircle(O, radius + 20, action = :stroke)\n\npoints = polycross(O, radius, 7, vertices=true)\npoly(points, action = :stroke, close=true)\n\nantipoints = last.(pointinverse.(points, O, radius+20))\n\nfor (n, pt) in enumerate(zip(points, antipoints))\n    sethue(HSB(length(points) * n, 0.8, 0.8))\n    @. circle(pt, distance(O, pt)/6, action = :fill)\n    sethue(\"black\")\n    arrow(pt...)\nend\nend 800 500\nd # hide","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"Use anglethreepoints to find the angle formed by two lines connecting three points:","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"using Luxor # hide\nDrawing(800, 800, \"../assets/figures/anglethreepoints.png\") # hide\norigin() # hide\n\nfunction showangle(pt1, pt2, pt3)\n    θ = anglethreepoints(pt1, pt2, pt3)\n    label(string(round(rad2deg(θ), digits=2), \"°\"), :w, pt2)\n    newpath()\n    carc(pt2, 50, 0, -θ)\n    strokepath()\nend\n\nlet\n    background(\"grey20\")\n    sethue(\"white\")\n    fontsize(12)\n    tiles = Tiler(800, 800, 4, 4)\n    for (pos, n) in tiles\n        @layer begin\n            translate(pos)\n            pg = [polar(50, 0), O, polar(50, n * -2π/16)]\n            poly(pg, action = :stroke)\n            for n in 1:3\n                pt1 = pg[1]\n                pt2 = pg[2]\n                pt3 = pg[3]\n                showangle(pt1, pt2, pt3)\n            end\n        end\n    end\n    finish() # hide\nend\n\nnothing # hide","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"(Image: angle three points)","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"Other functions that help with geometry include:","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"distance distance between two points\ngetnearestpointonline drop perpendicular \npointlinedistance distance of point from line between two points\nslope angle of line between two points\nperpendicular find perpendicular\ndotproduct scalar dot product of two points\n@polar convert radius and angle to point\npolar convert radius and angle to point\nispointonline true if point lies on line\nispointonpoly true if point lies on any edge of polygon\nisarcclockwise true if arc is clockwise\npointinverse inverse of point with respect to circle\nanglethreepoints angle formed by two lines defined by three points\ndeterminant3 find determinant of matrix of 3 points\nrotatepoint rotate point around another by angle","category":"page"},{"location":"howto/geometrytools/#Triangle-centers","page":"Use geometry tools","title":"Triangle centers","text":"","category":"section"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"To find the center of a triangle, use one of:","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"trianglecircumcenter center of circumcircle/intersection of the perpendicular bisectors.\ntriangleincenter intersection of the interior angle bisectors\ntrianglecenter centroid\ntriangleorthocenter intersection of the altitudes","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"using Luxor # hide\n\nDrawing(350, 350, \"../assets/figures/trianglecenters.svg\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetline(0.4) # hide\nfontsize(11) # hide\n▲ = Point[Point(-100.0, 0.0), Point(110.0, 30.0), Point(65.0, 90.0)]\n\n@layer begin\n    sethue(\"red\")\n    setline(2)\n    poly(▲,  :stroke, close=true)\nend\n\n# circumcenter\ncircle(▲..., action = :stroke)\ncp = trianglecircumcenter(▲...)\ncircle(cp, 2, action = :fill)\nlabel(\"circumcenter\", :N, cp)\n\n# incenter\ncp = triangleincenter(▲...)\ncircle(cp, 2, action = :fill)\npt1 = getnearestpointonline(▲[1], ▲[2], cp)\n@layer begin\n    sethue(\"black\")\n    circle(cp, distance(cp, pt1), action = :stroke)\n    label(\"incenter\", :S, cp)\nend\n\n# center    \ncp = trianglecenter(▲...)\ncircle(cp, 2, action = :fill)\nlabel(\"center\", :w, cp)\n\n# orthocenter\ncp = triangleorthocenter(▲...)\ncircle(cp, 2, action = :fill)\nlabel(\"orthocenter\", :e, cp)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"(Image: triangle centers)","category":"page"},{"location":"howto/geometrytools/#Intersections","page":"Use geometry tools","title":"Intersections","text":"","category":"section"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"intersectionlines finds the intersection of two lines.","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"using Luxor # hide\nDrawing(700, 220, \"../assets/figures/intersection.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\n\nsethue(\"black\")\nP1, P2, P3, P4 = ngon(O, 100, 5, vertices=true)\nlabel.([\"P1\", \"P2\", \"P3\", \"P4\"], :N, [P1, P2, P3, P4])\nline(P1, P2, action = :stroke)\nline(P4, P3, action = :stroke)\n\nflag, ip =  intersectionlines(P1, P2, P4, P3)\nif flag\n    circle(ip, 5, action = :fill)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"(Image: arc)","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"intersectionlinecircle finds the intersection of a line and a circle. There can be 0, 1, or 2 intersection points.","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"using Luxor # hide\nDrawing(700, 220, \"../assets/figures/intersection_line_circle.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsethue(\"chocolate2\") # hide\nl1 = Point(-100.0, -75.0)\nl2 = Point(300.0, 100.0)\nrad = 100\ncpoint = Point(0, 0)\nline(l1, l2, action = :stroke)\nsethue(\"darkgreen\") # hide\ncircle(cpoint, rad, action = :stroke)\nnints, ip1, ip2 =  intersectionlinecircle(l1, l2, cpoint, rad)\nsethue(\"black\")\nif nints == 2\n    circle(ip1, 8, action = :stroke)\n    circle(ip2, 8, action = :stroke)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"(Image: arc)","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"intersection2circles finds the area of the intersection of two circles, and intersectioncirclecircle finds the points where they cross.","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"This example shows the areas of two circles, and the area of their intersection.","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"using Luxor # hide\nDrawing(700, 310, \"../assets/figures/intersection2circles.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nfontsize(14) # hide\nsethue(\"black\") # hide\n\nc1 = (O, 150)\nc2 = (O + (100, 0), 150)\n\ncircle(c1... , action = :stroke)\ncircle(c2... , action = :stroke)\n\nsethue(\"purple\")\ncircle(c1... , action = :clip)\ncircle(c2... , action = :fill)\nclipreset()\n\nsethue(\"black\")\n\ntext(string(150^2 * π |> round), c1[1] - (125, 0))\ntext(string(150^2 * π |> round), c2[1] + (100, 0))\nsethue(\"white\")\ntext(string(intersection2circles(c1..., c2...) |> round),\n     midpoint(c1[1], c2[1]), halign=:center)\n\nsethue(\"red\")\nflag, C, D = intersectioncirclecircle(c1..., c2...)\nif flag\n    circle.([C, D], 5, action = :fill)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"(Image: intersection of two circles)","category":"page"},{"location":"howto/geometrytools/#Bounding-boxes","page":"Use geometry tools","title":"Bounding boxes","text":"","category":"section"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"The BoundingBox type allows you to use rectangular extents to organize and interact with the 2D drawing area. A BoundingBox holds two points, the opposite corners of a bounding box.","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"You can make a BoundingBox from:","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"the current drawing\ntwo points\na text string\nan existing polygon\na stored path\na table or table cell","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"and by modifying an existing bounding box, or using the results of functions such as circle() or box().","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"BoundingBox without arguments defines an extent that encloses the drawing (assuming that the origin is at the center of the drawing—see origin). Use centered=false if the drawing origin is still at the top left corner.","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"This example draws circles at three points: at two of the drawing's corners and at the midway point between them:","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"using Luxor # hide\nDrawing(700, 400, \"../assets/figures/bbox.png\") # hide\nbackground(\"white\") # hide\n\norigin()\n\nbb = BoundingBox()\nsetline(10)\nsethue(\"orange\")\n\ncircle(bb[1], 150, action = :stroke) # first corner\n\ncircle(bb[2], 150, action = :stroke) # second corner\n\ncircle(midpoint(bb...), 150, action = :stroke) # midpoint\n\nsethue(\"blue\")\ncircle.([bb[1], midpoint(bb[1:2]), bb[2]], 130, action = :fill)\n\nsethue(\"red\")\ncircle.([first(bb), midpoint(bb...), last(bb)], 100, action = :fill)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"(Image: bounding box)","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"You can make a bounding box from a polygon:","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"using Luxor # hide\nDrawing(400, 200, \"../assets/figures/bboxpoly.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\n\np = star(O, 100, 5, 0.1, π/3.3, vertices=true)\nsethue(\"antiquewhite\")\nbox(BoundingBox(p), action = :fill)\n\nsethue(\"black\")\npoly(p, action = :stroke, close=true)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"(Image: bounding box of polygon)","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"The resulting bounding boxes can be passed to box or poly to be drawn.","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"To convert a bounding box b into a box, use box(b, vertices=true) or convert(Vector{Point}, BoundingBox()).","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"To obtain the coordinates of the corners or key points on the bounding box, use the functions with names combining box and top|middle|bottom and left|center|right. So boxtopleft(bbox) finds the top left corner of the bounding box bbox.","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"You can also do some arithmetic on bounding boxes. In the next example, the bounding box is created from the text \"good afternoon\". The bounding box is filled with purple, then increased by 40 units on all sides (blue), also scaled by 1.3 (green), and also shifted by (0, 100) (orange).","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"using Luxor # hide\nDrawing(500, 300, \"../assets/figures/bbox2.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\n\ntranslate(-130,0)\nfontsize(40)\nstr = \"good afternoon\"\nsethue(\"purple\")\nbox(BoundingBox(str), action = :fill)\nsethue(\"white\")\ntext(str)\n\nsethue(\"blue\")\nmodbox = BoundingBox(str) + 40 # add 40 units to all sides\npoly(modbox, action = :stroke, close=true)\n\nsethue(\"green\")\nmodbox = BoundingBox(str) * 1.3\npoly(modbox, action = :stroke, close=true)\n\nsethue(\"orange\")\nmodbox = BoundingBox(str) + (0, 100)\npoly(modbox, action = :fill, close=true)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"(Image: bounding boxes 2)","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"You can find the union and intersection of BoundingBoxes, and also find whether a point lies inside one. The following code creates, shrinks, and shifts two bounding boxes (colored yellow and pink), and then draws: their union (a bounding box that includes both), in black outline; and their intersection (a bounding box of their common areas), in red. Then some random points are created (you can pass a bounding box to rand() to get a random point inside the box) and drawn differently depending on whether they're inside the intersection or outside.","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"using Luxor, Random # hide\nDrawing(600, 400, \"../assets/figures/bbox3.png\") # hide\nbackground(\"white\") # hide\nRandom.seed!(42) # hide\n\norigin()\nsetopacity(0.75)\nsetline(8)\n\nbbox1 = BoundingBox()/2 - (50, 30)\nsethue(\"yellow\")\nbox(bbox1, action = :fill)\n\nbbox2 = BoundingBox()/2  + (50, 30)\nsethue(\"pink\")\nbox(bbox2, action = :fill)\n\nsethue(\"black\")\nbox(bbox1 + bbox2, action = :stroke)\n\nsethue(\"red\")\nbothboxes = intersectboundingboxes(bbox1, bbox2)\nbox(bothboxes, action = :fill)\n\nfor i in 1:500\n    pt = rand(bbox1 + bbox2)\n    if isinside(pt, bothboxes)\n        sethue(\"white\")\n        circle(pt, 3, action = :fill)\n    else\n        sethue(\"black\")\n        circle(pt, 2, action = :fill)\n    end\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"(Image: intersecting bounding boxes)","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"To find out where a line starting at the center of a bounding box passing through a point crosses or would cross the edges of the box, use pointcrossesboundingbox.","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"using Luxor, Random # hide\nDrawing(600, 400, \"../assets/figures/bbox4.png\") # hide\nbackground(\"antiquewhite\") # hide\nRandom.seed!(42) # hide\norigin() # hide\nbx = BoundingBox(box(O, 200, 200))\nsetline(1)\nsethue(\"black\") # hide\nbox(bx, action = :stroke)\nfor i in 1:10\n    pt = randompoint((1.5bx)...)\n    pt2 = pointcrossesboundingbox(pt, bx)\n\n    sethue(\"grey50\")\n    arrow(O, pt)\n    sethue(\"red\")\n    circle(pt2, 3, action = :stroke)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"(Image: point crosses bounding box)","category":"page"},{"location":"howto/geometrytools/#Random-points","page":"Use geometry tools","title":"Random points","text":"","category":"section"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"You can use randompointarray to create an array of randomly placed points.","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"The randompointarray(boundingbox, distance) method fills the boundingbox with random points up to distance units apart using a Poisson Disk sampling method.","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"using Luxor, Colors # hide\n@drawsvg begin # hide\nbackground(\"black\")\nb = blend(\n        boxtopleft(BoundingBox()),\n        boxbottomright(BoundingBox()),\n        \"red\",\n        \"green\")\n\naddstop(b, 0.3, \"orange\")\naddstop(b, 0.4, \"magenta\")\naddstop(b, 0.5, \"cyan\")\naddstop(b, 0.7, \"yellow\")\nsetblend(b)\n\nfor pt in randompointarray(BoundingBox() * 0.9, 15)\n    d = rescale(distance(pt, O), 0, sqrt(800 * 500), 1, 0)\n    circle(pt, 1 + 7d, action = :fill)\nend\nend 800 500 # hide","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"The randompointarray(point1, point2, n) method generates n random points in the area bounded by two points, using Julia's random number generator.","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"using Luxor, Random # hide\n@drawsvg begin # hide\nbackground(\"white\") # hide\nRandom.seed!(42) # hide\norigin() # hide\n\npt1 = Point(-300, -150)\npt2 = Point(300, 150)\n\nsethue(\"purple\")\nmap(pt -> circle(pt, 6, action = :fill), (pt1, pt2))\nbox(pt1, pt2, action = :stroke)\n\nsethue(\"blue\")\nmap(pt -> circle(pt, 4, action = :fill), randompointarray(pt1, pt2, 200))\n\nend 800 400 # hide","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"Use rand(BoundingBox()) to return a single point somewhere inside a bounding box.","category":"page"},{"location":"howto/geometrytools/#Noise","page":"Use geometry tools","title":"Noise","text":"","category":"section"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"For artistic graphics you might prefer noisy input values to purely random ones. Use the noise function to obtain smoothly changing random values corresponding to input coordinates. The returned values wander slowly rather than jump about everywhere.","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"In this example, the gray value varies gradually as the noise function returns values between 0 and 1 depending on the location of the two input values pos.x and pos.y.","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"The top two quadrants use a lower value for the detail keyword argument, an integer ()>= 1) specifying how many \"octaves\" of noise you want.","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"The left two quadrants use a lower value for the persistence keyword argument, a floating point number specifying how the amplitude diminishes for each successive level of detail. There is more fine detail when the persistence is higher, particularly when the detail setting is also high.","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"using Luxor, Colors # hide\nDrawing(800, 400, \"../assets/figures/noise.png\") # hide\n\nbackground(\"white\") # hide\norigin() # hide\n\ntiles = Tiler(800, 400, 200, 200)\nsethue(\"black\")\nfor (pos, n) in tiles\n    freq = 0.05\n    pos.y < 0 ? d = 1      : d = 4\n    pos.x < 0 ? pers = 0.3 : pers = 1.0\n    ns = noise(freq * pos.x, freq * pos.y,\n        detail=d,\n        persistence=pers)\n    setgray(ns)\n    box(pos, tiles.tilewidth, tiles.tileheight, action = :fillstroke)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"(Image: noise)","category":"page"},{"location":"howto/geometrytools/","page":"Use geometry tools","title":"Use geometry tools","text":"Use initnoise to initialize the noise behaviour.","category":"page"},{"location":"reference/api/","page":"Function reference","title":"Function reference","text":"Modules = [Luxor]\nOrder   = [:macro, :function, :type, :constant, ]","category":"page"},{"location":"reference/api/#Luxor.@draw","page":"Function reference","title":"Luxor.@draw","text":"@draw drawing-instructions [width] [height]\n\nPreview an PNG drawing, optionally specifying width and height (the default is 600 by 600). The drawing is stored in memory, not in a file on disk.\n\nExamples\n\n@draw circle(O, 20, :fill)\n\n@draw circle(O, 20, :fill) 400\n\n@draw circle(O, 20, :fill) 400 1200\n\n@draw begin\n    setline(10)\n    sethue(\"purple\")\n    circle(O, 20, :fill)\nend\n\n@draw begin\n    setline(10)\n    sethue(\"purple\")\n    circle(O, 20, :fill)\nend 1200 1200\n\n\n\n\n\n","category":"macro"},{"location":"reference/api/#Luxor.@drawsvg","page":"Function reference","title":"Luxor.@drawsvg","text":"@drawsvg begin\n    body\nend w h\n\nCreate and preview an SVG drawing. Like @draw but using SVG format.\n\nUnlike @draw (PNG), there is no background, by default.\n\n\n\n\n\n","category":"macro"},{"location":"reference/api/#Luxor.@eps","page":"Function reference","title":"Luxor.@eps","text":"@eps drawing-instructions [width] [height] [filename]\n\nCreate and preview an EPS drawing, optionally specifying width and height (the default is 600 by 600). The file is saved in the current working directory as filename if supplied, or luxor-drawing(timestamp).eps.\n\nOn some platforms, EPS files are converted automatically to PDF when previewed.\n\nExamples\n\n@eps circle(O, 20, :fill)\n\n@eps circle(O, 20, :fill) 400\n\n@eps circle(O, 20, :fill) 400 1200\n\n@eps circle(O, 20, :fill) 400 1200 \"/tmp/A0-version\"\n\n@eps circle(O, 20, :fill) 400 1200 \"/tmp/A0-version.eps\"\n\n@eps begin\n    setline(10)\n    sethue(\"purple\")\n    circle(O, 20, :fill)\nend\n\n@eps begin\n    setline(10)\n    sethue(\"purple\")\n    circle(O, 20, :fill)\nend 1200 1200\n\n\n\n\n\n","category":"macro"},{"location":"reference/api/#Luxor.@imagematrix","page":"Function reference","title":"Luxor.@imagematrix","text":"@imagematrix drawing-instructions [width=256] [height=256]\n\nCreate a drawing and return a matrix of the image.\n\nThis macro returns a matrix of pixels that represent the drawing produced by the vector graphics instructions. It uses the image_as_matrix() function.\n\nThe default drawing is 256 by 256 points.\n\nYou don't need finish() (the macro calls it), and it's not previewed by preview().\n\nm = @imagematrix begin\n        sethue(\"red\")\n        box(O, 20, 20, :fill)\n    end 60 60\n\njulia>  m[1220:1224] |> show\n    ARGB32[ARGB32(0.0N0f8,0.0N0f8,0.0N0f8,0.0N0f8),\n           ARGB32(1.0N0f8,0.0N0f8,0.0N0f8,1.0N0f8),\n           ARGB32(1.0N0f8,0.0N0f8,0.0N0f8,1.0N0f8),\n           ARGB32(1.0N0f8,0.0N0f8,0.0N0f8,1.0N0f8),\n           ARGB32(1.0N0f8,0.0N0f8,0.0N0f8,1.0N0f8)]\n\n\nIf, for some strange reason you want to draw the matrix as another Luxor drawing again, use code such as this:\n\nm = @imagematrix begin\n        sethue(\"red\")\n        box(O, 20, 20, :fill)\n        sethue(\"blue\")\n        box(O, 10, 40, :fill)\n    end 60 60\n\nfunction convertmatrixtocolors(m)\n    return convert.(Colors.RGBA, m)\nend\n\nfunction drawimagematrix(m)\n    d = Drawing(500, 500, \"/tmp/temp.png\")\n    origin()\n    w, h = size(m)\n    t = Tiler(500, 500, w, h)\n    mi = convertmatrixtocolors(m)\n    @show mi[30, 30]\n    for (pos, n) in t\n        c = mi[t.currentrow, t.currentcol]\n        setcolor(c)\n        box(pos, t.tilewidth -1, t.tileheight - 1, :fill)\n    end\n    finish()\n    return d\nend\n\ndrawimagematrix(m)\n\nTransparency\n\nThe default value for the cells in an image matrix is transparent black. (Luxor's default color is opaque black.)\n\njulia> @imagematrix begin\n       end 2 2\n2×2 reinterpret(ARGB32, ::Array{UInt32,2}):\n ARGB32(0.0,0.0,0.0,0.0)  ARGB32(0.0,0.0,0.0,0.0)\n ARGB32(0.0,0.0,0.0,0.0)  ARGB32(0.0,0.0,0.0,0.0)\n\nSetting the background to a partially or completely transparent value may give unexpected results:\n\njulia> @imagematrix begin\n       background(1, 0.5, 0.0, 0.5) # semi-transparent orange\n       end 2 2\n2×2 reinterpret(ARGB32, ::Array{UInt32,2}):\n ARGB32(0.502,0.251,0.0,0.502)  ARGB32(0.502,0.251,0.0,0.502)\n ARGB32(0.502,0.251,0.0,0.502)  ARGB32(0.502,0.251,0.0,0.502)\n\nhere the semi-transparent orange color has been partially applied to the transparent background.\n\njulia> @imagematrix begin\n           sethue(1., 0.5, 0.0)\n       paint()\n       end 2 2\n2×2 reinterpret(ARGB32, ::Array{UInt32,2}):\n ARGB32(1.0,0.502,0.0,1.0)  ARGB32(1.0,0.502,0.0,1.0)\n ARGB32(1.0,0.502,0.0,1.0)  ARGB32(1.0,0.502,0.0,1.0)\n\npicks up the default alpha of 1.0.\n\n\n\n\n\n","category":"macro"},{"location":"reference/api/#Luxor.@imagematrix!","page":"Function reference","title":"Luxor.@imagematrix!","text":"@imagematrix! buffer drawing-instructions [width=256] [height=256]\n\nLike @imagematrix, but use an existing UInt32 buffer.\n\nw = 200\nh  = 150\nbuffer = zeros(UInt32, w, h)\nm = @imagematrix! buffer juliacircles(40) 200 150;\nImages.RGB.(m)\n\n\n\n\n\n","category":"macro"},{"location":"reference/api/#Luxor.@layer-Tuple{Any}","page":"Function reference","title":"Luxor.@layer","text":"The `layer` macro is a shortcut for `gsave()` ... `grestore()`.\n\n\n\n\n\n","category":"macro"},{"location":"reference/api/#Luxor.@pdf","page":"Function reference","title":"Luxor.@pdf","text":"@pdf drawing-instructions [width] [height] [filename]\n\nCreate and preview an PDF drawing, optionally specifying width and height (the default is 600 by 600). The file is saved in the current working directory as filename if supplied, or luxor-drawing(timestamp).pdf.\n\nExamples\n\n@pdf circle(O, 20, :fill)\n\n@pdf circle(O, 20, :fill) 400\n\n@pdf circle(O, 20, :fill) 400 1200\n\n@pdf circle(O, 20, :fill) 400 1200 \"/tmp/A0-version\"\n\n@pdf circle(O, 20, :fill) 400 1200 \"/tmp/A0-version.pdf\"\n\n@pdf begin\n    setline(10)\n    sethue(\"purple\")\n    circle(O, 20, :fill)\nend\n\n@pdf begin\n    setline(10)\n    sethue(\"purple\")\n    circle(O, 20, :fill)\nend 1200 1200\n\n\n\n\n\n","category":"macro"},{"location":"reference/api/#Luxor.@png","page":"Function reference","title":"Luxor.@png","text":"@png drawing-instructions [width] [height] [filename]\n\nCreate and preview an PNG drawing, optionally specifying width and height (the default is 600 by 600). The file is saved in the current working directory as filename, if supplied, or luxor-drawing(timestamp).png.\n\nExamples\n\n@png circle(O, 20, :fill)\n\n@png circle(O, 20, :fill) 400\n\n@png circle(O, 20, :fill) 400 1200\n\n@png circle(O, 20, :fill) 400 1200 \"/tmp/round\"\n\n@png circle(O, 20, :fill) 400 1200 \"/tmp/round.png\"\n\n@png begin\n    setline(10)\n    sethue(\"purple\")\n    circle(O, 20, :fill)\nend\n\n@png begin\n    setline(10)\n    sethue(\"purple\")\n    circle(O, 20, :fill)\nend 1200 1200\n\n\n\n\n\n","category":"macro"},{"location":"reference/api/#Luxor.@polar-Tuple{Any}","page":"Function reference","title":"Luxor.@polar","text":"@polar (p)\n\nConvert a tuple of two numbers to a Point of x, y Cartesian coordinates.\n\n@polar (10, pi/4)\n@polar [10, pi/4]\n@polar 10, pi/4\n\nproduces\n\nLuxor.Point(7.0710678118654755, 7.071067811865475)\n\n\n\n\n\n","category":"macro"},{"location":"reference/api/#Luxor.@savesvg","page":"Function reference","title":"Luxor.@savesvg","text":"@savesvg begin\n    body\nend w h\n\nLike @drawsvg but returns the raw SVG code of the drawing in a string. Uses svgstring.\n\nUnlike @draw (PNG), there is no background, by default.\n\nTHis example scans the generated SVG for color values:\n\ns = @savesvg begin\n    julialogo()\nend\n\neachmatch(r\"rgb.*?;\", s) |> collect\n\n5-element Vector{RegexMatch}:\n RegexMatch(\"rgb(0%,0%,0%);\")\n RegexMatch(\"rgb(25.1%,38.8%,84.7%);\")\n RegexMatch(\"rgb(22%,59.6%,14.9%);\")\n RegexMatch(\"rgb(58.4%,34.5%,69.8%);\")\n RegexMatch(\"rgb(79.6%,23.5%,20%);\")\n\n\n\n\n\n\n","category":"macro"},{"location":"reference/api/#Luxor.@setcolor_str-Tuple{Any}","page":"Function reference","title":"Luxor.@setcolor_str","text":"Set the current color to a string using a macro.\n\nFor example:\n\nsetcolor\"red\"\n\n\n\n\n\n","category":"macro"},{"location":"reference/api/#Luxor.@svg","page":"Function reference","title":"Luxor.@svg","text":"@svg drawing-instructions [width] [height] [filename]\n\nCreate and preview an SVG drawing, optionally specifying width and height (the default is 600 by 600). The file is saved in the current working directory as filename if supplied, or luxor-drawing-(timestamp).svg.\n\nExamples\n\n@svg circle(O, 20, :fill)\n\n@svg circle(O, 20, :fill) 400\n\n@svg circle(O, 20, :fill) 400 1200\n\n@svg circle(O, 20, :fill) 400 1200 \"/tmp/test\"\n\n@svg circle(O, 20, :fill) 400 1200 \"/tmp/test.svg\"\n\n@svg begin\n    setline(10)\n    sethue(\"purple\")\n    circle(O, 20, :fill)\nend\n\n@svg begin\n    setline(10)\n    sethue(\"purple\")\n    circle(O, 20, :fill)\nend 1200 1200\n\n\n\n\n\n","category":"macro"},{"location":"reference/api/#Base.:*-Tuple{AbstractMatrix, Point}","page":"Function reference","title":"Base.:*","text":"*(m::Matrix, pt::Point)\n\nTransform a point pt by the 3×3 matrix m.\n\njulia> M = [2 0 0; 0 2 0; 0 0 1]\n3×3 Matrix{Int64}:\n 2  0  0\n 0  2  0\n 0  0  1\n\njulia> M * Point(20, 20)\nPoint(40.0, 40.0)\n\nTo convert between Cairo matrices (6-element Vector{Float64}) to a 3×3 Matrix, use cairotojuliamatrix() and juliatocairomatrix().\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Base.convert-Tuple{Type{Vector{Point}}, BoundingBox}","page":"Function reference","title":"Base.convert","text":"convert(Point, bbox::BoundingBox)\n\nConvert a BoundingBox to a four-point clockwise polygon.\n\nconvert(Vector{Point}, BoundingBox())\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Base.hcat-Tuple{Vararg{Drawing}}","page":"Function reference","title":"Base.hcat","text":"hcat(D::Drawing...; valign=:top, hpad=0, clip=true)\n\nCreate a new SVG drawing by horizontal concatenation of SVG drawings. If drawings have different height, the valign option can be used in order to define how to align. The hpad argument can be used to add padding between concatenated images.\n\nThe clip argument is a boolean for whether the concatenated images should be clipped before concatenation. Note that drawings sometimes have elements that go beyond it's margins, and they only show when the image is drawn in a larger canvas. The clip argument ensures that these elements are not drawn in the concatenated drawing.\n\nExample:\n\nd1 = Drawing(200, 100, :svg)\norigin()\ncircle(O, 60, :fill)\nfinish()\n\nd2 = Drawing(200, 200, :svg)\nrect(O, 200, 200, :fill)\nfinish()\nhcat(d1, d2; hpad = 10, valign = :top, clip = true)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Base.in-Tuple{Point, BoundingBox}","page":"Function reference","title":"Base.in","text":"in(pt, bbox::BoundingBox)\n\nTest whether pt is inside bbox.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Base.isapprox-Tuple{Point, Point}","page":"Function reference","title":"Base.isapprox","text":"isapprox(p1::Point, p2::Point; atol = 1e-6, kwargs...)\n\nCompare points.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Base.isequal-Tuple{Point, Point}","page":"Function reference","title":"Base.isequal","text":"isequal(p1::Point, p2::Point) =     isapprox(p1.x, p2.x, atol = 0.00000001) &&    (isapprox(p1.y, p2.y, atol = 0.00000001))\n\nCompare points.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Base.rand-Tuple{BoundingBox}","page":"Function reference","title":"Base.rand","text":"rand(bbox::BoundingBox)\n\nReturn a random Point that lies inside bbox.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Base.vcat-Tuple{Vararg{Drawing}}","page":"Function reference","title":"Base.vcat","text":"vcat(D::Drawing...; halign=:left, vpad=0, clip=true)\n\nCreates a new SVG drawing by vertical concatenation of SVG drawings. If drawings have different widths, the halign option can be used in order to define how to align. The vpad argument can be used to add padding between concatenated images.\n\nThe clip argument is a boolean for whether the concatenated images should be clipped before concatenation. Note that drawings sometimes have elements that go beyond it's margins, and they only show when the image is drawn in a larger canvas. The clip argument ensures that these elements are not drawn in the concatenated drawing.\n\nExample:\n\nd1 = Drawing(200, 100, :svg)\norigin()\ncircle(O, 60, :fill)\nfinish()\n\nd2 = Drawing(200, 200, :svg)\nrect(O, 200, 200, :fill)\nfinish()\nvcat(d1, d2; vpad = 10, halign = :left, clip = true)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.Circle","page":"Function reference","title":"Luxor.Circle","text":"Circle(t::Turtle, radius=1.0)\n\nDraw a filled circle centered at the current position with the given radius.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.Forward","page":"Function reference","title":"Luxor.Forward","text":"Forward(t::Turtle, d=1)\n\nMove the turtle forward by d units. The stored position is updated.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.HueShift","page":"Function reference","title":"Luxor.HueShift","text":"HueShift(t::Turtle, inc=1.0)\n\nShift the Hue of the turtle's pen forward by inc. Hue values range between 0 and 360. (Don't start with black, otherwise the saturation and brightness values will be black.)\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.Message-Tuple{Turtle, Any}","page":"Function reference","title":"Luxor.Message","text":"Message(t::Turtle, txt)\n\nWrite some text at the current position.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.Orientation","page":"Function reference","title":"Luxor.Orientation","text":"Orientation(t::Turtle, r=0.0)\n\nSet the turtle's orientation to r degrees. See also Turn.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.Pen_opacity_random-Tuple{Turtle}","page":"Function reference","title":"Luxor.Pen_opacity_random","text":"Pen_opacity_random(t::Turtle)\n\nChange the opacity of the pen to some value at random.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.Pencolor-Tuple{Turtle, Any, Any, Any}","page":"Function reference","title":"Luxor.Pencolor","text":"Pencolor(t::Turtle, r, g, b)\n\nSet the Red, Green, and Blue colors of the turtle.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.Pendown-Tuple{Turtle}","page":"Function reference","title":"Luxor.Pendown","text":"Pendown(t::Turtle)\n\nPut that pen down and start drawing.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.Penup-Tuple{Turtle}","page":"Function reference","title":"Luxor.Penup","text":"Penup(t::Turtle)\n\nPick that pen up and stop drawing.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.Penwidth-Tuple{Turtle, Any}","page":"Function reference","title":"Luxor.Penwidth","text":"Penwidth(t::Turtle, w)\n\nSet the width of the line drawn.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.Pop-Tuple{Turtle}","page":"Function reference","title":"Luxor.Pop","text":"Pop(t::Turtle)\n\nLift the turtle's position and orientation off a stack.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.Push-Tuple{Turtle}","page":"Function reference","title":"Luxor.Push","text":"Push(t::Turtle)\n\nSave the turtle's position and orientation on a stack.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.Randomize_saturation-Tuple{Turtle}","page":"Function reference","title":"Luxor.Randomize_saturation","text":"Randomize_saturation(t::Turtle)\n\nRandomize the saturation of the turtle's pen color.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.Rectangle","page":"Function reference","title":"Luxor.Rectangle","text":"Rectangle(t::Turtle, width=10.0, height=10.0)\n\nDraw a filled rectangle centered at the current position with the given radius.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.Reposition-Tuple{Turtle, Any, Any}","page":"Function reference","title":"Luxor.Reposition","text":"Reposition(t::Turtle, pos::Point)\nReposition(t::Turtle, x, y)\n\nReposition: pick the turtle up and place it at another position.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.Towards-Tuple{Turtle, Point}","page":"Function reference","title":"Luxor.Towards","text":"Towards(t::Turtle, pos::Point)\n\nRotate the turtle to face towards a given point.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.Turn","page":"Function reference","title":"Luxor.Turn","text":"Turn(t::Turtle, r=5.0)\n\nIncrease the turtle's rotation by r degrees. See also Orientation.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor._adjust_background_rects-Tuple{Any}","page":"Function reference","title":"Luxor._adjust_background_rects","text":"_adjust_background_rects(buffer::UInt8[]; addmarker = true)\n\nSee issue  https://github.com/JuliaGraphics/Luxor.jl/issues/150 for discussion details.\n Setting backgrounds in a recording surface (:rec) and creating a svg from it result in elements as\n\n<rect x=\"0\" y=\"0\" width=\"16777215\" height=\"16777215\" .../>\n\nindependent of an existing transformation matrix (e.g. set with origin(...) or snapshot with a crop bounding box).\nAn existing transformation matrix manifests in the svg file as\n\n<use xlink:href=\"#surface199\" transform=\"matrix(3 1 -1 3 30 40)\"/>\n\nwhich is applied to every element including the background rects.\nThis transformation needs to be inversed for the background rects which is added in this function.\n\nIf addmarker is not set to false, a class property is set as marker:\n\n<rect class=\"luxor_adjusted\" x=\"0\" y=\"0\" width=\"16777215\" height=\"16777215\" .../>\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor._betweenpoly-Tuple{Any, Any, Any}","page":"Function reference","title":"Luxor._betweenpoly","text":"_betweenpoly(loop1, loop2, k;\n    samples = 100,\n    easingfunction = easingflat)\n\nFind a simple polygon between the two simple polygons loop1 and loop2 corresponding to k, where 0.0 < k < 1.0.\n\nBy default, easingfunction = easingflat, so the intermediate steps are linearly spaced. If you use another easing function, intermediate steps are determined by the value of the easing function at k.\n\nUsed by polymorph().\n\nBecause polysample() can treat the polygon as open or closed (with different results), you can specify how the sampling is done here, with the closed= keyword:\n\nclosed = true -> polygons are sampled as closed\nclosed = false -> polygons are sampled as open\nclosed = (true, false) -> first polygon is sampled as closed, second as open\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor._drawing_indices-Tuple{}","page":"Function reference","title":"Luxor._drawing_indices","text":"Luxor._drawing_indices()\n\nGet a UnitRange over all available indices of drawings.\n\nWith Luxor you can work on multiple drawings simultaneously. Each drawing is stored in an internal array. The first drawing is stored at index 1 when you start a drawing with Drawing(...). To start a second drawing you call Luxor._set_next_drawing_index(), which returns the new index. Calling another Drawing(...) stores the second drawing at this new index. Luxor._set_next_drawing_index() will return and set the next available index which is available for a new drawing. This can be a new index at the end of drawings, or, if you already finished a drawing with finish(), the index of this finished drawing. To specify on which drawing the next graphics command should be applied you call Luxor._set_drawing_index(i). All successive Luxor commands work on this drawing. With Luxor._get_drawing_index() you get the current active drawing index.\n\nMultiple drawings is especially helpful for interactive graphics with live windows like MiniFB.\n\nExample:\n\nusing Luxor\nDrawing(500, 500, \"1.svg\")\norigin()\nsetcolor(\"red\")\ncircle(Point(0, 0), 100, action = :fill)\n\nLuxor._drawing_indices()               # returns 1:1\n\nLuxor._get_next_drawing_index()        # returns 2 but doesn't change current drawing\nLuxor._set_next_drawing_index()        # returns 2 and sets current drawing to it\nDrawing(500, 500, \"2.svg\")\norigin()\nsetcolor(\"green\")\ncircle(Point(0, 0), 100, action = :fill)\n\nLuxor._drawing_indices()               # returns 1:2\nLuxor._set_drawing_index(1)            # returns 1\n\nfinish()\npreview()                             # presents the red circle 1.svg\n\nLuxor._drawing_indices()               # returns 1:2\nLuxor._set_next_drawing_index()        # returns 1 because drawing 1 was finished before\n\nDrawing(500, 500, \"3.svg\")\norigin()\nsetcolor(\"blue\")\ncircle(Point(0, 0), 100, action = :fill)\n\nfinish()\npreview()                             # presents the blue circle 3.svg\n\nLuxor._set_drawing_index(2)            # returns 2\nfinish()\npreview()                             # presents the green circle 2.svg\n\nLuxor._drawing_indices()               # returns 1:2, but all are finished\nLuxor._set_drawing_index(1)            # returns 1\n\npreview()                             # presents the blue circle 3.svg again\n\nLuxor._set_drawing_index(10)           # returns 1 as 10 does not existing    \nLuxor._get_drawing_index()             # returns 1\nLuxor._get_next_drawing_index()        # returns 1, because 1 was finished\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor._empty_neighbourhood-Tuple{Point, Any, Any, Any, Any, Vector{Point}, Any}","page":"Function reference","title":"Luxor._empty_neighbourhood","text":"emptyneighbourhood(sample, w, h, cellsize, d, points, grid)\n\nUses entries in grid to check whether the sample point is more than d units away from any other point in points.\n\nThe region we're analyzing lies between the origin and Point(w, h)`.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor._get_drawing_index-Tuple{}","page":"Function reference","title":"Luxor._get_drawing_index","text":"Luxor._get_drawing_index()\n\nReturns the index of the current drawing. If there isn't any drawing yet returns 1.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor._get_next_drawing_index-Tuple{}","page":"Function reference","title":"Luxor._get_next_drawing_index","text":"Luxor._get_next_drawing_index()\n\nReturns the next available drawing index. This can either be a new index or an existing index where a finished (finish()) drawing was stored before.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor._has_drawing-Tuple{}","page":"Function reference","title":"Luxor._has_drawing","text":"Luxor._has_drawing()\n\nReturns true if there is a current drawing available or finished, otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor._set_drawing_index-Tuple{Int64}","page":"Function reference","title":"Luxor._set_drawing_index","text":"Luxor._set_drawing_index(i::Int)\n\nSet the active drawing for successive graphic commands to index i if exist. if index i doesn't exist, the current drawing is unchanged.\n\nReturns the current drawing index.\n\nExample:\n\nnext_index=5\nif Luxor._set_drawing_index(next_index) == next_index\n    # do some additional graphics on the existing drawing\n    ...\nelse\n    @warn \"Drawing \"*string(next_index)*\" doesn't exist\"\nendif\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor._set_next_drawing_index-Tuple{}","page":"Function reference","title":"Luxor._set_next_drawing_index","text":"Luxor._set_next_drawing_index()\n\nSet the current drawing to the next available drawing index. This can either be a new index or an existing index where a finished (finish()) drawing was stored before.\n\nReturns the current drawing index.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor._split_string_into_head_mid_tail-Tuple{Any, Any}","page":"Function reference","title":"Luxor._split_string_into_head_mid_tail","text":"_split_string_into_head_mid_tail(s::String,id::String)\n\nsplits s into head, mid and tail string.\nExample:\n\n\n  s=\"head...<g id=\"\\$id\">...</g>...tail\"\n\nresults in\n\n\n  head=\"head...\"\n  mid=\"<g id=\"\\$id\">...</g>\"\n  tail=\"...tail\"\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.add_mesh_patch","page":"Function reference","title":"Luxor.add_mesh_patch","text":"add_mesh_patch(pattern::Mesh, bezierpath::BezierPath,\n    colors=Array{Colors.Colorant, 1})\n\nAdd a new patch to the mesh pattern in pattern.\n\nThe first three or four elements of the supplied bezierpath define the three or four sides of the mesh shape.\n\nThe colors array define the color of each corner point. Colors are reused if necessary. At least one color should be supplied.\n\nUse setmesh() to select the mesh, which will be used to fill shapes.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.add_mesh_patch-2","page":"Function reference","title":"Luxor.add_mesh_patch","text":"add_mesh_patch(pattern::Mesh, plist::Array{Point}, colors=Array{Colors.Colorant, 1})\n\nAdd a new patch to the mesh pattern in pattern.\n\nThe first three or four sides of the supplied points polygon define the three or four sides of the mesh shape.\n\nThe colors array define the color of each corner point. Colors are reused if necessary. At least one color should be supplied.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.addstop-Tuple{Cairo.CairoPattern, Any, ColorTypes.Colorant}","page":"Function reference","title":"Luxor.addstop","text":"addstop(b::Blend, offset, col)\naddstop(b::Blend, offset, (r, g, b, a))\naddstop(b::Blend, offset, string)\n\nAdd a color stop to a blend. The offset specifies the location along the blend's 'control vector', which varies between 0 (beginning of the blend) and 1 (end of the blend). For linear blends, the control vector is from the start point to the end point. For radial blends, the control vector is from any point on the start circle, to the corresponding point on the end circle.\n\nExamples:\n\nblendredblue = blend(Point(0, 0), 0, Point(0, 0), 1)\naddstop(blendredblue, 0, setcolor(sethue(\"red\")..., .2))\naddstop(blendredblue, 1, setcolor(sethue(\"blue\")..., .2))\naddstop(blendredblue, 0.5, sethue(randomhue()...))\naddstop(blendredblue, 0.5, setcolor(randomcolor()...))\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.anglethreepoints-Tuple{Point, Point, Point}","page":"Function reference","title":"Luxor.anglethreepoints","text":"anglethreepoints(p1::Point, p2::Point, p3::Point)\n\nFind the angle formed by two lines defined by three points.\n\nIf the angle is less than π, the line heads to the left.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.animate-Tuple{Movie, Scene}","page":"Function reference","title":"Luxor.animate","text":"animate(movie::Movie, scene::Scene; creategif=false, framerate=30)\n\nCreate the movie defined in movie by rendering the frames define in scene.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.animate-Tuple{Movie, Vector{Scene}}","page":"Function reference","title":"Luxor.animate","text":"animate(movie::Movie, scenelist::Array{Scene, 1};\n    creategif=false,\n    framerate=30,\n    pathname=\"\",\n    tempdirectory=\"\",\n    usenewffmpeg=true)\n\nCreate the movie defined in movie by rendering the frames define in the array of scenes in scenelist.\n\nIf creategif is true, the function attempts to call the ffmpeg utility on the resulting frames to build a GIF animation. This will be stored in pathname (an existing file will be overwritten; use a \".gif\" suffix), or in (movietitle).gif in a temporary directory. ffmpeg should be installed and available, of course, if this is to work.\n\nIn suitable environments, the resulting animation is displayed in the Plots window.\n\nExample\n\nanimate(bang, [\n    Scene(bang, backdrop, 0:200),\n    Scene(bang, frame1, 0:200, easingfunction=easeinsine)],\n    creategif=true,\n    pathname=\"/tmp/animationtest.gif\")\n\nThe usenewffmpeg option, true by default, uses single-pass palette generation and more complex filtering provided by recent versions of the ffmpeg utility, mainly to cope with transparent backgrounds. If set to false, the behavior is the same as in previous versions of Luxor.\n\nIf you prefer to use the FFMPEG package, use code such as this:\n\nusing FFMPEG\n\n...\n\ntempdirectory = \"/tmp/temp/\"\n\nanimate(movie, [\n        Scene(movie, frame, 1:50)\n    ], creategif=false, tempdirectory=tempdirectory)\n\nFFMPEG.ffmpeg_exe(`-r 30 -f image2 -i $(tempdirectory)/%10d.png -c:v libx264 -r 30 -pix_fmt yuv420p -y /tmp/animation.mp4`)\n\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.arc-Tuple{Point, Any, Any, Any}","page":"Function reference","title":"Luxor.arc","text":"arc(centerpoint::Point, radius, angle1, angle2; action=:none)\narc(centerpoint::Point, radius, angle1, angle2, action)\n\nAdd an arc to the current path from angle1 to angle2 going clockwise, centered at centerpoint.\n\nAngles are defined relative to the x-axis, positive clockwise.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.arc2r-Tuple{Point, Point, Point}","page":"Function reference","title":"Luxor.arc2r","text":"  arc2r(c1::Point, p2::Point, p3::Point; action=:none)\n  arc2r(c1::Point, p2::Point, p3::Point, action)\n\nAdd a circular arc centered at c1 that starts at p2 and ends at p3, going clockwise, to the current path.\n\nc1-p2 really determines the radius. If p3 doesn't lie on the circular path,  it will be used only as an indication of the arc's length, rather than its position.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.arc2sagitta-Tuple{Point, Point, Real}","page":"Function reference","title":"Luxor.arc2sagitta","text":"arc2sagitta(p1::Point, p2::Point, s;\n    action=:none)\n\nMake a clockwise arc starting at p1 and ending at p2 that reaches a height of s, the sagitta, at the middle, and add it to the current path.\n\nReturn tuple of the center point and the radius of the arc.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.arrow","page":"Function reference","title":"Luxor.arrow","text":"arrow(start::Point, finish::Point, height::Vector, action=:stroke;\n    keyword arguments...)\n\nDraw a Bézier arrow between start and finish, with control points defined to fit in an imaginary box defined by the two supplied height values (see bezierfrompoints()). If the height values are different signs, the arrow will change direction on its way.\n\nKeyword arguments are the same as arrow(pt1, pt2, pt3, pt4).\n\nExample\n\narrow(pts[1], pts[end], [15, 15],\n    decoration = 0.5,\n    decorate = () -> text(string(pts[1])))\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.arrow-2","page":"Function reference","title":"Luxor.arrow","text":"arrow(start::Point, C1::Point, C2::Point, finish::Point, action=:stroke;\n    linewidth       = 1.0,\n    arrowheadlength = 10,\n    arrowheadangle  = pi/8,\n    startarrow      = false,\n    finisharrow     = true,\n    decoration      = 0.5,\n    decorate        = nothing\n    arrowheadfunction = nothing)\n\nDraw a Bezier curved arrow, from start to finish, with control points C1 and C2. Arrow heads can be added/hidden by changing startarrow and finisharrow options.\n\nThe decorate keyword argument accepts a function that can execute code at one or more locations on the arrow's shaft. The inherited graphic environment is centered at each point on the shaft given by scalar or vector decoration, and the x-axis is aligned with the direction of the curve at that point.\n\nExample\n\nThis code draws an arrow head that's filled with orange and outlined in green.\n\nfunction myarrowheadfunction(originalendpoint, newendpoint, shaftangle)\n    @layer begin\n        setline(5)\n        translate(newendpoint)\n        rotate(shaftangle)\n        sethue(\"orange\")\n        ngon(O, 20, 3, 0, :fill)\n        sethue(\"green\")\n        ngon(O, 20, 3, 0, :stroke)\n    end\nend\n\n@drawsvg begin\n    background(\"white\")\n    arrow(O, 220, 0, π,\n        linewidth=10,\n        arrowheadlength=30,\n        arrowheadangle=π/7,\n        clockwise=true,\n        arrowheadfunction = myarrowheadfunction)\nend\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.arrow-Tuple{Point, Any, Any, Any}","page":"Function reference","title":"Luxor.arrow","text":"arrow(centerpos::Point, radius, startangle, endangle;\n    linewidth          = 1.0,\n    arrowheadlength    = 10,\n    arrowheadangle     = π/8,\n    decoration         = 0.5,\n    decorate           = nothing,\n    arrowheadfunction  = nothing,\n    clockwise          = true)\n\nDraw a curved arrow, an arc centered at centerpos starting at startangle and ending at endangle with an arrowhead at the end. Angles are measured clockwise from the positive x-axis.\n\nArrows don't use the current linewidth setting (setline()); you can specify the linewidth.\n\nThe decorate keyword argument accepts a zero-argument function that can execute code at one or more locations on the arrow's shaft. The inherited graphic environment is centered at points on the shaft between 0 and 1 given by scalar or vector decoration, and the x-axis is aligned with the direction of the curve at that point.\n\nA triangular arrowhead is drawn by default. But you can pass a function to the arrowheadfunction keyword argument that accepts three arguments: the shaft end, the arrow head end, and the shaft angle. Thsi allows you to draw any shape arrowhead.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.arrow-Tuple{Point, Point}","page":"Function reference","title":"Luxor.arrow","text":"arrow(startpoint::Point, endpoint::Point;\n    linewidth         = 1.0,\n    arrowheadlength   = 10,\n    arrowheadangle    = pi/8,\n    decoration        = 0.5 or range(),\n    decorate          = nothing,\n    arrowheadfunction = nothing)\n\nDraw a line between two points and add an arrowhead at the end. The arrowhead length will be the length of the side of the arrow's head, and the arrowhead angle is the angle between the sloping side of the arrowhead and the arrow's shaft.\n\nArrows don't use the current linewidth setting (setline()), and defaults to 1, but you can specify another value. It doesn't need stroking/filling, the shaft is stroked and the head filled with the current color.\n\nDecoration\n\nThe decorate keyword argument accepts a function with zero arguments that can execute code at one or more locations on the arrow's shaft. The inherited graphic environment is centered at each point on the shaft between 0 and 1 given by scalar or vector decoration, and the x-axis is aligned with the direction of the curve at that point.\n\nArrowheads\n\nA triangular arrowhead is drawn by default. But you can pass a function to the arrowheadfunction keyword argument that accepts three arguments: the shaft end, the arrow head end, and the shaft angle. Thsi allows you to draw any shape arrowhead.\n\nExample\n\nfunction redbluearrow(shaftendpoint, endpoint, shaftangle)\n    @layer begin\n        sethue(\"red\")\n        sidept1 = shaftendpoint  + polar(10, shaftangle + π/2 )\n        sidept2 = shaftendpoint  - polar(10, shaftangle + π/2)\n        poly([sidept1, endpoint, sidept2], :fill)\n        sethue(\"blue\")\n        poly([sidept1, endpoint, sidept2], :stroke, close=false)\n    end\nend\n\n@drawsvg begin\n    background(\"white\")\n    arrow(O, O + (120, 120),\n        linewidth=4,\n        arrowheadlength=40,\n        arrowheadangle=π/7,\n        arrowheadfunction = redbluearrow)\n\n    arrow(O, 100, 3π/2, π,\n        linewidth=4,\n        arrowheadlength=20,\n        clockwise=false,arrowheadfunction=redbluearrow)\nend 800 250\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.arrowhead","page":"Function reference","title":"Luxor.arrowhead","text":"arrowhead(target[, action=:fill];\n    shaftangle=0,\n    headlength=10,\n    headangle=pi/8)\n\nDraw an arrow head. The arrowhead length will be the length of the side of the arrow's head, and the arrowhead angle is the angle between the sloping side of the arrowhead and the arrow's shaft.\n\nThis doesn't use the current linewidth setting (setline()), and defaults to 1, but you can specify another value.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.background-Tuple{ColorTypes.Colorant}","page":"Function reference","title":"Luxor.background","text":"background(color)\n\nFill the canvas with a single color. Returns the (red, green, blue, alpha) values.\n\nExamples:\n\nbackground(\"antiquewhite\")\nbackground(1, 0.0, 1.0)\nbackground(1, 0.0, 1.0, .5)\nbackground(Luxor.Colors.RGB(0, 1, 0))\n\nIf Colors.jl has been imported:\n\nbackground(RGB(0, 1, 0))\nbackground(RGBA(0, 1, 0))\nbackground(RGBA(0, 1, 0, .5))\nbackground(Luv(20, -20, 30))\n\nIf you don't specify a background color for a PNG drawing, the background will be transparent. You can set a partly or completely transparent background for PNG files by passing a color with an alpha value, such as this 'transparent black':\n\nbackground(RGBA(0, 0, 0, 0))\n\nor\n\nbackground(0, 0, 0, 0)\n\nReturns a tuple (r, g, b, a) of the color that was used to paint the background.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.barchart-Tuple{Any}","page":"Function reference","title":"Luxor.barchart","text":"barchart(values;\n        boundingbox = BoundingBox(O + (-250, -120), O + (250, 120)),\n        bargap=10,\n        margin = 5,\n        border=false,\n        labels=false,\n        labelfunction = (values, i, lowpos, highpos, barwidth, scaledvalue) -> begin\n                label(string(values[i]), :n, highpos, offset=10)\n          end,\n        barfunction =  (values, i, lowpos, highpos, barwidth, scaledvalue) -> begin\n            @layer begin\n                setline(barwidth)\n                line(lowpos, highpos, :stroke)\n            end\n          end)\n\nDraw a barchart where each bar is the height of a value in the values array. The bars will be scaled to fit in a bounding box.\n\nText labels are drawn if the keyword labels=true.\n\nExtended help\n\nThe function returns a vector of points; each is the bottom center of a bar.\n\nDraw a Fibonacci sequence as a barchart:\n\nfib(n) = n > 2 ? fib(n - 1) + fib(n - 2) : 1\nfibs = fib.(1:15)\n@draw begin\n    fontsize(12)\n    barchart(fibs, labels=true)\nend\n\nTo control the drawing of the text and bars, define functions that process the end points:\n\nmybarfunction(values, i, lowpos, highpos, barwidth, scaledvalue)\n\nmylabelfunction(values, i, lowpos, highpos, barwidth, scaledvalue)\n\nand pass them like this:\n\nbarchart(vals, barfunction=mybarfunction)\nbarchart(vals, labelfunction=mylabelfunction)\n\nfunction myprologfunction(values, basepoint, minbarrange, maxbarrange, barchartheight)\n    @layer begin\n        setline(0.2)\n        for i in 0:10:maximum(values)\n            rule(boxbottomcenter(basepoint) + (0, -(rescale(i, minbarrange, maxbarrange) * barchartheight)))\n        end\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.between","page":"Function reference","title":"Luxor.between","text":"between(bb::BoundingBox, x)\n\nFind a point between the two corners of a BoundingBox corresponding to x, where x is typically between 0 and 1.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.between-Tuple{Point, Point, Any}","page":"Function reference","title":"Luxor.between","text":"between(p1::Point, p2::Point, x)\nbetween((p1::Point, p2::Point), x)\n\nFind the point between point p1 and point p2 for x, where x is typically between 0 and 1. between(p1, p2, 0.5) is equivalent to midpoint(p1, p2).\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.bezier-Tuple{Any, Point, Point, Point, Point}","page":"Function reference","title":"Luxor.bezier","text":"bezier(t, A::Point, A1::Point, B1::Point, B::Point)\n\nReturn the result of evaluating the Bézier cubic curve function, t going from 0 to 1, starting at A, finishing at B, control points A1 (controlling A), and B1 (controlling B).\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.beziercurvature-Tuple{Any, Point, Point, Point, Point}","page":"Function reference","title":"Luxor.beziercurvature","text":"beziercurvature(t, A::Point, A1::Point, B1::Point, B::Point)\n\nReturn the curvature of the Bézier curve at t ([0-1]), given start and end points A and B, and control points A1 and B1. The value (kappa) will typically be a value between -0.001 and 0.001 for points with coordinates in the 100-500 range.\n\nκ(t) is the curvature of the curve at point t, which for a parametric planar curve is:\n\nbeginequation\nkappa = fracmid dotxddoty-dotyddotxmid\n    (dotx^2 + doty^2)^frac32\nendequation\n\nThe radius of curvature, or the radius of an osculating circle at a point, is 1/κ(t). Values of 1/κ will typically be in the range -1000 to 1000 for points with coordinates in the 100-500 range.\n\nTODO Fix overshoot...\n\n...The value of kappa can sometimes collapse near 0, returning NaN (and Inf for radius of curvature).\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.bezierfrompoints-NTuple{4, Point}","page":"Function reference","title":"Luxor.bezierfrompoints","text":"bezierfrompoints(startpoint::Point,\n    pointonline1::Point,\n    pointonline2::Point,\n    endpoint::Point)\n\nGiven four points, return the Bézier curve that passes through all four points, starting at startpoint and ending at endpoint. The two middle points of the returned BezierPathSegment are the two control points that make the curve pass through the two middle points supplied.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.bezierfrompoints-Tuple{Vector{Point}}","page":"Function reference","title":"Luxor.bezierfrompoints","text":"bezierfrompoints(ptslist::Array{Point, 1})\n\nGiven four points, return the Bézier curve that passes through all four points.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.bezierpathtopath-Tuple{BezierPath}","page":"Function reference","title":"Luxor.bezierpathtopath","text":"bezierpathtopath(bp::BezierPath)\n\nConvert a Bezier path to a Path object.\n\n@draw drawpath(polytopath(ngon(O, 145, 5, vertices = true)), action = :fill)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.bezierpathtopoly-Tuple{BezierPath}","page":"Function reference","title":"Luxor.bezierpathtopoly","text":"bezierpathtopoly(bezierpath::BezierPath;\n    steps=10)\n\nConvert a Bézier path (an array of BezierPathSegments, where each is a tuple of four points: anchor1, control1, control2, anchor2), to a polygon.\n\nTo make a Bézier path, use makebezierpath() on a polygon.\n\nThe steps optional keyword determines how many straight line sections are used for each path.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.beziersegmentangles-Tuple{Any, Any}","page":"Function reference","title":"Luxor.beziersegmentangles","text":"beziersegmentangles(pt1, pt2;\n    out = deg2rad(45),\n    in  = deg2rad(135),\n    l   = 100)\n\nReturn a BezierPathSegment joining pt1 and pt2 making the angles out at the start and in at the end.\n\nIt's similar to the tikZ (a) to [out=135, in=45] (b) drawing instruction (but in radians obviously).\n\nout is the angle that a line from pt1 to the outgoing Bézier handle makes with the horizontal. in is the angle that a line joining pt2 from the preceding Bézier handle makes with the horizontal.\n\nThe function finds the interesction point of two lines with the two angles and constructs a BezierPathSegment that fits.\n\nSee also the bezierfrompoints() function that makes a BezierPathSegment that passes through four points.\n\nExample\n\ndrawbezierpath(beziersegmentangles(O, O + (100, 0),\n    out = deg2rad(45),\n    in  = 2π - deg2rad(45)),\n    :stroke)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.bezierstroke","page":"Function reference","title":"Luxor.bezierstroke","text":"bezierstroke(point1, point2, width=0.0)\n\nReturn a BezierPath, a stroked version of a straight line between two points.\n\nIt wil have 2 or 6 Bezier path segments that define a brush or pen shape. If width is 0, the brush shape starts and ends at a point. Otherwise the brush shape starts and ends with the thick end.\n\nTo draw it, use eg drawbezierpath(..., :fill).\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.beziertopoly-Tuple{BezierPathSegment}","page":"Function reference","title":"Luxor.beziertopoly","text":"beziertopoly(bpseg::BezierPathSegment;\n    steps=10)\n\nConvert a BezierPathsegment to a polygon (an array of points).\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.bezier′-NTuple{5, Any}","page":"Function reference","title":"Luxor.bezier′","text":"bezier′(t, A::Point, A1::Point, B1::Point, B::Point)\n\nReturn the first derivative of the Bézier function.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.bezier′′-NTuple{5, Any}","page":"Function reference","title":"Luxor.bezier′′","text":"bezier′′(t, A::Point, A1::Point, B1::Point, B::Point)\n\nReturn the second derivative of Bézier function.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.bezigon-Tuple{Vector{Point}, Any}","page":"Function reference","title":"Luxor.bezigon","text":"bezigon(pts::Array{Point,1}, sides;\n    close = false,\n    action = :none))\n\nConstruct a bezigon, a path made of Bezier curves.\n\ncorners is an array of points, the corners of the bezigon, eg this triangle:\n\n[Point(0, 0), Point(50, 50), Point(100, 0)]\n\nsides is an array of arrays of points, where each array contains two control points, eg:\n\n    sides = [\n        [Point(-10, -20), Point(40, -120)], # control points for first side\n        [Point(120, -120), Point(180, -20)],\n    ]\n\nThe first pair of sides (two points) are control points, which combine with the first two points in corners to define a Bezier curve. And so on for the next pair.\n\nReturns a path.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.blend-Tuple{Point, Any, Point, Any, Any, Any}","page":"Function reference","title":"Luxor.blend","text":"blend(centerpos1, rad1, centerpos2, rad2, color1, color2)\n\nCreate a radial blend.\n\nExample:\n\nredblue = blend(\n    pos, 0,                   # first circle center and radius\n    pos, tiles.tilewidth/2,   # second circle center and radius\n    \"red\",\n    \"blue\"\n    )\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.blend-Tuple{Point, Any, Point, Any}","page":"Function reference","title":"Luxor.blend","text":"blend(from::Point, startradius, to::Point, endradius)\n\nCreate an empty radial blend.\n\nRadial blends are defined by two circles that define the start and stop locations. The first point is the center of the start circle, the first radius is the radius of the first circle.\n\nA new blend is empty. To add colors, use addstop().\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.blend-Tuple{Point, Point, Any, Any}","page":"Function reference","title":"Luxor.blend","text":"blend(pt1::Point, pt2::Point, color1, color2)\n\nCreate a linear blend.\n\nExample:\n\nredblue = blend(pos, pos, \"red\", \"blue\")\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.blend-Tuple{Point, Point}","page":"Function reference","title":"Luxor.blend","text":"blend(from::Point, to::Point)\n\nCreate an empty linear blend.\n\nA blend is a specification of how one color changes into another. Linear blends are defined by two points: parallel lines through these points define the start and stop locations of the blend. The blend is defined relative to the current axes origin. This means that you should be aware of the current axes when you define blends, and when you use them.\n\nTo add colors, use addstop().\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.blendadjust","page":"Function reference","title":"Luxor.blendadjust","text":"blendadjust(ablend, center::Point, xscale, yscale, rot=0)\n\nModify an existing blend by scaling, translating, and rotating it so that it will fill a shape properly even if the position of the shape is nowhere near the original location of the blend's definition.\n\nFor example, if your blend definition was this (notice the 1)\n\nblendgoldmagenta = blend(\n        Point(0, 0), 0,                   # first circle center and radius\n        Point(0, 0), 1,                   # second circle center and radius\n        \"gold\",\n        \"magenta\"\n        )\n\nyou can use it in a shape that's 100 units across and centered at pos, by calling this:\n\nblendadjust(blendgoldmagenta, Point(pos.x, pos.y), 100, 100)\n\nthen use setblend():\n\nsetblend(blendgoldmagenta)\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.blendmatrix-Tuple{Cairo.CairoPattern, Any}","page":"Function reference","title":"Luxor.blendmatrix","text":"blendmatrix(b::Blend, m)\n\nSet the matrix of a blend.\n\nTo apply a sequence of matrix transforms to a blend:\n\nA = [1 0 0 1 0 0]\nAj = cairotojuliamatrix(A)\nSj = scalingmatrix(2, .2) * Aj\nTj = translationmatrix(10, 0) * Sj\nA1 = juliatocairomatrix(Tj)\nblendmatrix(b, As)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.boundingboxesintersect-NTuple{4, Point}","page":"Function reference","title":"Luxor.boundingboxesintersect","text":"boundingboxesintersect(bbox1::BoundingBox, bbox2::BoundingBox)\nboundingboxesintersect(acorner1::Point, acorner2::Point, bcorner1::Point, bcorner2::Point)\n\nReturn true if the two bounding boxes intersect.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.box-Tuple{Array, Symbol}","page":"Function reference","title":"Luxor.box","text":"box(points::Array; action=:none,\n    reversepath=reversepath,\n    vertices=vertices)\nbox(points::Array; action=:none,\n    reversepath=reversepath,\n    vertices=vertices)\n\nCreate a box/rectangle using the first two points of an array of Points to defined opposite corners, and add it to the current path. Then apply action.\n\nUse vertices=true to return an array of the four corner points: bottom left, top left, top right, bottom right rather than execute action.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.box-Tuple{BoundingBox, Array}","page":"Function reference","title":"Luxor.box","text":"box(bbox::BoundingBox, cornerradii::Array;\n    action = :none)\n\nMake a box that is the size of the BoundingBox bbox with curved corners.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.box-Tuple{BoundingBox, Real}","page":"Function reference","title":"Luxor.box","text":"box(bbox::BoundingBox, cornerradius::Real;\n    action = :none)\n\nMake a box that is the size of the BoundingBox bbox with curved corners.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.box-Tuple{BoundingBox}","page":"Function reference","title":"Luxor.box","text":"box(bbox::BoundingBox;\n    action   = :none,\n    vertices = false)\nbox(bbox::BoundingBox, action::Symbol;\n    vertices=false)\n\nDefine a box using the bounds in bbox.\n\nUse vertices = true to return an array of the four corner points: bottom left, top left, top right, bottom right.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.box-Tuple{BoxmapTile, Symbol}","page":"Function reference","title":"Luxor.box","text":"box(tile::BoxmapTile, action::Symbol=:none; vertices=false)\nbox(tile::BoxmapTile, action=:none, vertices=false)\n\nUse a Boxmaptile to make or draw a rectangular box. Use vertices=true to obtain the coordinates.\n\nCreate boxmaps using boxmap().\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.box-Tuple{Point, Any, Any, Array}","page":"Function reference","title":"Luxor.box","text":"box(pt, width, height, cornerradii::Array; action=:none)\nbox(pt, width, height, cornerradii::Array, action=:none)\n\nDraw a box/rectangle centered at point pt with width and height and round each corner by the corresponding value in the array cornerradii.\n\nThe constructed path consists of arcs and straight lines.\n\nThe first corner is the one at the bottom left, the second at the top left, and so on.\n\nExample\n\n@draw begin\n    box(O, 120, 120, [0, 20, 40, 60], :fill)\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.box-Tuple{Point, Any, Any, Real, Symbol}","page":"Function reference","title":"Luxor.box","text":"box(pt, width, height, cornerradius, action=:none)\nbox(pt, width, height, cornerradius; action=:none)\n\nDraw a box/rectangle centered at point pt with width and height and round each corner by cornerradius.\n\nThe constructed path consists of arcs and straight lines.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.box-Tuple{Point, Any, Any}","page":"Function reference","title":"Luxor.box","text":"box(pt::Point, width, height; action=:none, vertices=false)\nbox(pt::Point, width, height, action=:none; vertices=false)\n\nCreate a box/rectangle centered at point pt with width and height. Use vertices=true to return an array of the four corner points rather than apply the action.\n\nreversepath reverses the direction of the path.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.box-Tuple{Point, Point}","page":"Function reference","title":"Luxor.box","text":"box(cornerpoint1, cornerpoint2; action=:none, vertices=false, reversepath=false)\nbox(cornerpoint1, cornerpoint2, action; vertices=false, reversepath=false)\n\nCreate a box (rectangle) between two points and add it to the current path. Then apply action.\n\nUse vertices=true to return an array of the four corner points: bottom left, top left, top right, bottom right rather than execute action.\n\nreversepath reverses the direction of the path (and returns points in the order: bottom left, bottom right, top right, top left).\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.box-Tuple{Table, Int64, Symbol}","page":"Function reference","title":"Luxor.box","text":"box(t::Table, cellnumber::Int, action::Symbol=:none; vertices=false)\nbox(t::Table, cellnumber::Int; action=:none, vertices=false)\n\nMake box around cell cellnumber in table t.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.box-Tuple{Table, Integer, Integer, Symbol}","page":"Function reference","title":"Luxor.box","text":"box(t::Table, r::Integer, c::Integer, action::Symbol)\nbox(t::Table, r::Integer, c::Integer; action=:none)\n\nDraw a box in table t at row r and column c.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.box-Tuple{Tiler, Integer}","page":"Function reference","title":"Luxor.box","text":"box(tiles::Tiler, n::Integer; action=:none, vertices=false, reversepath=false)\nbox(tiles::Tiler, n::Integer, action::Symbol=:none; vertices=false, reversepath=false)\n\nDraw a box in tile n of tiles tiles.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.boxaspectratio","page":"Function reference","title":"Luxor.boxaspectratio","text":"boxaspectratio(bb::BoundingBox=BoundingBox())\n\nReturn the aspect ratio (the height divided by the width) of bounding box bb.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.boxbottomcenter","page":"Function reference","title":"Luxor.boxbottomcenter","text":"boxbottomcenter(bb::BoundingBox=BoundingBox())\n\nReturn the point at the bottom center of the BoundingBox bb, defaulting to the drawing extent.\n\n⋅ ⋅ ⋅\n⋅ ⋅ ⋅\n⋅ ■ ⋅\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.boxbottomleft","page":"Function reference","title":"Luxor.boxbottomleft","text":"boxbottomleft(bb::BoundingBox=BoundingBox())\n\nReturn the point at the bottom left of the BoundingBox bb, defaulting to the drawing extent.\n\n⋅ ⋅ ⋅\n⋅ ⋅ ⋅\n■ ⋅ ⋅\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.boxbottomright","page":"Function reference","title":"Luxor.boxbottomright","text":"boxbottomright(bb::BoundingBox=BoundingBox())\n\nReturn the point at the bottom right of the BoundingBox bb, defaulting to the drawing extent.\n\n⋅ ⋅ ⋅\n⋅ ⋅ ⋅\n⋅ ⋅ ■\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.boxdiagonal","page":"Function reference","title":"Luxor.boxdiagonal","text":"boxdiagonal(bb::BoundingBox=BoundingBox())\n\nReturn the length of the diagonal of bounding box bb.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.boxheight","page":"Function reference","title":"Luxor.boxheight","text":"boxheight(bb::BoundingBox=BoundingBox())\n\nReturn the height of bounding box bb.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.boxmap-Tuple{Array, Point, Any, Any}","page":"Function reference","title":"Luxor.boxmap","text":"boxmap(A::Array, pt, w, h)\n\nBuild a box map of the values in A with one corner at pt and width w and height h. There are length(A) boxes. The areas of the boxes are proportional to the original values, scaled as necessary.\n\nThe return value is an array of BoxmapTiles. For example:\n\n[BoxmapTile(0.0, 0.0, 10.0, 20.0)\n BoxmapTile(10.0, 0.0, 10.0, 13.3333)\n BoxmapTile(10.0, 13.3333, 10.0, 6.66667)]\n\nwith each tile containing (x, y, w, h). box() and BoundingBox() can work with BoxmapTiles as well.\n\nExample\n\nusing Luxor\n@svg begin\n    fontsize(16)\n    fontface(\"HelveticaBold\")\n    pt = Point(-200, -200)\n    a = rand(10:200, 15)\n    tiles = boxmap(a, Point(-200, -200), 400, 400)\n    for (n, t) in enumerate(tiles)\n        randomhue()\n        bb = BoundingBox(t)\n        box(bb - 2, :stroke)\n        box(bb - 5, :fill)\n        sethue(\"white\")\n        text(string(n), midpoint(bb[1], bb[2]), halign=:center)\n    end\nend 400 400 \"boxmap.svg\"\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.boxmiddlecenter","page":"Function reference","title":"Luxor.boxmiddlecenter","text":"boxmiddlecenter(bb::BoundingBox=BoundingBox())\n\nReturn the point at the center of the BoundingBox bb, defaulting to the drawing extent.\n\n⋅ ⋅ ⋅\n⋅ ■ ⋅\n⋅ ⋅ ⋅\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.boxmiddleleft","page":"Function reference","title":"Luxor.boxmiddleleft","text":"boxmiddleleft(bb::BoundingBox=BoundingBox())\n\nReturn the point at the middle left of the BoundingBox bb, defaulting to the drawing extent.\n\n⋅ ⋅ ⋅\n■ ⋅ ⋅\n⋅ ⋅ ⋅\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.boxmiddleright","page":"Function reference","title":"Luxor.boxmiddleright","text":"boxmiddleright(bb::BoundingBox=BoundingBox())\n\nReturn the point at the midde right of the BoundingBox bb, defaulting to the drawing extent.\n\n⋅ ⋅ ⋅\n⋅ ⋅ ■\n⋅ ⋅ ⋅\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.boxtopcenter","page":"Function reference","title":"Luxor.boxtopcenter","text":"boxtopcenter(bb::BoundingBox=BoundingBox())\n\nReturn the point at the top center of the BoundingBox bb, defaulting to the drawing extent.\n\n⋅ ■ ⋅\n⋅ ⋅ ⋅\n⋅ ⋅ ⋅\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.boxtopleft","page":"Function reference","title":"Luxor.boxtopleft","text":"boxtopleft(bb::BoundingBox=BoundingBox())\n\nReturn the point at the top left of the BoundingBox bb, defaulting to the drawing extent.\n\n■ ⋅ ⋅\n⋅ ⋅ ⋅\n⋅ ⋅ ⋅\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.boxtopright","page":"Function reference","title":"Luxor.boxtopright","text":"boxtopright(bb::BoundingBox=BoundingBox())\n\nReturn the point at the top right of the BoundingBox bb, defaulting to the drawing extent.\n\n⋅ ⋅ ■\n⋅ ⋅ ⋅\n⋅ ⋅ ⋅\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.boxwidth","page":"Function reference","title":"Luxor.boxwidth","text":"boxwidth(bb::BoundingBox=BoundingBox())\n\nReturn the width of bounding box bb.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.brush","page":"Function reference","title":"Luxor.brush","text":"brush(pt1, pt2, width=10;\n    strokes=10,\n    minwidth=0.01,\n    maxwidth=0.03,\n    twist = -1,\n    lowhandle  = 0.3,\n    highhandle = 0.7,\n    randomopacity = true,\n    tidystart = false,\n    action = :fill,\n    strokefunction = (nbpb) -> nbpb))\n\nDraw a composite brush stroke made up of some randomized individual filled Bezier paths.\n\nstrokefunction allows a function to process a BezierPathSegment or do other things before it's drawn.\n\nnote: Note\nThere is a lot of randomness in this function. Results are unpredictable.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.buildcolumn-NTuple{5, Any}","page":"Function reference","title":"Luxor.buildcolumn","text":"buildcolumn(A, x, y, w, h)\n\nMake a column of tiles from A.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.buildrow-NTuple{5, Any}","page":"Function reference","title":"Luxor.buildrow","text":"buildrow(A, x, y, w, h)\n\nMake a row of tiles from A.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.cairotojuliamatrix-Tuple{Array}","page":"Function reference","title":"Luxor.cairotojuliamatrix","text":"cairotojuliamatrix(c)\n\nReturn a 3x3 Julia matrix that's the equivalent of the six-element matrix in c.\n\nSee getmatrix() for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.carc-Tuple{Point, Any, Any, Any}","page":"Function reference","title":"Luxor.carc","text":"carc(centerpoint::Point, radius, angle1, angle2; action=:none)\ncarc(centerpoint::Point, radius, angle1, angle2, action)\n\nAdd an arc centered at centerpoint to the current path from angle1 to angle2, going counterclockwise.\n\nAngles are defined relative to the x-axis, positive clockwise.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.carc2r-Tuple{Point, Point, Point}","page":"Function reference","title":"Luxor.carc2r","text":"carc2r(c1::Point, p2::Point, p3::Point; action=:none)\n\nAdd a circular arc centered at c1 that starts at p2 and ends at p3, going counterclockwise, to the current path.\n\nc1-p2 really determines the radius. If p3 doesn't lie on the circular path, it will be used only as an indication of the arc's length, rather than its position.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.carc2sagitta-Tuple{Point, Point, Real}","page":"Function reference","title":"Luxor.carc2sagitta","text":"carc2sagitta(p1::Point, p2::Point, s;\n    action=:none)\n\nMake a counterclockwise arc starting at p1 and ending at p2 that reaches a height of s, the sagitta, at the middle, and add it to the current path.\n\nReturn tuple of center point and radius of arc.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.center3pts-Tuple{Point, Point, Point}","page":"Function reference","title":"Luxor.center3pts","text":"center3pts(a::Point, b::Point, c::Point)\n\nFind the radius and center point for three points lying on a circle.\n\nreturns (centerpoint, radius) of a circle.\n\nIf there's no such circle, the function returns (Point(0, 0), 0).\n\nIf two of the points are the same, use circle(pt1, pt2) instead.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.circle-Tuple{Point, Point, Point}","page":"Function reference","title":"Luxor.circle","text":"circle(pt1::Point, pt2::Point, pt3::Point; action=:none)\ncircle(pt1::Point, pt2::Point, pt3::Point, action)\n\nMake a circle that passes through three points, and add it to the current path.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.circle-Tuple{Point, Point}","page":"Function reference","title":"Luxor.circle","text":"circle(pt1::Point, pt2::Point; action=:none)\ncircle(pt1::Point, pt2::Point, action)\n\nMake a circle that passes through two points that define the diameter, and add it to the current path.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.circle-Tuple{Point, Real}","page":"Function reference","title":"Luxor.circle","text":"circle(centerpoint::Point, r; action=:none)\ncircle(centerpoint::Point, r, action)\n\nMake a circle of radius r centered at 'centerpoint', and add it to the current path.\n\naction is one of the actions applied by do_action, defaulting to :none.\n\nReturns a tuple of two points, the corners of a bounding box that encloses the circle.\n\nYou can also use ellipse() to draw circles and place them by their centerpoint.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.circlecircleinnertangents-Tuple{Point, Any, Point, Any}","page":"Function reference","title":"Luxor.circlecircleinnertangents","text":"circlecircleinnertangents(circle1center::Point, circle1radius, circle2center::Point, circle2radius)\n\nFind the inner tangents of two circles. These are tangent lines that cross as they skim past one circle and touch the other.\n\nReturns the four points: tangentpoint1 on circle 1, tangentpoint1 on circle2, tangentpoint2 on circle 1, tangentpoint2 on circle2.\n\nReturns (O, O, O, O) if inner tangents can't be found (eg when the circles overlap).\n\nUse circlecircleoutertangents() to find the outer tangents.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.circlecircleoutertangents-Tuple{Point, Any, Point, Any}","page":"Function reference","title":"Luxor.circlecircleoutertangents","text":"circlecircleoutertangents(cpt1::Point, r1, cpt2::Point, r2)\n\nReturn four points, p1, p2,p3,p4, where a line throughp1andp2, and a line throughp3andp4, form the outer tangents to the circles defined bycpt1/r1andcpt2/r2`.\n\nReturns four identical points (O) if one of the circles lies inside the other.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.circlepath-Tuple{Point, Any}","page":"Function reference","title":"Luxor.circlepath","text":"circlepath(center::Point, radius;\n    action=:none,\n    reversepath=false,\n    kappa = 0.5522847498307936)\ncirclepath(center::Point, radius, action;\n    reversepath=false,\n    kappa = 0.5522847498307936)\n\nMake a circle using Bézier curves, and add it to the current path.\n\nOne benefit of using this rather than circle() is that you can use the reversepath option to draw the circle clockwise rather than circle's counterclockwise.\n\nThe magic value, kappa, is 4.0 * (sqrt(2.0) - 1.0) / 3.0.\n\nReturn two points, the corners of a bounding box.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.circlepointtangent-Tuple{Point, Any, Point, Any}","page":"Function reference","title":"Luxor.circlepointtangent","text":"circlepointtangent(through::Point, radius, targetcenter::Point, targetradius)\n\nFind the centers of up to two circles of radius radius that pass through point through and are tangential to a circle that has radius targetradius and center targetcenter.\n\nThis function returns a tuple:\n\n(0, O, O)      - no circles exist\n(1, pt1, O)    - 1 circle exists, centered at pt1\n(2, pt1, pt2)  - 2 circles exist, with centers at pt1 and pt2\n\n(The O are just dummy points so that three values are always returned.)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.circletangent2circles-Tuple{Any, Point, Any, Point, Any}","page":"Function reference","title":"Luxor.circletangent2circles","text":"circletangent2circles(radius, circle1center::Point, circle1radius, circle2center::Point, circle2radius)\n\nFind the centers of up to two circles of radius radius that are tangent to the two circles defined by circle1... and circle2.... These two circles can overlap, but one can't be inside the other.\n\n(0, O, O)      - no such circles exist\n(1, pt1, O)    - 1 circle exists, centered at pt1\n(2, pt1, pt2)  - 2 circles exist, with centers at pt1 and pt2\n\n(The O are just dummy points so that three values are always returned.)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.clip-Tuple{}","page":"Function reference","title":"Luxor.clip","text":"clip()\n\nEstablish a new clipping region by intersecting the current clipping region with the current path and then clearing the current path.\n\nAn existing clipping region is enforced through and after a gsave()-grestore() block, but a clipping region set inside a gsave()-grestore() block is lost after grestore(). [?]\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.clippreserve-Tuple{}","page":"Function reference","title":"Luxor.clippreserve","text":"clippreserve()\n\nEstablish a new clipping region by intersecting the current clipping region with the current path, but keep the current path.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.clipreset-Tuple{}","page":"Function reference","title":"Luxor.clipreset","text":"clipreset()\n\nReset the clipping region to the current drawing's extent.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.closepath-Tuple{}","page":"Function reference","title":"Luxor.closepath","text":"closepath()\n\nDraw a line from the current point to the first point of the current subpath. This is Cairo's close_path() function.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.crescent-Tuple{Point, Real, Point, Real}","page":"Function reference","title":"Luxor.crescent","text":"crescent(cp1, r1, cp2, r2;             action=nothing,             vertices=false,             reversepath=false)\n\nCreate a crescent-shaped polygon, aligned with the current x-axis, by finding the intersection of two circles, and add it to the current path. The two center positions should be different.\n\nSee also crescent(point, innerradius, outeradius...).\n\nExamples\n\nCreate a filled crescent shape from two circles.\n\ncrescent(O, 100, O + (60, 0), 150, :fill) # or\ncrescent(O, 100, O + (60, 0), 150, action=:fill)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.crescent-Tuple{Point, Real, Real}","page":"Function reference","title":"Luxor.crescent","text":"crescent(pos, innerradius, outeradius;\n    action=nothing,\n    vertices=false,\n    reversepath=false,\n    steps = 30)\n\nCreate a crescent-shaped polygon, aligned with the current x-axis, and add it to the current path. If the inner radius is 0, you'll get a semicircle.\n\nSee also crescent(pos1, innerradius, pos2, outeradius...).\n\nExamples\n\nCreate a filled crescent shape with outer radius of 200, inner radius of 130.\n\ncrescent(O, 130, 200, :fill) # or\ncrescent(O, 130, 200, action=:fill)\n\nCreate a stroked crescent shape - the inner radius of 0 produces a semicircle - and add it to the current path.\n\ncrescent(O, 0, 200, :stroke) # or\ncrescent(O, 0, 200, action=:stroke)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.cropmarks-Tuple{Any, Any, Any}","page":"Function reference","title":"Luxor.cropmarks","text":"cropmarks(center, width, height)\n\nDraw cropmarks (also known as trim marks). Use current color.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.crossproduct-Tuple{Point, Point}","page":"Function reference","title":"Luxor.crossproduct","text":"crossproduct(p1::Point, p2::Point)\n\nThis is the perp dot product, really, not the crossproduct proper (which is 3D):\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.currentdrawing-Tuple{Drawing}","page":"Function reference","title":"Luxor.currentdrawing","text":"currentdrawing(d::Drawing)\n\nSets and returns the current Luxor drawing overwriting an existing drawing if exists.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.currentdrawing-Tuple{}","page":"Function reference","title":"Luxor.currentdrawing","text":"currentdrawing()\n\nReturn the current Luxor drawing, if there currently is one.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.currentpoint-Tuple{}","page":"Function reference","title":"Luxor.currentpoint","text":"currentpoint()\n\nReturn the current point. This is the most recent point in the current path, as defined by one of the path building functions such as move(), line(), curve(), arc(), rline(), and rmove().\n\nTo see if there is a current point, use hascurrentpoint().\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.curve-NTuple{6, Any}","page":"Function reference","title":"Luxor.curve","text":"curve(x1, y1, x2, y2, x3, y3)\ncurve(p1, p2, p3)\n\nAdd a Bézier curve to the current path..\n\nThe spline starts at the current position, finishing at x3/y3 (p3), following two control points x1/y1 (p1) and x2/y2 (p2).\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.determinant3-Tuple{Point, Point, Point}","page":"Function reference","title":"Luxor.determinant3","text":"determinant3(p1::Point, p2::Point, p3::Point)\n\nFind the determinant of the 3×3 matrix:\n\nbeginbmatrix\np1x  p1y  1 \np2x  p2y  1 \np3x  p3y  1  \nendbmatrix\n\nIf the value is 0.0, the points are collinear.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.dimension-Tuple{Point, Point}","page":"Function reference","title":"Luxor.dimension","text":"dimension(p1::Point, p2::Point;\n    format::Function   = (d) -> string(d), # process the measured value into a string\n    offset             = 0.0,              # left/right, parallel with x axis\n    fromextension      = (10.0, 10.0),     # length of extensions lines left and right\n    toextension        = (10.0, 10.0),     #\n    textverticaloffset = 0.0,              # range 1.0 (top) to -1.0 (bottom)\n    texthorizontaloffset = 0.0,            # range 1.0 (top) to -1.0 (bottom)\n    textgap            = 5,                # gap between start of each arrow (≈ fontsize?)\n    textrotation       = 0.0,\n    arrowlinewidth     = 1.0,\n    arrowheadlength    = 10,\n    arrowheadangle     = π/8)\n\nCalculate and draw dimensioning graphics for the distance between p1 and p2. The value can be formatted with function format.\n\np1 is the lower on the page (ie probably the higher y value) point, p2 is the higher on the page (ie probably lower y) point.\n\noffset is to the left (-x) when negative.\n\nDimension graphics will be rotated to align with a line between p1 and p2.\n\nIn textverticaloffset, \"vertical\" and \"horizontal\" are best understood by \"looking\" along the line from the first point to the second. textverticaloffset ranges from -1 to 1, texthorizontaloffset in default units.\n\n        toextension\n        [5  ,  5]\n       <---> <--->\n                             to\n       -----------            +\n            ^\n            |\n\n           -50\n\n            |\n            v\n       ----------            +\n                            from\n       <---> <--->\n         [5 , 5]\n       fromextension\n\n            <---------------->\n                  offset\n\nReturns the measured distance and the text.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.distance-Tuple{Luxor.Hexagon, Luxor.Hexagon}","page":"Function reference","title":"Luxor.distance","text":"distance(h1::Hexagon, h2::Hexagon)\n\nFind distance between hexagons h1 and h2.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.distance-Tuple{Point, Point}","page":"Function reference","title":"Luxor.distance","text":"distance(p1::Point, p2::Point)\n\nFind the distance between two points (two argument form).\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.do_action-Tuple{Any}","page":"Function reference","title":"Luxor.do_action","text":"do_action(action)\n\nThis is usually called by other graphics functions. Actions for graphics commands include :fill, :stroke, :clip, :fillstroke, :fillpreserve, and :strokepreserve.\n\nThe :path action adds the graphics to the current path.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.dotproduct-Tuple{Point, Point}","page":"Function reference","title":"Luxor.dotproduct","text":"dotproduct(a::Point, b::Point)\n\nReturn the scalar dot product of the two points.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.douglas_peucker-Tuple{Vector{Point}, Any, Any, Any}","page":"Function reference","title":"Luxor.douglas_peucker","text":"Use a non-recursive Douglas-Peucker algorithm to simplify a polygon. Used by simplify().\n\ndouglas_peucker(pointlist::Array, start_index, last_index, epsilon)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.drawbezierpath-Tuple{BezierPath, Any}","page":"Function reference","title":"Luxor.drawbezierpath","text":"drawbezierpath(bezierpath::BezierPath, action=:none;\n    close=true)\ndrawbezierpath(bezierpath::BezierPath;\n    action=:none,\n    close=true)\n\nDraw the Bézier path, and apply the action, such as :none, :stroke, :fill, etc. By default the path is closed.\n\nTODO Return something more useful than a Boolean.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.drawbezierpath-Tuple{BezierPathSegment}","page":"Function reference","title":"Luxor.drawbezierpath","text":"drawbezierpath(bps::BezierPathSegment;\n    action=:none,\n    close=false)\n\nDraw the Bézier path segment, and apply the action, such as :none, :stroke, :fill, etc. By default the path is open.\n\nTODO Return something more useful than a Boolean.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.drawpath-Tuple{Path, Real}","page":"Function reference","title":"Luxor.drawpath","text":"drawpath(path::Path, k::Real;\n    steps=10, # used when approximating Bezier curve segments\n    action=:none,\n    startnewpath=true,\n    pathlength = 0.0)\n\nDraw the path in path starting at the beginning and stopping at k between 0 and 1. So if k is 0.5, half the path is drawn.\n\nReturns the last point processed.\n\nThe function calculates the length of the entire path before drawing it. If you want to draw a large path more than once, it might be more efficient to calculate the length of the path first, and provide it to the pathlength keyword.\n\nThe steps parameter is used when approximating the length of any curve (Bezier) sections.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.drawpath-Tuple{Path}","page":"Function reference","title":"Luxor.drawpath","text":"drawpath(cp::Path; action=:none, startnewpath=true)\ndrawpath(cp::Path, action; startnewpath=true)\n\nMake the Luxor path stored in cp and apply the action.\n\nTo make paths, follow some path construction functions such as move(), line(), and curve() with the storepath() function.\n\nBy default, startnewpath=true, which starts a new path, discarding any existing path contents.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.easeincirc-NTuple{4, Any}","page":"Function reference","title":"Luxor.easeincirc","text":"easeincirc(t, b, c, d)\n\ncircular easing in - accelerating from zero velocity\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.easeincubic-NTuple{4, Any}","page":"Function reference","title":"Luxor.easeincubic","text":"easeincubic(t, b, c, d)\n\ncubic easing in - accelerating from zero velocity\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.easeinexpo-NTuple{4, Any}","page":"Function reference","title":"Luxor.easeinexpo","text":"easeinexpo(t, b, c, d)\n\nexponential easing in - accelerating from zero velocity\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.easeinoutbezier","page":"Function reference","title":"Luxor.easeinoutbezier","text":"easeinoutbezier(t, b, c, d, cpt1, cpt2)\n\nThis easing function takes six arguments, the usual t, b, c, and d, but also two points. These are the normalized control points of a Bezier curve drawn between Point(0, 0) to Point(1.0, 1.0). The y value of the Bezier is the eased value for t.\n\nIn your frame() generating function, if a Scene specifies the easeinoutbezier easing function, you can use this:\n\n...\nlineareasing = rescale(framenumber, 1, scene.framerange.stop)\nbeziereasing = scene.easingfunction(lineareasing, 0, 1, 1,\n    Point(0.25, 0.25), Point(0.75, 0.75))\n...\n\nThese two control points lie on the line between 0/0 and 1/1, so it's equivalent to a linear easing (lineartween() or easingflat).\n\nHowever, in the next example, the two control points define a wave-like curve that changes direction before changing back. When animating with this easing function, an object will 'go retrograde' for a while.\n\nlineareasing = rescale(framenumber, 1, scene.framerange.stop)\nbeziereasing = scene.easingfunction(lineareasing, 0, 1, 1,\n    Point(0.01, 1.99), Point(0.99, -1.5))\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.easeinoutcirc-NTuple{4, Any}","page":"Function reference","title":"Luxor.easeinoutcirc","text":"easeinoutcirc(t, b, c, d)\n\ncircular easing in/out - acceleration until halfway, then deceleration\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.easeinoutcubic-NTuple{4, Any}","page":"Function reference","title":"Luxor.easeinoutcubic","text":"easeinoutcubic(t, b, c, d)\n\ncubic easing in/out - acceleration until halfway, then deceleration\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.easeinoutexpo-NTuple{4, Any}","page":"Function reference","title":"Luxor.easeinoutexpo","text":"easeinoutexpo(t, b, c, d)\n\nexponential easing in/out - accelerating until halfway, then decelerating\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.easeinoutinversequad-NTuple{4, Any}","page":"Function reference","title":"Luxor.easeinoutinversequad","text":"easeinoutinversequad(t, b, c, d)\n\nease in, then slow down, then speed up, and ease out\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.easeinoutquad-NTuple{4, Any}","page":"Function reference","title":"Luxor.easeinoutquad","text":"easeinoutquad(t, b, c, d)\n\nquadratic easing in/out - acceleration until halfway, then deceleration\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.easeinoutquart-NTuple{4, Any}","page":"Function reference","title":"Luxor.easeinoutquart","text":"easeinoutquart(t, b, c, d)\n\nquartic easing in/out - acceleration until halfway, then deceleration\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.easeinoutquint-NTuple{4, Any}","page":"Function reference","title":"Luxor.easeinoutquint","text":"easeinoutquint(t, b, c, d)\n\nquintic easing in/out - acceleration until halfway, then deceleration\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.easeinoutsine-NTuple{4, Any}","page":"Function reference","title":"Luxor.easeinoutsine","text":"easeinoutsine(t, b, c, d)\n\nsinusoidal easing in/out - accelerating until halfway, then decelerating\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.easeinquad-NTuple{4, Any}","page":"Function reference","title":"Luxor.easeinquad","text":"easeinquad(t, b, c, d)\n\nquadratic easing in - accelerating from zero velocity\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.easeinquart-NTuple{4, Any}","page":"Function reference","title":"Luxor.easeinquart","text":"easeinquart(t, b, c, d)\n\nquartic easing in - accelerating from zero velocity\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.easeinquint-NTuple{4, Any}","page":"Function reference","title":"Luxor.easeinquint","text":"easeinquint(t, b, c, d)\n\nquintic easing in - accelerating from zero velocity\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.easeinsine-NTuple{4, Any}","page":"Function reference","title":"Luxor.easeinsine","text":"easeinsine(t, b, c, d)\n\nsinusoidal easing in - accelerating from zero velocity\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.easeoutcirc-NTuple{4, Any}","page":"Function reference","title":"Luxor.easeoutcirc","text":"easeoutcirc(t, b, c, d)\n\ncircular easing out - decelerating to zero velocity\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.easeoutcubic-NTuple{4, Any}","page":"Function reference","title":"Luxor.easeoutcubic","text":"easeoutcubic(t, b, c, d)\n\ncubic easing out - decelerating to zero velocity\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.easeoutexpo-NTuple{4, Any}","page":"Function reference","title":"Luxor.easeoutexpo","text":"easeoutexpo(t, b, c, d)\n\nexponential easing out - decelerating to zero velocity\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.easeoutquad-NTuple{4, Any}","page":"Function reference","title":"Luxor.easeoutquad","text":"easeoutquad(t, b, c, d)\n\nquadratic easing out - decelerating to zero velocity\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.easeoutquart-NTuple{4, Any}","page":"Function reference","title":"Luxor.easeoutquart","text":"easeoutquart(t, b, c, d)\n\nquartic easing out - decelerating to zero velocity\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.easeoutquint-NTuple{4, Any}","page":"Function reference","title":"Luxor.easeoutquint","text":"easeoutquint(t, b, c, d)\n\nquintic easing out - decelerating to zero velocity\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.easeoutsine-NTuple{4, Any}","page":"Function reference","title":"Luxor.easeoutsine","text":"easeoutsine(t, b, c, d)\n\nsinusoidal easing out - decelerating to zero velocity\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.easingflat-NTuple{4, Any}","page":"Function reference","title":"Luxor.easingflat","text":"easingflat(t, b, c, d)\n\nA flat easing function, same as lineartween().\n\nFor all easing functions, the four parameters are:\n\nt time, ie the current framenumber\nb beginning position or bottom value of the range\nc total change in position or top value of the range\nd duration, ie a framecount\n\nt/d or t/=d normalizes t to between 0 and 1\n... * c scales up to the required range value\n... + b adds the initial offset\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.ellipse-Tuple{Point, Point, Any}","page":"Function reference","title":"Luxor.ellipse","text":"ellipse(focus1::Point, focus2::Point, k;\n        action=:none,\n        stepvalue=pi/100,\n        vertices=false,\n        reversepath=false)\n\nBuild a polygon approximation to an ellipse, given two points and a distance, k, which is the sum of the distances to the focii of any points on the ellipse (or the shortest length of string required to go from one focus to the perimeter and on to the other focus), and add it to the current path.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.ellipse-Tuple{Point, Point, Point}","page":"Function reference","title":"Luxor.ellipse","text":"ellipse(focus1::Point, focus2::Point, pt::Point;\n    action=:none,\n    stepvalue=pi/100,\n    vertices=false,\n    reversepath=false)\n\nBuild a polygon approximation to an ellipse, given two points and a point somewhere on the ellipse.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.ellipse-Tuple{Point, Real, Real}","page":"Function reference","title":"Luxor.ellipse","text":"ellipse(centerpoint::Point, w, h; action=:none)\nellipse(centerpoint::Point, w, h; action)\n\nMake an ellipse, centered at centerpoint, with width w, and height h, and add it to the current path.\n\nReturns a tuple of two points, the corners of a bounding box that encloses the ellipse.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.ellipseinquad-Tuple{Any}","page":"Function reference","title":"Luxor.ellipseinquad","text":"ellipseinquad(qgon; action=:none)\nellipseinquad(qgon, action)\n\nCalculate a Bézier-based ellipse that fits inside the quadrilateral qgon, an array with at least four Points that form a convex polygon, and add it to the current path.\n\nIt returns ellipsecenter, ellipsesemimajor, ellipsesemiminor, ellipseangle:\n\nellipsecenter the ellipse center\nellipsesemimajor ellipse semimajor axis\nellipsesemiminor ellipse semiminor axis\nellipseangle ellipse rotation\n\nThe function returns O, 0, 0, 0 if a suitable ellipse can't be found. (The qgon is probably not a convex polygon.)\n\nExamples\n\nellipseinquad(box(O, 130, 130); action=:stroke)\n\nellipseinquad(box(O, 140, 230), :stroke)\n\nReferences\n\nhttp://faculty.mae.carleton.ca/John_Hayes/Papers/InscribingEllipse.pdf\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.epitrochoid-Tuple{Any, Any, Any}","page":"Function reference","title":"Luxor.epitrochoid","text":"epitrochoid(R, r, d;\n    action=:none,\n    stepby=0.01,\n    period=0,\n    vertices=false)\nepitrochoid(R, r, d, action;\n    stepby=0.01,\n    period=0,\n    vertices=false)\n\nMake a epitrochoid with short line segments, and add it to the current path. (Like a Spirograph.) The curve is traced by a point attached to a circle of radius r rolling around the outside of a fixed circle of radius R, where the point is a distance d from the center of the circle. Things get interesting if you supply non-integral values.\n\nstepby, the angular step value, controls the amount of detail, ie the smoothness of the polygon.\n\nIf period is not supplied, or 0, the lowest period is calculated for you.\n\nThe function can return a polygon (a list of points), or draw the points directly using the supplied action. If the points are drawn, the function returns a tuple showing how many points were drawn and what the period was (as a multiple of pi).\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.fillpath-Tuple{}","page":"Function reference","title":"Luxor.fillpath","text":"fillpath()\n\nFill the current path according to the current settings. The current path is then emptied.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.fillpreserve-Tuple{}","page":"Function reference","title":"Luxor.fillpreserve","text":"fillpreserve()\n\nFill the current path with current settings, but then keep the path current.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.fillstroke-Tuple{}","page":"Function reference","title":"Luxor.fillstroke","text":"fillstroke()\n\nFill and stroke the current path. After this, the current path is empty, and there is no current point.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.findbeziercontrolpoints-NTuple{4, Point}","page":"Function reference","title":"Luxor.findbeziercontrolpoints","text":"findbeziercontrolpoints(\n    previouspt::Point,\n    pt1::Point,\n    pt2::Point,\n    nextpt::Point;\n        smoothing = 0.5)\n\nFind the Bézier control points for the line between pt1 and pt2, where the point before pt1 is previouspt and the next point after pt2 is nextpt.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.finish-Tuple{}","page":"Function reference","title":"Luxor.finish","text":"finish(;svgpostprocess = false, addmarker = true)\n\nFinish the drawing, close any related files. You may be able to view the drawing in another application with preview().\n\nFor more information about svgpostprocess and addmarker see help for Luxor._adjust_background_rects\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.fontface-Tuple{Any}","page":"Function reference","title":"Luxor.fontface","text":"fontface(fontname)\n\nSelect a font to use. (Toy API)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.fontsize-Tuple{Any}","page":"Function reference","title":"Luxor.fontsize","text":"fontsize(n)\n\nSet the font size to n units. The default size is 10 units. (Toy API)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.get_bezier_length-Tuple{BezierPathSegment}","page":"Function reference","title":"Luxor.get_bezier_length","text":"get_bezier_length(bps::BezierPathSegment;\n    steps=10)\n\nReturn the length of a BezierPathSegment, using steps to determine the accuracy, by stepping  through the curve and finding all the points,  and then measuring between them.\n\nThis is obviously just an approximation; the maths to do it properly is too difficult for me. :(\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.get_bezier_points-Tuple{BezierPathSegment}","page":"Function reference","title":"Luxor.get_bezier_points","text":"get_bezier_points(bps::BezierPathSegment;\n    steps=10)\n\nThe flattening: return a list of all the points on the Bezier curve, including start and end, using steps to determine the accuracy.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.get_current_color-Tuple{}","page":"Function reference","title":"Luxor.get_current_color","text":"getcurrentcolor()\n\nReturn an RGBA colorant, the current color, as set by setcolor etc...\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.get_current_hue-Tuple{}","page":"Function reference","title":"Luxor.get_current_hue","text":"getcurrenthue()\n\nAs set by eg sethue(). Return an RGB colorant.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.get_fontsize-Tuple{}","page":"Function reference","title":"Luxor.get_fontsize","text":"get_fontsize()\n\nReturn the font size set by fontsize or. more precisely. the y-scale of the Cairo font matrix if Cairo.set_font_matrix is used directly. (Toy API)\n\nThis only works if Cairo is at least at v1.0.5.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.getcolor-Tuple{}","page":"Function reference","title":"Luxor.getcolor","text":"getcolor()\n\nReturn an RGBA colorant, the current color, as set by setcolor etc...\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.getline-Tuple{}","page":"Function reference","title":"Luxor.getline","text":"getline()\n\nGet the current line width, in points.\n\nUse setline() to set the value.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.getmatrix-Tuple{}","page":"Function reference","title":"Luxor.getmatrix","text":"getmatrix()\n\nGet the current workspace (position, scale, and orientation) as a 6-element vector:\n\n[xx, yx, xy, yy, x0, y0]\n\nxx component of the affine transformation\nyx component of the affine transformation\nxy component of the affine transformation\nyy component of the affine transformation\nx0 translation component of the affine transformation\ny0 translation component of the affine transformation\n\nWhen a drawing is first created, the 'matrix' looks like this:\n\ngetmatrix() = [1.0, 0.0, 0.0, 1.0, 0.0, 0.0]\n\nWhen the origin is moved to 400/400, it looks like this:\n\ngetmatrix() = [1.0, 0.0, 0.0, 1.0, 400.0, 400.0]\n\nTo reset the 'matrix' to the original:\n\nsetmatrix([1.0, 0.0, 0.0, 1.0, 0.0, 0.0])\n\nTo modify the current 'matrix' by multiplying it by a 6 element 'matrix' a, see transform(a::Array).\n\nTo convert between Luxor/Cairo 'matrix' format (6-element Vector{Float64}) and a 3x3 Julia matrix, use cairotojuliamatrix(c) and juliatocairomatrix(c).\n\nSee also rotationmatrix(a), translationmatrix(), and scalingmatrix().\n\nExtended help\n\nHere are some basic matrix transforms:\n\ntranslate\n\ntransform([1, 0, 0, 1, dx, dy]) shifts by dx, dy\n\nscale\n\ntransform([fx 0 0 fy 0 0]) scales by fx and fy\n\nrotate\n\ntransform([cos(a), -sin(a), sin(a), cos(a), 0, 0]) rotates around to a radians\n\nrotate around O: [c -s s c 0 0]\n\nshear\n\ntransform([1 0 a 1 0 0]) shears in x direction by a\n\nshear in y direction by a: [1 a 0 1 0 0]\n\nx-skew\n\ntransform([1, 0, tan(a), 1, 0, 0]) skews in x by a\n\ny-skew\n\ntransform([1, tan(a), 0, 1, 0, 0]) skews in y by a\n\nflip\n\ntransform([fx, 0, 0, fy, centerx * (1 - fx), centery * (fy-1)]) flips with center at centerx/centery\n\nreflect\n\ntransform([1 0 0 -1 0 0]) reflects in xaxis\n\ntransform([-1 0 0 1 0 0]) reflects in yaxis\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.getmode-Tuple{}","page":"Function reference","title":"Luxor.getmode","text":"getmode()\n\nReturn the current compositing/blending mode as a string.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.getnearestpointonline-Tuple{Point, Point, Point}","page":"Function reference","title":"Luxor.getnearestpointonline","text":"getnearestpointonline(pt1::Point, pt2::Point, startpt::Point)\n\nGiven a line from pt1 to pt2, and startpt is the start of a perpendicular heading to meet the line, at what point does it hit the line?\n\nSee perpendicular().\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.getpath-Tuple{}","page":"Function reference","title":"Luxor.getpath","text":"getpath()\n\nGet the current path and return a CairoPath object, which is an array of element_type and points objects. With the results you can step through and examine each entry like this:\n\no = getpath()\nx, y = currentpoint()\nfor e in o\n      if e.element_type == Cairo.CAIRO_PATH_MOVE_TO\n          (x, y) = e.points\n          move(x, y)\n      elseif e.element_type == Cairo.CAIRO_PATH_LINE_TO\n          (x, y) = e.points\n          # straight lines\n          line(x, y)\n          strokepath()\n          circle(x, y, 1, :stroke)\n      elseif e.element_type == Cairo.CAIRO_PATH_CURVE_TO\n          (x1, y1, x2, y2, x3, y3) = e.points\n          # Bezier control lines\n          circle(x1, y1, 1, :stroke)\n          circle(x2, y2, 1, :stroke)\n          circle(x3, y3, 1, :stroke)\n          move(x, y)\n          curve(x1, y1, x2, y2, x3, y3)\n          strokepath()\n          (x, y) = (x3, y3) # update current point\n      elseif e.element_type == Cairo.CAIRO_PATH_CLOSE_PATH\n          closepath()\n      else\n          error(\"unknown CairoPathEntry \" * repr(e.element_type))\n          error(\"unknown CairoPathEntry \" * repr(e.points))\n      end\n  end\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.getpathflat-Tuple{}","page":"Function reference","title":"Luxor.getpathflat","text":"getpathflat()\n\nGet the current path, like getpath() but flattened so that there are no Bézier curves.\n\nReturns a CairoPath which is an array of element_type and points objects.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.getrotation-Tuple{Matrix}","page":"Function reference","title":"Luxor.getrotation","text":"getrotation(R::Matrix)\ngetrotation()\n\nGet the rotation of a Julia 3x3 matrix, or the current Luxor rotation.\n\ngetrotation()\n0.0\n\nbeginbmatrix\na  b  tx \nc  d  ty \n0  0  1  \nendbmatrix\n\nThe rotation angle is atan(-b, a) or atan(c, d).\n\nSee getmatrix() for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.getscale-Tuple{Matrix}","page":"Function reference","title":"Luxor.getscale","text":"getscale(R::Matrix)\ngetscale()\n\nGet the current scale of a 3x3 matrix, or the current Luxor scale.\n\nReturns a tuple of x and y values.\n\ngetscale()\n(1.0, 1.0)\n\nSee getmatrix() for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.gettranslation-Tuple{Matrix}","page":"Function reference","title":"Luxor.gettranslation","text":"gettranslation(R::Matrix)\ngettranslation()\n\nGet the current translation of a 3x3 matrix R, or get the current Luxor translation.\n\nReturns a tuple of x and y values.\n\nSee getmatrix() for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.getworldposition","page":"Function reference","title":"Luxor.getworldposition","text":"getworldposition(pt::Point = O;\n    centered=true)\n\nReturn the world coordinates of pt.\n\nThe default coordinate system for Luxor drawings is that the top left corner is 0/0. If you use origin() (or the various @- macro shortcuts), everything moves to the center of the drawing, and this function with the default centered option assumes an origin() function. If you choose centered=false, the returned coordinates will be relative to the top left corner of the drawing.\n\norigin()\ntranslate(120, 120)\n@show currentpoint()      # => Point(0.0, 0.0)\n@show getworldposition()  # => Point(120.0, 120.0)\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.grestore-Tuple{}","page":"Function reference","title":"Luxor.grestore","text":"grestore()\n\nReplace the current graphics state with the one previously saved by the most recent gsave().\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.gsave-Tuple{}","page":"Function reference","title":"Luxor.gsave","text":"gsave()\n\nSave the current graphics environment, including current color settings.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.hascurrentpoint-Tuple{}","page":"Function reference","title":"Luxor.hascurrentpoint","text":"hascurrentpoint()\n\nReturn true if there is a current point. This is the most recent point in the current path, as defined by one of the path building functions such as move(), line(), curve(), arc(), rline(), and rmove().\n\nTo obtain the current point, use currentpoint().\n\nThere's no current point after strokepath() and strokepath() calls.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.hexagons_within-Tuple{Int64, Luxor.Hexagon}","page":"Function reference","title":"Luxor.hexagons_within","text":"hexagons_within(n::Int, hex::Hexagon)\n\nReturn all the hexagons within index distance n of hex. If n is 0, only the hex itself is returned. If n is 1, hex and the six hexagons one index away are returned. If n is 2, 19 hexagons surrounding hex are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.hexcenter-Tuple{Luxor.Hexagon}","page":"Function reference","title":"Luxor.hexcenter","text":"hexcenter(hex::Hexagon)\n\nFind the center of the hex hexagon. Returns a Point.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.hexcube_linedraw-Tuple{Luxor.Hexagon, Luxor.Hexagon}","page":"Function reference","title":"Luxor.hexcube_linedraw","text":"hexcube_linedraw(hexa::Hexagon, hexb::Hexagon)\n\nFind and return the hexagons that lie (mostly) on a straight line between hexa and hexb. If you filled/stroked them appropriately, you'd get a jagged line.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.hexcube_round","page":"Function reference","title":"Luxor.hexcube_round","text":"hexcube_round(x, y, origin, width = 10.0, height = 10.0)\n\nReturn the hexagon containing the point x, y, on the hexagonal grid centered at origin, and with tiles of width/height\n\npoint in Cartesian space can be mapped to the index of the hexagon that contains it.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.hexdiagonals-Tuple{Luxor.Hexagon}","page":"Function reference","title":"Luxor.hexdiagonals","text":"hexdiagonals(hex::Hexagon)\n\nReturn the six hexagons that lie on the diagonals to hex.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.hexnearest_cubic-Tuple{Real, Real, Real, Any, Any, Any}","page":"Function reference","title":"Luxor.hexnearest_cubic","text":" hexnearest_cubic(x::Real, y::Real, z::Real, origin, width, height)\n\nFind the nearest hexagon in cubic coordinates, ie as q, r, s integer indices, given (x, y, z) as Real numbers, with the hexagonal grid centered at origin, and with tiles of width/height.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.hexneighbors-Tuple{Luxor.Hexagon}","page":"Function reference","title":"Luxor.hexneighbors","text":"hexneighbors(hex::Hexagon)\n\nReturn the neighbors of hex.\n\nExample\n\njulia> h = HexagonOffsetEvenR(0, 0, 70.0)\n\njulia> hexneighbors(h)\nHexagonNeighborIterator(HexagonCubic(0, 0, 0, Point(0.0, 0.0), 70.0, 70.0))\n\njulia> collect(hexneighbors(h))\n6-element Vector{Any}:\nHexagonCubic(1, -1, 0, Point(0.0, 0.0), 70.0, 70.0)\nHexagonCubic(1, 0, -1, Point(0.0, 0.0), 70.0, 70.0)\nHexagonCubic(0, 1, -1, Point(0.0, 0.0), 70.0, 70.0)\nHexagonCubic(-1, 1, 0, Point(0.0, 0.0), 70.0, 70.0)\nHexagonCubic(-1, 0, 1, Point(0.0, 0.0), 70.0, 70.0)\nHexagonCubic(0, -1, 1, Point(0.0, 0.0), 70.0, 70.0)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.hexring-Tuple{Int64, Luxor.Hexagon}","page":"Function reference","title":"Luxor.hexring","text":"hexring(n::Int, hex::Hexagon)\n\nReturn the ring of hexagons that surround hex. If n is 1, the hexagons immediately surrounding hex are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.hexspiral-Tuple{Any, Any}","page":"Function reference","title":"Luxor.hexspiral","text":"hexspiral(hex, n)\n\nReturn an array of hexagons to spiral around a central hexagon forming n rings.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.hextile-Tuple{Luxor.Hexagon}","page":"Function reference","title":"Luxor.hextile","text":" hextile(hex::Hexagon)\n\nCalculate the six vertices of the hexagon hex and return them in an array of Points.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.highestaspectratio-NTuple{5, Any}","page":"Function reference","title":"Luxor.highestaspectratio","text":"highestaspectratio()\n\nFind the highest aspect ratio of a list of rectangles, given the length of the side along which they are to be laid out.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.highlightcells","page":"Function reference","title":"Luxor.highlightcells","text":"highlightcells(t::Table, cellnumbers, action::Symbol=:stroke;\n        color::Colorant=colorant\"red\",\n        offset = 0)\n\nHighlight (draw or fill) one or more cells of table t. cellnumbers is a range, array, or an array of row/column tuples.\n\nhighlightcells(t, 1:10, :fill, color=colorant\"blue\")\nhighlightcells(t, vcat(1:5, 150), :stroke, color=colorant\"magenta\")\nhighlightcells(t, [(4, 5), (3, 6)])\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.hypotrochoid-Tuple{Any, Any, Any}","page":"Function reference","title":"Luxor.hypotrochoid","text":"hypotrochoid(R, r, d;\n    action=:none,\n    stepby=0.01,\n    period=0.0,\n    vertices=false)\nhypotrochoid(R, r, d, action;\n    stepby=0.01,\n    period=0.0,\n    vertices=false)\n\nMake a hypotrochoid with short line segments, and add it to the current path. (Like a Spirograph.) The curve is traced by a point attached to a circle of radius r rolling around the inside  of a fixed circle of radius R, where the point is a distance d from  the center of the interior circle. Things get interesting if you supply non-integral values.\n\nSpecial cases include the hypocycloid, if d = r, and an ellipse, if R = 2r.\n\nstepby, the angular step value, controls the amount of detail, ie the smoothness of the polygon,\n\nIf period is not supplied, or 0, the lowest period is calculated for you.\n\nThe function can return a polygon (a list of points), or draw the points directly using the supplied action. If the points are drawn, the function returns a tuple showing how many points were drawn and what the period was (as a multiple of pi).\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.image_as_matrix!-Tuple{Any}","page":"Function reference","title":"Luxor.image_as_matrix!","text":"image_as_matrix!(buffer)\n\nLike image_as_matrix(), but use an existing UInt32 buffer.\n\nbuffer is a buffer of UInt32.\n\nw = 200\nh = 150\nbuffer = zeros(UInt32, w, h)\nDrawing(w, h, :image)\norigin()\njuliacircles(50)\nm = image_as_matrix!(buffer)\nfinish()\n# collect(m)) is Array{ARGB32,2}\nImages.RGB.(m)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.image_as_matrix-Tuple{}","page":"Function reference","title":"Luxor.image_as_matrix","text":"image_as_matrix()\n\nReturn an Array of the current state of the picture as an array of ARGB32.\n\nA matrix 50 wide and 30 high => a table 30 rows by 50 cols\n\nusing Luxor, Images\n\nDrawing(50, 50, :png)\norigin()\nbackground(randomhue()...)\nsethue(\"white\")\nfontsize(40)\nfontface(\"Georgia\")\ntext(\"42\", halign=:center, valign=:middle)\nmat = image_as_matrix()\nfinish()\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.initnoise-Tuple{Any}","page":"Function reference","title":"Luxor.initnoise","text":"initnoise(seed::Int)\ninitnoise()\n\nInitialize the noise generation code.\n\njulia> initnoise(); noise(1)\n0.7453148982810598\n\njulia> initnoise(); noise(1)\n0.7027617067916981\n\nIf you provide an integer seed, it will be used to seed Random.seed!()` when the noise code is initialized:\n\njulia> initnoise(41); noise(1) # yesterday\n0.7134000046640385\n\njulia> initnoise(41); noise(1) # today\n0.7134000046640385\n\nIf you need to control which type of random number generator is used, you can provide your own and it will be used instead of the default Julia implementation.\n\njulia> rng = MersenneTwister(1234) # any AbstractRNG\njulia> initnoise(rng)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.insertvertices!-Tuple{Any}","page":"Function reference","title":"Luxor.insertvertices!","text":"insertvertices!(pgon;\n    ratio=0.5)\n\nInsert a new vertex into each edge of a polygon pgon. The default ratio of 0.5 divides the original edge of the polygon into half.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.intersectboundingboxes-Tuple{BoundingBox, BoundingBox}","page":"Function reference","title":"Luxor.intersectboundingboxes","text":"intersectboundingboxes(bb1::BoundingBox, bb2::BoundingBox)\n\nReturn a BoundingBox that's an intersection of the two bounding boxes.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.intersection2circles-NTuple{4, Any}","page":"Function reference","title":"Luxor.intersection2circles","text":"intersection2circles(pt1, r1, pt2, r2)\n\nFind the area of intersection between two circles, the first centered at pt1 with radius r1, the second centered at pt2 with radius r2.\n\nIf one circle is entirely within another, that circle's area is returned.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.intersectioncirclecircle-NTuple{4, Any}","page":"Function reference","title":"Luxor.intersectioncirclecircle","text":"intersectioncirclecircle(cp1, r1, cp2, r2)\n\nFind the two points where two circles intersect, if they do. The first circle is centered at cp1 with radius r1, and the second is centered at cp1 with radius r1.\n\nReturns\n\n(flag, ip1, ip2)\n\nwhere flag is a Boolean true if the circles intersect at the points ip1 and ip2. If the circles don't intersect at all, or one is completely inside the other, flag is false and the points are both Point(0, 0).\n\nUse intersection2circles() to find the area of two overlapping circles.\n\nIn the pure world of maths, it must be possible that two circles 'kissing' only have a single intersection point. At present, this unromantic function reports that two kissing circles have no intersection points.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.intersectionlinecircle-Tuple{Point, Point, Point, Any}","page":"Function reference","title":"Luxor.intersectionlinecircle","text":"intersectionlinecircle(p1::Point, p2::Point, cpoint::Point, r)\n\nFind the intersection points of a line (extended through points p1 and p2) and a circle.\n\nReturn a tuple of (n, pt1, pt2)\n\nwhere\n\nn is the number of intersections, 0, 1, or 2\npt1 is first intersection point, or Point(0, 0) if none\npt2 is the second intersection point, or Point(0, 0) if none\n\nThe calculated intersection points won't necessarily lie on the line segment between p1 and p2.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.intersectionlines-NTuple{4, Point}","page":"Function reference","title":"Luxor.intersectionlines","text":"intersectionlines(p0, p1, p2, p3;\n    crossingonly=false)\n\nFind the point where two lines intersect.\n\nIf crossingonly == true the point of intersection must lie on both lines.\n\nIf crossingonly == false the point of intersection can be where the lines meet if extended almost to 'infinity'.\n\nAccordng to this function, collinear, overlapping, and parallel lines never intersect. Ie, the line segments might be collinear but have no points in common, or the lines segments might be collinear and have many points in common, or the line segments might be collinear and one is entirely contained within the other.\n\nIf the lines are collinear and share a point in common, that is the intersection point.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.intersectlinepoly-Tuple{Point, Point, Vector{Point}}","page":"Function reference","title":"Luxor.intersectlinepoly","text":"intersectlinepoly(pt1::Point, pt2::Point, C)\n\nReturn an array of the points where a line between pt1 and pt2 crosses polygon C.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.isarcclockwise-Tuple{Point, Point, Point}","page":"Function reference","title":"Luxor.isarcclockwise","text":"isarcclockwise(c::Point, A::Point, B::Point)\n\nReturn true if an arc centered at c going from A to B is clockwise.\n\nIf c, A, and B are collinear, then a hemispherical arc could be either clockwise or not.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.isinside-Tuple{Point, BoundingBox}","page":"Function reference","title":"Luxor.isinside","text":"isinside(p::Point, bb:BoundingBox)\n\nReturns true if pt is inside bounding box bb.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.isinside-Tuple{Point, Vector{Point}}","page":"Function reference","title":"Luxor.isinside","text":"isinside(p, pol; allowonedge=false)\n\nIs a point p inside a polygon pol? Returns true if it does, or false.\n\nThis is an implementation of the Hormann-Agathos (2001) Point in Polygon algorithm.\n\nThe classification of points lying on the edges of the target polygon, or coincident with its vertices is not clearly defined, due to rounding errors or arithmetical inadequacy. By default these will generate errors, but you can suppress these by setting allowonedge to true.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.ispointonleftofline-Tuple{Point, Point, Point}","page":"Function reference","title":"Luxor.ispointonleftofline","text":"ispointonleftofline(A::Point, B::Point, C::Point)\n\nFor a line passing through points A and B:\n\nreturn true if point C is on the left of the line\nreturn false if point C lies on the line\nreturn false if point C is on the right of the line\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.ispointonline-Tuple{Point, Point, Point}","page":"Function reference","title":"Luxor.ispointonline","text":"ispointonline(pt::Point, pt1::Point, pt2::Point;\n    extended = false,\n    atol = 10E-5)\n\nReturn true if the point pt lies on a straight line between pt1 and pt2.\n\nIf extended is false (the default) the point must lie on the line segment between pt1 and pt2. If extended is true, the point lies on the line if extended in either direction.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.ispointonpoly-Tuple{Point, Vector{Point}}","page":"Function reference","title":"Luxor.ispointonpoly","text":"ispointonpoly(pt::Point, pgon;\n    atol=10E-5)\n\nReturn true if pt lies on the polygon pgon.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.ispolyclockwise-Tuple{Vector{Point}}","page":"Function reference","title":"Luxor.ispolyclockwise","text":"ispolyclockwise(pgon)\n\nReturns true if polygon is clockwise. WHEN VIEWED IN A LUXOR DRAWING...?\n\nTODO This code is still experimental...\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.ispolyconvex-Tuple{Any}","page":"Function reference","title":"Luxor.ispolyconvex","text":"ispolyconvex(pts)\n\nReturn true if polygon is convex. This tests that every interior angle is less than or equal to 180°.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.juliacircles","page":"Function reference","title":"Luxor.juliacircles","text":"juliacircles(radius=100;\n    outercircleratio=0.75,\n    innercircleratio=0.65,\n    action=:fill)\n\nDraw the three Julia circles (\"dots\") in color centered at the origin.\n\nThe distance of the centers of each circle from the origin is radius.\n\nThe optional keyword argument outercircleratio (default 0.75) determines the radius of each circle relative to the main radius. So the default is to draw circles of radius 75 points around a larger circle of radius 100.\n\nReturn the three centerpoints.\n\nThe innercircleratio (default 0.65) no longer does anything useful (it used to draw the smaller circles) and will be deprecated.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.julialogo-Tuple{}","page":"Function reference","title":"Luxor.julialogo","text":"julialogo(;\n    action=:fill,\n    color=true,\n    bodycolor=colorant\"black\",\n    centered=false)\n\nDraw the Julia logo. The default action is to fill the logo and use the colors:\n\njulialogo()\n\nIf color is false, the bodycolor color is used for the logo.\n\nThe function uses the current drawing state (position, scale, etc).\n\nThe centered keyword lets you center the logo at its mathematical center, but the optical center might lie somewhere else - it's difficult to position well due to its asymmetric design.\n\nTo use the logo as a clipping mask:\n\njulialogo(action=:clip)\n\n(In this case the color setting is automatically ignored.)\n\nTo obtain a stroked (outlined) version:\n\njulialogo(action=:path)\nsethue(\"red\")\nstrokepath()\n\nTODO Return something more useful than a Boolean.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.juliatocairomatrix-Tuple{Matrix}","page":"Function reference","title":"Luxor.juliatocairomatrix","text":"juliatocairomatrix(c)\n\nReturn a six-element matrix that's the equivalent of the 3x3 Julia matrix in c.\n\nSee getmatrix() for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.label","page":"Function reference","title":"Luxor.label","text":"label(txt::T where T <: AbstractString, rotation::Float64, pos::Point=O;\n    offset=5,\n    leader=false,\n    leaderoffsets=[0.0, 1.0])\n\nAdd a text label at a point, positioned relative to that point, for example, 0.0 is East, pi is West.\n\nlabel(\"text\", pi)          # positions text to the left of the origin\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.label-2","page":"Function reference","title":"Luxor.label","text":"label(txt::T where T <: AbstractString, alignment::Symbol=:N, pos::Point=O;\n    offset=5,\n    leader=false,\n    leaderoffsets=[0.0, 1.0])\n\nAdd a text label at a point, positioned relative to that point, for example, :N signifies North and places the text directly above that point.\n\nUse one of :N, :S, :E, :W, :NE, :SE, :SW, :NW to position the label relative to that point.\n\nlabel(\"text\")          # positions text at North (above), relative to the origin\nlabel(\"text\", :S)      # positions text at South (below), relative to the origin\nlabel(\"text\", :S, pt)  # positions text South of pt\nlabel(\"text\", :N, pt, offset=20)  # positions text North of pt, offset by 20\n\nThe default offset is 5 units.\n\nIf leader is true, draw a line as well.\n\nleaderoffsts uses normalized fractions (see between()) to specify the gap between the designated points and the start and end of the lines.\n\nTODO: Negative offsets don't give good results.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.latexboundingbox","page":"Function reference","title":"Luxor.latexboundingbox","text":"latexboundingbox(lstr::LaTeXString, font_size=get_fontsize(); halign=:left, valign=:right)\n\nReturns the bounding box containing the latex text with (Lower Left Point, Upper Right Point). Use box(latex_bb(testext)...,:stroke) to draw the bounding box.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.latextextsize-Tuple{LaTeXStrings.LaTeXString}","page":"Function reference","title":"Luxor.latextextsize","text":"latextextsize(lstr::LaTeXString)\n\nReturns the width and height of a latex string.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.layout-NTuple{5, Any}","page":"Function reference","title":"Luxor.layout","text":"layout(A, x, y, w, h)\n\nFrom A, make a row of tiles (if wider than tall) or a column of tiles (if taller than wide).\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.line-Tuple{Any, Any}","page":"Function reference","title":"Luxor.line","text":"line(pt::Point)\n\nAdd a straight line to the current path that joins the path's current point to pt. The current point is then updated to pt.\n\nOther path-building functions are move(), curve(), arc(), rline(), and rmove().\n\nSee also currentpoint() and hascurrentpoint().\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.line-Tuple{Point, Point}","page":"Function reference","title":"Luxor.line","text":"line(pt1::Point, pt2::Point; action=:path)\nline(pt1::Point, pt2::Point, action=:path)\n\nAdd a straight line between two points pt1 and pt2, and do the action.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.lineartween-NTuple{4, Any}","page":"Function reference","title":"Luxor.lineartween","text":"default linear transition - no easing, no acceleration\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.makebezierpath-Tuple{Vector{Point}}","page":"Function reference","title":"Luxor.makebezierpath","text":"makebezierpath(pgon::Array{Point, 1};\n    smoothing=1.0)\n\nReturn a Bézier path (a BezierPath) that represents a polygon (an array of points). The Bézier path is an array of segments (tuples of 4 points); each segment contains the four points that make up a section of the entire Bézier path.\n\nsmoothing determines how closely the curve follows the polygon. A value of 0 returns a straight-sided path; as values move above 1 the paths deviate further from the original polygon's edges.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.mask-Tuple{Point, Point, Any, Any}","page":"Function reference","title":"Luxor.mask","text":"mask(point::Point, focus::Point, width, height)\n    max = 1.0,\n    min = 0.0,\n    easingfunction = easingflat)\n\nCalculate a value between 0 and 1 for a point relative to a rectangular area defined by focus, width, and height. The value will approach max (1.0) at the center, and min (0.0) at the edges.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.mask-Tuple{Point, Point, Any}","page":"Function reference","title":"Luxor.mask","text":"mask(point::Point, focus::Point, radius)\n    max = 1.0,\n    min = 0.0,\n    easingfunction = easingflat)\n\nCalculate a value between 0 and 1 for a point relative to a circular area defined by focus and radius. The value will approach max (1.0) at the center of the circular area, and min (0.0) at the circumference.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.mesh","page":"Function reference","title":"Luxor.mesh","text":"mesh(points::Array{Point},\n     colors=Array{Colors.Colorant, 1})\n\nCreate a mesh.\n\nThe first three or four sides of the supplied points polygon define the three or four sides of the mesh shape.\n\nThe colors array define the color of each corner point. Colors are reused if necessary. At least one color should be supplied.\n\nExample\n\n@svg begin\n    pl = ngon(O, 250, 3, pi/6, vertices=true)\n    mesh1 = mesh(pl, [\n        \"purple\",\n        Colors.RGBA(0.0, 1.0, 0.5, 0.5),\n        \"yellow\"\n        ])\n    setmesh(mesh1)\n    setline(180)\n    ngon(O, 250, 3, pi/6, :strokepreserve)\n    setline(5)\n    sethue(\"black\")\n    strokepath()\nend\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.mesh-2","page":"Function reference","title":"Luxor.mesh","text":"mesh(bezierpath::BezierPath,\n     colors=Array{Colors.Colorant, 1})\n\nCreate a mesh. The first three or four elements of the supplied bezierpath define the three or four sides of the mesh shape.\n\nThe colors array define the color of each corner point. Colors are reused if necessary. At least one color should be supplied.\n\nUse setmesh() to select the mesh, which will be used to fill shapes.\n\nExample\n\n@svg begin\n    bp = makebezierpath(ngon(O, 50, 4, 0, vertices=true))\n    mesh1 = mesh(bp, [\n        \"red\",\n        Colors.RGB(0, 1, 0),\n        Colors.RGB(0, 1, 1),\n        Colors.RGB(1, 0, 1)\n        ])\n    setmesh(mesh1)\n    box(O, 500, 500, :fill)\nend\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.midpoint","page":"Function reference","title":"Luxor.midpoint","text":"midpoint(bb::BoundingBox=BoundingBox())\n\nReturns the point midway between the two points of the BoundingBox. This should also be the center, unless I've been very stupid...\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.midpoint-Tuple{Array}","page":"Function reference","title":"Luxor.midpoint","text":"midpoint(a)\n\nFind midpoint between the first two elements of an array of points.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.midpoint-Tuple{Point, Point}","page":"Function reference","title":"Luxor.midpoint","text":"midpoint(p1, p2)\n\nFind the midpoint between two points.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.move-Tuple{Any, Any}","page":"Function reference","title":"Luxor.move","text":"move(pt)\n\nBegin a new subpath in the current path, and set the current path's current point to pt, without drawing anything.\n\nOther path-building functions are line(), curve(), arc(), rline(), and rmove().\n\nhascurrentpoint() returns true if there is a current point.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.nearestindex-Tuple{Vector{T} where T<:Real, Any}","page":"Function reference","title":"Luxor.nearestindex","text":"nearestindex(polydistancearray, value)\n\nReturn a tuple of the index of the largest value in polydistancearray less than value, and the difference value. Array is assumed to be sorted.\n\n(Designed for use with polydistances()).\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.newpath-Tuple{}","page":"Function reference","title":"Luxor.newpath","text":"newpath()\n\nDiscard the current path's contents. After this, the current path is empty, and there's no current point.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.newsubpath-Tuple{}","page":"Function reference","title":"Luxor.newsubpath","text":"newsubpath()\n\nStart a new subpath in the current path. After this, there's no current point.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.nextgridpoint-Tuple{GridHex}","page":"Function reference","title":"Luxor.nextgridpoint","text":"nextgridpoint(g::GridHex)\n\nReturns the next available grid point of a hexagonal grid.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.nextgridpoint-Tuple{GridRect}","page":"Function reference","title":"Luxor.nextgridpoint","text":"nextgridpoint(g::GridRect)\n\nReturns the next available (or even the first) grid point of a grid.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.ngon","page":"Function reference","title":"Luxor.ngon","text":"ngon(centerpos, radius, sides=5, orientation=0;\n    action=:none,\n    vertices=false,\n    reversepath=false)\n\nDraw a regular polygon centered at point centerpos.\n\nFind the vertices of a regular n-sided polygon centered at x, y with circumradius radius.\n\nThe polygon is constructed counterclockwise, starting with the first vertex drawn below the positive x-axis.\n\nIf you just want the raw points, use keyword argument vertices=true, which returns the array of points. Compare:\n\nngon(0, 0, 4, 4, 0, vertices=true) # returns the polygon's points:\n\n4-element Array{Luxor.Point, 1}:\nLuxor.Point(2.4492935982947064e-16, 4.0)\nLuxor.Point(-4.0, 4.898587196589413e-16)\nLuxor.Point(-7.347880794884119e-16, -4.0)\nLuxor.Point(4.0, -9.797174393178826e-16)\n\nwhereas\n\nngon(0, 0, 4, 4, 0, :close) # draws a polygon\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.ngon-2","page":"Function reference","title":"Luxor.ngon","text":"ngon(x, y, radius, sides=5, orientation=0;\n    action = :none,\n    vertices = false,\n    reversepath = false)\n\nDraw a regular polygon centered at point Point(x,y).\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.ngonside","page":"Function reference","title":"Luxor.ngonside","text":"ngonside(centerpoint::Point, sidelength::Real, sides::Int=5, orientation=0;\n        action=:none,\n        vertices=false,\n        reversepath=false)\nngonside(centerpoint::Point, sidelength::Real, sides::Int, orientation, action;\n        vertices=false,\n        reversepath=false)\n\nDraw a regular polygon centered at centerpoint with sides sides of length sidelength.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.noise-Union{Tuple{Any}, Tuple{T}} where T<:Integer","page":"Function reference","title":"Luxor.noise","text":"noise(x)          ; detail = 1, persistence = 1.0) # 1D\nnoise(x, y)       ; detail = 1, persistence = 1.0) # 2D\nnoise(x, y, z)    ; detail = 1, persistence = 1.0) # 3D\nnoise(x, y, z, w) ; detail = 1, persistence = 1.0) # 4D\n\nGenerate a noise value between 0.0 and 1.0 corresponding to the x, y, z, and w values. An x value on its own produces 1D noise, x and y make 2D noise, and so on.\n\nThe detail value is an integer (>= 1) specifying how many octaves of noise you want.\n\nThe persistence value, typically between 0.0 and 1.0, controls how quickly the amplitude diminishes for each successive octave for values of detail greater than 1.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.offsetlinesegment-NTuple{5, Any}","page":"Function reference","title":"Luxor.offsetlinesegment","text":"offsetlinesegment(p1, p2, p3, d1, d2)\n\nGiven three points, find another 3 points that are offset by d1 at the start and d2 at the end.\n\nNegative d values put the offset on the left.\n\nUsed by offsetpoly().\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.offsetpoly-Tuple{Any, Function}","page":"Function reference","title":"Luxor.offsetpoly","text":"offsetpoly(plist, shape::Function)\n\nReturn a closed polygon that is offset from and encloses an polyline.\n\nThe incoming set of points plist is treated as an polyline, and another set of points is created, which form a closed polygon offset from the source poly.\n\nThere must be at least 4 points in the polyline.\n\nThis method for offsetpoly() treats the list of points as n vertices connected with n - 1 lines. (The other method offsetpoly(plist, d) treats the list of points as n vertices connected with n lines.)\n\nThe supplied function determines the width of the line. f(0, θ) gives the width at the start (the slope of the curve at that point is supplied in θ), f(1, θ) provides the width at the end, and f(n, θ) is the width of point n/l.\n\nExamples\n\nThis example draws a tilde, with the ends starting at 20 (10 + 10) units wide, swelling to 50 (10 + 10 + 15 + 15) in the middle, as f(0.5) = 25.\n\nf(x, θ) =  10 + 15sin(x * π)\nsinecurve = [Point(50x, 50sin(x)) for x in -π:π/24:π]\npgon = offsetpoly(sinecurve, f)\npoly(pgon, :fill)\n\nThis example enhances the vertical part of the curve, and thins the horizontal parts.\n\ng(x, θ) = rescale(abs(sin(θ)), 0, 1, 0.1, 30)\nsinecurve = [Point(50x, 50sin(x)) for x in -π:π/24:π]\npgon = offsetpoly(sinecurve, g)\npoly(pgon, :fill)\n\nTODO - rewrite it!\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.offsetpoly-Tuple{Any}","page":"Function reference","title":"Luxor.offsetpoly","text":"offsetpoly(plist;\n    startoffset = 10,\n    endoffset   = 10,\n    easingfunction = lineartween)\n\nReturn a closed polygon that is offset from and encloses an open polygon.\n\nThe incoming set of points plist is treated as an open polygon, and another set of points is created, which form a polygon lying ...offset units away from the source poly.\n\nThis method for offsetpoly() treats the list of points as n vertices connected with n - 1 lines. It allows you to vary the offset from the start of the line to the end.\n\nThe other method offsetpoly(plist, d) treats the list of points as n vertices connected with n lines.\n\nExtended help\n\nThis function accepts a keyword argument that allows you to control the offset using a function, using the easing functionality built in to Luxor. By default the function is lineartween(), so the offset changes linearly between the startoffset and the endoffset. The function:\n\nf(a, b, c, d) = 2sin((a * π))\n\nruns from 0 to 2 and back as a runs from 0 to 1. The offsets are scaled by this amount.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.offsetpoly-Union{Tuple{T}, Tuple{Vector{Point}, T}} where T<:Number","page":"Function reference","title":"Luxor.offsetpoly","text":"offsetpoly(plist::Array{Point, 1}, d) where T<:Number\n\nReturn a polygon that is offset from a polygon by d units.\n\nThe incoming set of points plist is treated as a polygon, and another set of points is created, which form a polygon lying d units away from the source poly.\n\nPolygon offsetting is a topic on which people have written PhD theses and published academic papers, so this short brain-dead routine will give good results for simple polygons up to a point (!). There are a number of issues to be aware of:\n\nvery short lines tend to make the algorithm 'flip' and produce larger lines\nsmall polygons that are counterclockwise and larger offsets may make the new polygon appear the wrong side of the original\nvery sharp vertices will produce even sharper offsets, as the calculated intersection point veers off to infinity\nduplicated adjacent points might cause the routine to scratch its head and wonder how to draw a line parallel to them\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.origin-Tuple{Any}","page":"Function reference","title":"Luxor.origin","text":"origin(pt:Point)\n\nReset the current position, scale, and orientation, then move the 0/0 position to pt.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.origin-Tuple{}","page":"Function reference","title":"Luxor.origin","text":"origin()\n\nReset the current position, scale, and orientation, and then set the 0/0 origin to the center of the drawing (otherwise it will stay at the top left corner, the default).\n\nYou can refer to the 0/0 point as O. (O = Point(0, 0)),\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.paint-Tuple{}","page":"Function reference","title":"Luxor.paint","text":"paint()\n\nPaint the current clip region with the current settings.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.pathlength-Tuple{Path}","page":"Function reference","title":"Luxor.pathlength","text":"pathlength(path::Path;\n    steps=10)\n\nReturn the length of a Path.\n\nThe steps parameter is used when approximating the length of any curve (Bezier) sections.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.pathsample-Tuple{Path, Any}","page":"Function reference","title":"Luxor.pathsample","text":"pathsample(path::Path, spacing;\n    steps=10)\n\nReturn a new Path that resamples the path such that each line and curve of the original path is divided into sections that are approximately spacing units long.\n\nThe steps parameter is used when approximating the length of any curve (Bezier) sections. For measurement purposes, each Bezier curve is divided in steps straight lines; the error will be smaller for flatter curves and larger for more curvy ones.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.pathtobezierpaths-Tuple{}","page":"Function reference","title":"Luxor.pathtobezierpaths","text":"pathtobezierpaths(\n    ; flat=true)\n\nConvert the current Cairo path (which may consist of one or more paths) to an array of Bézier paths, each of which is an array of BezierPathSegments. Each path segment is a tuple of four points. A straight line is converted to a Bézier segment in which the control points are set to be the same as the end points.\n\nIf flat is true, use getpathflat() rather than getpath().\n\nExample\n\nThis code draws the BezierPathSegments and shows the control points as \"handles\", like a vector-editing program might.\n\n@svg begin\n    fontface(\"MyanmarMN-Bold\")\n    st = \"goo\"\n    thefontsize = 100\n    fontsize(thefontsize)\n    sethue(\"red\")\n    fontsize(thefontsize)\n    textpath(st)\n    nbps = pathtobezierpaths()\n    for nbp in nbps\n        setline(.15)\n        sethue(\"grey50\")\n        drawbezierpath(nbp, :stroke)\n        for p in nbp\n            sethue(\"red\")\n            circle(p[2], 0.16, :fill)\n            circle(p[3], 0.16, :fill)\n            line(p[2], p[1], :stroke)\n            line(p[3], p[4], :stroke)\n            if p[1] != p[4]\n                sethue(\"black\")\n                circle(p[1], 0.26, :fill)\n                circle(p[4], 0.26, :fill)\n            end\n        end\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.pathtopoly-Tuple{}","page":"Function reference","title":"Luxor.pathtopoly","text":"pathtopoly()\n\nConvert the current path to an array of polygons.\n\nReturns an array of polygons, corresponding to the paths and subpaths of the original path.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.perpendicular-Tuple{Point, Point, Any}","page":"Function reference","title":"Luxor.perpendicular","text":"perpendicular(p1, p2, k)\n\nReturn a point p3 that is k units away from p1, such that a line p1 p3 is perpendicular to p1 p2.\n\nConvention? to the right?\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.perpendicular-Tuple{Point, Point, Point}","page":"Function reference","title":"Luxor.perpendicular","text":"perpendicular(p1::Point, p2::Point, p3::Point)\n\nReturn a point on a line passing through p1 and p2 that is perpendicular to p3.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.perpendicular-Tuple{Point, Point}","page":"Function reference","title":"Luxor.perpendicular","text":"perpendicular(p1, p2)\n\nReturn two points p3 and p4 such that a line from p3 to p4 is perpendicular to a line from p1 to p2, the same length, and the lines intersect at their midpoints.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.perpendicular-Tuple{Point}","page":"Function reference","title":"Luxor.perpendicular","text":"perpendicular(p::Point)\n\nReturns point Point(p.y, -p.x).\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.pie-NTuple{5, Real}","page":"Function reference","title":"Luxor.pie","text":"pie(x, y, radius, startangle, endangle; action=:none)\npie(centerpoint, radius, startangle, endangle; action=:none)\n\nMake a pie shape centered at x/y. Angles start at the positive x-axis and are measured clockwise, and add it to the current path.\n\nTODO - return something more useful than a Boolean\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.pie-Tuple{Point, Real, Real, Real, Symbol}","page":"Function reference","title":"Luxor.pie","text":"pie(centerpoint::Point, radius::Real, startangle::Real, endangle::Real, action::Symbol)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.pie-Tuple{Real, Real, Real}","page":"Function reference","title":"Luxor.pie","text":"pie(radius, startangle, endangle;\n    action=:none)\n\nMake a pie shape centered at the origin, and add it to the current path.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.placeimage","page":"Function reference","title":"Luxor.placeimage","text":"placeimage(svgimg, pos=O; centered=false)\n\nPlace an SVG image stored in svgimg on the drawing at pos. Use readsvg() to read an SVG image from file, or from SVG code.\n\nUse keyword centered=true to place the center of the image at the position.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.placeimage-2","page":"Function reference","title":"Luxor.placeimage","text":"placeimage(matrix::AbstractMatrix{UInt32}, pos=O;\n    alpha=1, centered=false)\n\nPlace an image matrix on the drawing at pos with opacity/transparency alpha.\n\nUse keyword centered=true to place the center of the image at the position.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.placeimage-Tuple{AbstractMatrix{ColorTypes.ARGB32}, Vararg{Any}}","page":"Function reference","title":"Luxor.placeimage","text":"placeimage(buffer::AbstractMatrix{ARGB32}, args...; \n    kargs...)\n\nPlace an array of ARGB32 lements on the drawing at pos with opacity/transparency alpha. Values are \"alpha-premultiplied\" before being placed.\n\nUse keyword centered=true to place the center of the image at the position.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.placeimage-Tuple{Cairo.CairoSurface, Any, Any, Any}","page":"Function reference","title":"Luxor.placeimage","text":"placeimage(img, pt::Point=O, alpha; centered=false)\nplaceimage(pngimg, xpos, ypos, alpha; centered=false)\n\nPlace a PNG image pngimg on the drawing at pt or Point(xpos, ypos) with opacity/transparency alpha. The image has been previously loaded using readpng().\n\nUse keyword centered=true to place the center of the image at the position.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.placeimage-Tuple{Cairo.CairoSurface, Any, Any}","page":"Function reference","title":"Luxor.placeimage","text":"placeimage(pngimg, pos=O; centered=false)\nplaceimage(pngimg, xpos, ypos; centered=false)\n\nPlace the PNG image on the drawing at pos, or (xpos/ypos). The image img has been previously read using readpng().\n\nUse keyword centered=true to place the center of the image at the position.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.pointcircletangent-Tuple{Point, Point, Any}","page":"Function reference","title":"Luxor.pointcircletangent","text":"pointcircletangent(point::Point, circlecenter::Point, circleradius)\n\nFind the two points on a circle that lie on tangent lines passing through an external point.\n\nIf both points are O, the external point is inside the circle, and the result is (O, O).\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.pointcrossesboundingbox-Tuple{Any, BoundingBox}","page":"Function reference","title":"Luxor.pointcrossesboundingbox","text":"pointcrossesboundingbox(pt, bbox::BoundingBox)\n\nFind and return the point where a line from the center of bounding box bbox to point pt would, if continued, cross the edges of the box.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.pointinverse-Tuple{Point, Any, Any}","page":"Function reference","title":"Luxor.pointinverse","text":"pointinverse(A::Point, centerpoint::Point, rad)\n\nFind A′, the inverse of a point A with respect to a circle centerpoint/rad, such that:\n\ndistance(centerpoint, A) * distance(centerpoint, A′) == rad^2\n\nReturn (true, A′) or (false, A).\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.pointlinedistance-Tuple{Point, Point, Point}","page":"Function reference","title":"Luxor.pointlinedistance","text":"pointlinedistance(p::Point, a::Point, b::Point)\n\nFind the distance between a point p and a line between two points a and b.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.polar-Tuple{Any, Any}","page":"Function reference","title":"Luxor.polar","text":"polar(r, theta)\n\nConvert a point specified in polar form (radius and angle) to a Point.\n\npolar(10, pi/4)\n\nproduces\n\nLuxor.Point(7.071067811865475, 7.0710678118654755)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.poly","page":"Function reference","title":"Luxor.poly","text":"poly(bbox::BoundingBox, :action; kwargs...)\n\nMake a polygon around the BoundingBox in bbox.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.poly-Tuple{Vector{Point}}","page":"Function reference","title":"Luxor.poly","text":"Draw a polygon.\n\npoly(pointlist::Array{Point, 1}, action = :none;\n    close=false,\n    reversepath=false)\n\nCreate a path with the points in pointlist and apply action. By default poly() doesn't close or fill the polygon.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.polyarea-Tuple{Vector{Point}}","page":"Function reference","title":"Luxor.polyarea","text":"polyarea(p::Array)\n\nFind the area of a simple polygon. It works only for polygons that don't self-intersect. See also polyorientation().\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.polycentroid-Tuple{Vector{Point}}","page":"Function reference","title":"Luxor.polycentroid","text":"Find the centroid of a simple polygon.\n\npolycentroid(pointlist)\n\nReturns a point. This only works for simple (non-intersecting) polygons.\n\nYou could test the point using isinside().\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.polyclip-Tuple{Vector{Point}, Vector{Point}}","page":"Function reference","title":"Luxor.polyclip","text":"polyclip(s, c)\n\nReturn a polygon that defines the intersection between an subject polygon and the clip polygon.\n\nReturn nothing if the function can't find one.\n\nS - subject polygon - can be concave or convex.\n\nC - clip polygon - must be convex.\n\nUses the Sutherland-Hodgman clipping algorithm. Calls ispointonleftofline().\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.polycross","page":"Function reference","title":"Luxor.polycross","text":"polycross(pt::Point, radius, npoints::Int, ratio=0.5, orientation=0.0;\n    action      = :none,\n    splay       = 0.5,\n    vertices    = false,\n    reversepath = false)\npolycross(pt::Point, radius, npoints::Int, ratio=0.5, orientation=0.0, action;\n    splay       = 0.5,\n    vertices    = false,\n    reversepath = false)\n\nMake a cross-shaped polygon with npoints arms to fit inside a circle of radius radius centered at pt.\n\nratio specifies the ratio of the two sides of each arm. splay makes the arms ... splayed.\n\nUse vertices=true to return the vertices of the shape instead of executing the action.\n\n(Adapted from Compose.jl.xgon()))\n\nExamples\n\npolycross(O, 100, 5,\n    action = :fill,\n    splay  = 0.5)\n\npolycross(O, 120, 5, 0.5, 0.0, :stroke,\n    splay  = 0.5)\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.polydistances-Tuple{Vector{Point}}","page":"Function reference","title":"Luxor.polydistances","text":"polydistances(p::Array{Point, 1}; closed=true)\n\nReturn an array of the cumulative lengths of a polygon.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.polyfit","page":"Function reference","title":"Luxor.polyfit","text":"polyfit(plist::Array, npoints=30)\n\nBuild a polygon that constructs a B-spine approximation to it. The resulting list of points makes a smooth path that runs between the first and last points.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.polyhull-Tuple{Any}","page":"Function reference","title":"Luxor.polyhull","text":"polyhull(pts)\n\nFind all points in pts that form a convex hull around the points in pts, and return them.\n\nThis uses the Graham Scan algorithm.\n\nTODO : experimental, can be improved.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.polyintersect-Tuple{AbstractVector{Point}, AbstractVector{Point}}","page":"Function reference","title":"Luxor.polyintersect","text":"polyintersect(p1::AbstractArray{Point, 1}, p2::AbstractArray{Point, 1};\n    closed=true)\n\nTODO: Fix/test/improve this experimental polygon intersection routine.\n\nReturn the points where polygon p1 and polygon p2 cross.\n\nIf closed is false, the intersection points must lie on the first n - 1 lines of each polygon.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.polymorph-Tuple{Array{Vector{Point}}, Array{Vector{Point}}, Any}","page":"Function reference","title":"Luxor.polymorph","text":"polymorph(pgon1::Array{Array{Point,1}}, pgon2::Array{Array{Point,1}}, k;\n    samples = 100,\n    easingfunction = easingflat,\n    kludge = true\n    closed = true)\n\n\"morph\" is to gradually change from one thing to another. This function changes one polygon into another.\n\nIt returns an array of polygons, [p_1, p_2, p_3, ... ], where each polygon p_n is the intermediate shape between the corresponding shape in pgon1[1...n] and pgon2[1...n] at k, where 0.0 < k < 1.0. If k ≈ 0.0, the pgon1[1...n] is returned, and if `k ≈ 1.0, pgon2[1...n] is returned.\n\npgon1 and pgon2 can be either simple polygons or arrays of one or more polygonal shapes (eg as created by pathtopoly()). For example, pgon1 might consist of two polygonal shapes, a square and a triangular shaped hole inside; pgon2 might be a triangular shape with a square hole.\n\nIt makes sense for both arguments to have the same number of polygonal shapes. If one has more than another, some shapes would be lost when it morphs. But the suggestively-named kludge keyword argument, when set to (the default) true, tries to compensate for this.\n\nBy default, easingfunction = easingflat, so the intermediate steps are linear. If you use another easing function, intermediate steps are determined by the value of the easing function at k.\n\nBecause polysample() can treat the polygon as open or closed (with different results), you can specify how the sampling is done here, with the closed= keyword:\n\nclosed = true -> polygons are sampled as closed\nclosed = false -> polygons are sampled as open\nclosed = (true, false) -> first polygon is sampled as closed, second as open\n\nThis function isn't very efficient, because it copies the polygons and resamples them.\n\nTODO : experimental, can surely be improved.\n\nExtended help\n\nExamples\n\nThis simple morph between a small square and a larger octagon is controlled by the easing function easeinoutinversequad, which slows down around the middle of the transition.\n\nOnly the first shape of the returned polygon array is needed.\n\npgon1 = ngon(O, 30, 4, 0, vertices = true)\npgon2 = ngon(O, 220, 8, 0, vertices = true)\nfor i in 0:0.1:1.0\n    poly(first(polymorph(pgon1, pgon2, i,\n            easingfunction = easeinoutinversequad)),\n        action = :stroke,\n        close = true)\nend\n\nThis next example morphs between the first shape - a circle with a square hole - and the second shape, a square with a circular hole.\n\nngon(O - (250, 0), 30, 50, 0, :path)\nnewsubpath()\nngon(O - (250, 0), 10, 4, 0, reversepath = true, :path)\npg1 = pathtopoly()\n\nnewpath()\nngon(O + (250, 0), 30, 4, 0, :path)\nnewsubpath()\nngon(O + (250, 0), 10, 50, 0, reversepath = true, :path)\npg2 = pathtopoly()\n\nfor i in reverse(0.0:0.1:1.0)\n    randomhue()\n    newpath()\n    # use :path followed by fillpath() to preserve correct \"hole\"-iness\n    poly.(polymorph(pg1, pg2, i), :path, close = true)\n    fillpath()\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.polymove!-Tuple{Any, Point, Point}","page":"Function reference","title":"Luxor.polymove!","text":"polymove!(pgon, frompoint::Point, topoint::Point)\n\nMove (permanently) a polygon from frompoint to topoint.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.polyorientation-Tuple{Vector{Point}}","page":"Function reference","title":"Luxor.polyorientation","text":"polyorientation(pgon)\n\nReturns a number which is positive if the polygon is clockwise in Luxor...\n\nTODO This code is still experimental...\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.polyperimeter-Tuple{Vector{Point}}","page":"Function reference","title":"Luxor.polyperimeter","text":"polyperimeter(p::Array{Point, 1}; closed=true)\n\nFind the total length of the sides of polygon p.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.polyportion","page":"Function reference","title":"Luxor.polyportion","text":"polyportion(p::Array{Point, 1}, portion=0.5; closed=true, pdist=[])\n\nReturn a portion of a polygon, starting at a value between 0.0 (the beginning) and 1.0 (the end). 0.5 returns the first half of the polygon, 0.25 the first quarter, 0.75 the first three quarters, and so on.\n\nUse closed=false to exclude the line joining the final point to the first point from the calculations.\n\nIf you already have a list of the distances between each point in the polygon (the \"polydistances\"), you can pass them in pdist, otherwise they'll be calculated afresh, using polydistances(p, closed=closed).\n\nUse the complementary polyremainder() function to return the other part.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.polyreflect!","page":"Function reference","title":"Luxor.polyreflect!","text":"polyreflect!(pgon, pt1 = O, pt2 = O + (0, 100)\n\nReflect (permanently) a polygon in a line (default to the y-axis) joining two points.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.polyremainder","page":"Function reference","title":"Luxor.polyremainder","text":"polyremainder(p::Array{Point, 1}, portion=0.5; closed=true, pdist=[])\n\nReturn the rest of a polygon, starting at a value between 0.0 (the beginning) and 1.0 (the end). 0.5 returns the last half of the polygon, 0.25 the last three quarters, 0.75 the last quarter, and so on.\n\nUse closed=false to exclude the line joining the final point to the first point from the calculations.\n\nIf you already have a list of the distances between each point in the polygon (the \"polydistances\"), you can pass them in pdist, otherwise they'll be calculated afresh, using polydistances(p, closed=closed).\n\nUse the complementary polyportion() function to return the other part.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.polyremovecollinearpoints-Tuple{Vector{Point}}","page":"Function reference","title":"Luxor.polyremovecollinearpoints","text":"polyremovecollinearpoints(pgon::Array{Point, 1})\n\nReturn copy of polygon with no collinear points.\n\nCaution: may return an empty polygon... !\n\nTODO This code is still experimental...\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.polyrotate!-Tuple{Any, Any}","page":"Function reference","title":"Luxor.polyrotate!","text":"polyrotate!(pgon, θ;\n    center=O)\n\nRotate (permanently) a polygon around center by θ radians.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.polysample-Tuple{Vector{Point}, Integer}","page":"Function reference","title":"Luxor.polysample","text":"polysample(p::Array{Point, 1}, npoints::T where T <: Integer;\n        closed=true)\n\nSample the polygon p, returning a polygon with npoints to represent it. The first sampled point is:\n\n1/`npoints` * `perimeter of p`\n\naway from the original first point of p.\n\nIf npoints is the same as length(p) the returned polygon is the same as the original, but the first point finishes up at the end (so new=circshift(old, 1)).\n\nIf closed is true, the entire polygon (including the edge joining the last point to the first point) is sampled.\n\nIf include_first is true, the first point of plist is included in the result.\n\nIf the resulting polygon's first and end points are the same, the end point is discarded.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.polyscale!-Tuple{Any, Any, Any}","page":"Function reference","title":"Luxor.polyscale!","text":"polyscale!(pgon, sh, sv;\n    center=O)\n\nScale (permanently) a polygon by sh horizontally and sv vertically, relative to center.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.polyscale!-Tuple{Any, Any}","page":"Function reference","title":"Luxor.polyscale!","text":"polyscale!(pgon, s;\n   center=O)\n\nScale (permanently) a polygon by s, relative to center.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.polysmooth-Tuple{Vector{Point}, Any, Symbol}","page":"Function reference","title":"Luxor.polysmooth","text":"polysmooth(points, radius, action=:action; debug=false)\npolysmooth(points, radius; action=:none, debug=false)\n\nMake a closed path from the points and round the corners by making them arcs with the given radius. Execute the action when finished.\n\nThe arcs are sometimes different sizes: if the given radius is bigger than the length of the shortest side, the arc can't be drawn at its full radius and is therefore drawn as large as possible (as large as the shortest side allows).\n\nThe debug option also draws the construction circles at each corner.\n\nTODO Return something more useful than a Boolean.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.polysortbyangle","page":"Function reference","title":"Luxor.polysortbyangle","text":"Sort the points of a polygon into order. Points are sorted according to the angle they make with a specified point.\n\npolysortbyangle(pointlist::Array, refpoint=minimum(pointlist))\n\nThe refpoint can be chosen, but the default minimum point is usually OK too:\n\npolysortbyangle(parray, polycentroid(parray))\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.polysortbydistance-Tuple{Vector{Point}, Point}","page":"Function reference","title":"Luxor.polysortbydistance","text":"Sort a polygon by finding the nearest point to the starting point, then the nearest point to that, and so on.\n\npolysortbydistance(p, starting::Point)\n\nYou can end up with convex (self-intersecting) polygons, unfortunately.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.polysplit-Tuple{Vector{Point}, Point, Point}","page":"Function reference","title":"Luxor.polysplit","text":"polysplit(p, p1, p2)\n\nSplit a polygon into two where it intersects with a line. It returns two polygons:\n\n(poly1, poly2)\n\nThis doesn't always work, of course. For example, a polygon the shape of the letter \"E\" might end up being divided into more than two parts.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.polytopath-Tuple{Vector{Point}}","page":"Function reference","title":"Luxor.polytopath","text":"polytopath(ptlist)\n\nConvert a polygon to a Path object.\n\n@draw drawpath(polytopath(ngon(O, 145, 5, vertices = true)), action = :fill)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.polytriangulate-Tuple{Vector{Point}}","page":"Function reference","title":"Luxor.polytriangulate","text":"polytriangulate(plist::Array{Point,1}; epsilon = -0.01)\n\nTriangulate the polygon in plist.\n\nThis uses the Bowyer–Watson/Delaunay algorithm to make triangles. It returns an array of triangular polygons.\n\nTODO: This experimental polygon function is not very efficient, because it first copies the list of points (to avoid modifying the original), and sorts it, before making triangles.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.prettypoly","page":"Function reference","title":"Luxor.prettypoly","text":"prettypoly(bbox::BoundingBox, action; kwargs...)\n\nMake a decorated polygon around the BoundingBox in bbox. The vertices are in the order: bottom left, top left, top right, and bottom right.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.prettypoly-2","page":"Function reference","title":"Luxor.prettypoly","text":"prettypoly(points::Array{Point, 1}, vertexfunction = () -> circle(O, 2, :stroke);\n    action=:none,\n    close=false,\n    reversepath=false,\n    vertexlabels = (n, l) -> ()\n    )\n\nDraw the polygon defined by points, possibly closing and reversing it, using the current parameters, and then evaluate the vertexfunction function at every vertex of the polygon.\n\nThe default vertexfunction draws a 2 pt radius circle.\n\nTo mark each vertex of a polygon with a randomly colored filled circle:\n\np = star(O, 70, 7, 0.6, 0, vertices=true)\nprettypoly(p, action=:fill, () ->\n    begin\n        randomhue()\n        circle(O, 10, :fill)\n    end,\n    close=true)\n\nThe optional keyword argument vertexlabels lets you supply a function with two arguments that can access the current vertex number and the total number of vertices at each vertex. For example, you can label the vertices of a triangle \"1 of 3\", \"2 of 3\", and \"3 of 3\" using:\n\nprettypoly(triangle, action=:stroke,\n    vertexlabels = (n, l) -> (text(string(n, \" of \", l))))\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.preview-Tuple{}","page":"Function reference","title":"Luxor.preview","text":"preview()\n\nIf you're working in a notebook (eg Jupyter/IJulia), display a PNG or SVG file in the notebook.\n\nIf you're working in VS-Code, display a PNG or SVG file in the Plots pane.\n\nDrawings of type :image should be converted to a matrix with image_as_matrix() before calling finish().\n\nOtherwise:\n\non macOS, open the file in the default application, which is probably the Preview.app for PNG and PDF, and Safari for SVG\non Unix, open the file with xdg-open\non Windows, refer to COMSPEC.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.randomcolor-Tuple{}","page":"Function reference","title":"Luxor.randomcolor","text":"randomcolor()\n\nSet a random color. This may change the current alpha opacity too.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.randomhue-Tuple{}","page":"Function reference","title":"Luxor.randomhue","text":"randomhue()\n\nSet a random hue, without changing the current alpha opacity.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.randompoint-NTuple{4, Any}","page":"Function reference","title":"Luxor.randompoint","text":"randompoint(lowx, lowy, highx, highy)\n\nReturn a random point somewhere inside a rectangle defined by the four values.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.randompoint-Tuple{Point, Point}","page":"Function reference","title":"Luxor.randompoint","text":"randompoint(lowpt, highpt)\n\nReturn a random point somewhere inside the rectangle defined by the two points.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.randompointarray-NTuple{5, Any}","page":"Function reference","title":"Luxor.randompointarray","text":"randompointarray(lowx, lowy, highx, highy, n)\n\nReturn an array of n random points somewhere inside the rectangle defined by the four coordinates.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.randompointarray-Tuple{Any, Any, Any}","page":"Function reference","title":"Luxor.randompointarray","text":"randompointarray(w, h, d; attempts=20)\n\nReturn an array of randomly positioned points inside the rectangle defined by the current origin (0/0) and the width and height. d determines the minimum distance between each point. Increase attempts if you want the function to try harder to fill empty spaces; decrease it if it's taking too long to look for samples that work.\n\nThis uses Bridson's Poisson Disk Sampling algorithm: https://www.cs.ubc.ca/~rbridson/docs/bridson-siggraph07-poissondisk.pdf\n\nExample\n\nfor pt in randompointarray(BoundingBox(), 20)\n    randomhue()\n    circle(pt, 10, :fill)\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.randompointarray-Tuple{BoundingBox, Any}","page":"Function reference","title":"Luxor.randompointarray","text":"randompointarray(bbox::BoundingBox, d; attempts=20)\n\nReturn an array of randomly positioned points inside the bounding box d units apart.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.randompointarray-Tuple{Point, Point, Any}","page":"Function reference","title":"Luxor.randompointarray","text":"randompointarray(lowpt, highpt, n)\n\nReturn an array of n random points somewhere inside the rectangle defined by two points.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.rawlatexboundingbox-Tuple{LaTeXStrings.LaTeXString}","page":"Function reference","title":"Luxor.rawlatexboundingbox","text":"rawlatexboundingbox(lstr::LaTeXString, font_size=1)\n\nHelper function that returns the coordinate points of the bounding box containing the specific LaTeX text.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.readpng-Tuple{Any}","page":"Function reference","title":"Luxor.readpng","text":"readpng(pathname)\n\nRead a PNG file.\n\nThis returns a image object suitable for placing on the current drawing with placeimage(). You can access its width and height fields:\n\nimage = readpng(\"test-image.png\")\nw = image.width\nh = image.height\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.readsvg-Tuple{Any}","page":"Function reference","title":"Luxor.readsvg","text":"readsvg(str)\n\nRead an SVG image. str is either pathname or pure SVG code. This returns an SVG image object suitable for placing on the current drawing with placeimage().\n\nPlacing an SVG file:\n\n@draw begin\n    mycoollogo = readsvg(\"mylogo.svg\")\n    placeimage(mycoollogo)\nend\n\nPlacing SVG code:\n\n# from https://github.com/edent/SuperTinyIcons\njulialogocode = \"\"\"<svg xmlns=\"http://www.w3.org/2000/svg\"\n    aria-label=\"Julia\" role=\"img\"\n    viewBox=\"0 0 512 512\">\n    <rect width=\"512\" height=\"512\" rx=\"15%\" fill=\"#fff\"/>\n    <circle fill=\"#389826\" cx=\"256\" cy=\"137\" r=\"83\"/>\n    <circle fill=\"#cb3c33\" cx=\"145\" cy=\"329\" r=\"83\"/>\n    <circle fill=\"#9558b2\" cx=\"367\" cy=\"329\" r=\"83\"/>\n</svg>\"\"\"\n\n@draw begin\n    julia_logo = readsvg(julialogocode)\n    placeimage(julia_logo, centered=true)\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.rect-NTuple{4, Real}","page":"Function reference","title":"Luxor.rect","text":"rect(xmin, ymin, w, h; action=:none)\nrect(xmin, ymin, w, h, action)\n\nCreate a rectangle with one corner at (xmin/ymin) with width w and height h, and add it to the current path. Then apply action.\n\nReturns a tuple of two points, the corners of a bounding box that encloses the rectangle.\n\nSee box() for more ways to do similar things, such as supplying two opposite corners, placing by centerpoint and dimensions.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.rect-Tuple{Point, Real, Real}","page":"Function reference","title":"Luxor.rect","text":"rect(cornerpoint, w, h; action = none, reversepath=false,\n    vertices=false)\nrect(cornerpoint, w, h, action; reversepath=false,\n    vertices=false)\n\nCreate a rectangle with one corner at cornerpoint with width w and height h, and add it to the current path. Then apply action.\n\nUse vertices=true to return an array of the four corner points: bottom left, top left, top right, bottom right.\n\nreversepath reverses the direction of the path (and returns points in the order: bottom left, bottom right, top right, top left).\n\nReturns the four corner vertices.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.rescale","page":"Function reference","title":"Luxor.rescale","text":"rescale(x, from_min, from_max, to_min=0.0, to_max=1.0)\n\nConvert x from one linear scale (from_min to from_max) to another (to_min to to_max).\n\nThe scales can also be supplied in tuple form:\n\nrescale(x, (from_min, from_max), (to_min, to_max))\n\nusing Luxor\njulia> rescale(15, 0, 100, 0, 1)\n0.15\n\njulia> rescale(15, (0, 100), (0, 1))\n0.15\n\njulia> rescale(pi/20, 0, 2pi, 0, 1)\n0.025\n\njulia> rescale(pi/20, (0, 2pi), (0, 1))\n0.025\n\njulia> rescale(25, 0, 1, 0, 1.609344)\n40.2336\n\njulia> rescale(15, (0, 100), (1000, 0))\n850.0\n\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.rline-Tuple{Any, Any}","page":"Function reference","title":"Luxor.rline","text":"rline(pt)\n\nAdd a line relative to the current position to the pt.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.rmove-Tuple{Any, Any}","page":"Function reference","title":"Luxor.rmove","text":"rmove(pt)\n\nBegin a new subpath in the current path, add pt to the current path's current point, then update the current point.\n\nOther path-building functions are move(), line(), curve(), arc(), and rline().\n\nThere must be a current point before you call this function.\n\nSee also currentpoint() and hascurrentpoint().\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.rotate-Tuple{Any}","page":"Function reference","title":"Luxor.rotate","text":"rotate(a::Float64)\n\nRotate the current workspace by a radians clockwise (from positive x-axis to positive y-axis).\n\nValues are relative to the current orientation.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.rotatepoint-Tuple{Point, Any}","page":"Function reference","title":"Luxor.rotatepoint","text":"rotatepoint(targetpt::Point, angle)\n\nRotate a target point around the current origin by an angle specified in radians.\n\nReturns the new point.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.rotatepoint-Tuple{Point, Point, Any}","page":"Function reference","title":"Luxor.rotatepoint","text":"rotatepoint(targetpt::Point, originpt::Point, angle)\n\nRotate a target point around another point by an angle specified in radians.\n\nReturns the new point.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.rotationmatrix-Tuple{Any}","page":"Function reference","title":"Luxor.rotationmatrix","text":"rotationmatrix(a)\n\nReturn a 3x3 Julia matrix that will apply a rotation through a radians.\n\nSee getmatrix() for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.rule","page":"Function reference","title":"Luxor.rule","text":"rule(pos, theta;\n    boundingbox=BoundingBox(),\n    vertices=false)\n\nDraw a straight line through pos at an angle theta from the x axis.\n\nBy default, the line spans the entire drawing, but you can supply a BoundingBox to change the extent of the line.\n\nrule(O)       # draws an x axis\nrule(O, pi/2) # draws a  y axis\n\nThe function:\n\nrule(O, pi/2, boundingbox=BoundingBox()/2)\n\ndraws a line that spans a bounding box half the width and height of the drawing, and returns a Set of end points. If you just want the vertices and don't want to draw anything, use vertices=true.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.rulers-Tuple{}","page":"Function reference","title":"Luxor.rulers","text":"rulers()\n\nDraw and label two CAD-style rulers starting at O, the current 0/0, and continuing out along the current positive x and y axes.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.scale-Tuple{Real, Real}","page":"Function reference","title":"Luxor.scale","text":"scale(x, y)\n\nScale the current workspace by different values in x and y.\n\nValues are relative to the current scale. Example:\n\nscale(0.2, 0.3)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.scale-Tuple{Real}","page":"Function reference","title":"Luxor.scale","text":"scale(f)\n\nScale the current workspace by f in both x and y directions.\n\nValues are relative to the current scale.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.scalingmatrix-Tuple{Any, Any}","page":"Function reference","title":"Luxor.scalingmatrix","text":"scalingmatrix(sx, sy)\n\nReturn a 3x3 Julia matrix that will apply a scaling by sx and sy.\n\nSee getmatrix() for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.sector-NTuple{4, Real}","page":"Function reference","title":"Luxor.sector","text":"sector(innerradius::Real, outerradius::Real, startangle::Real, endangle::Real;\n   action=:none)\n\nMake an annular sector centered at the origin, and add it to the current path.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.sector-Tuple{Point, Real, Real, Real, Real, Real}","page":"Function reference","title":"Luxor.sector","text":"sector(centerpoint::Point, innerradius, outerradius,\n        startangle, endangle, cornerradius;\n       action:none)\n\nMake an annular sector with rounded corners, basically a bent sausage shape, centered at centerpoint, and add it to the current path.\n\nTODO: The results aren't 100% accurate at the moment. There are small discontinuities where the curves join.\n\nTODO - return something more useful than a Boolean\n\nThe cornerradius is reduced from the supplied value if neceesary to prevent overshoots.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.sector-Tuple{Point, Real, Real, Real, Real}","page":"Function reference","title":"Luxor.sector","text":"sector(centerpoint::Point, innerradius, outerradius, startangle, endangle;\n    action=:none)\n\nMake an annular sector centered at centerpoint, and add it to the current path.\n\nTODO - return something more useful than a Boolean\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.sector-Tuple{Real, Real, Real, Real, Real, Symbol}","page":"Function reference","title":"Luxor.sector","text":"sector(innerradius::Real, outerradius::Real, startangle::Real, endangle::Real,\n   cornerradius::Real, action)\n\nMake an annular sector with rounded corners, centered at the current origin, and add it to the current path.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.setantialias-Tuple{Any}","page":"Function reference","title":"Luxor.setantialias","text":"setantialias(n)\n\nSet the current antialiasing to a value between 0 and 6:\n\nantialias_default  = 0, the default antialiasing for the subsystem and target device\nantialias_none     = 1, use a bilevel alpha mask\nantialias_gray     = 2, use single-color antialiasing (using shades of gray for black text on a white background, for example)\nantialias_subpixel = 3, take advantage of the order of subpixel elements on devices such as LCD panels\nantialias_fast     = 4, perform some antialiasing but prefer speed over quality\nantialias_good     = 5, balance quality against performance\nantialias_best     = 6, render at the highest quality, sacrificing speed if necessary\n\nThis affects subsequent graphics, but not text, and it doesn't apply to all types of output file.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.setbezierhandles-Tuple{BezierPathSegment}","page":"Function reference","title":"Luxor.setbezierhandles","text":"setbezierhandles(bps::BezierPathSegment;\n        angles  = [0.05, -0.1],\n        handles = [0.3, 0.3])\n\nReturn a new BezierPathSegment with new locations for the Bezier control points in the BezierPathSegment bps.\n\nangles are the two angles that the \"handles\" make with the line direciton.\n\nhandles are the lengths of the \"handles\". 0.3 is a typical value.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.setbezierhandles-Tuple{BezierPath}","page":"Function reference","title":"Luxor.setbezierhandles","text":"setbezierhandles(bezpath::BezierPath;\n    angles=[0 .05, -0.1],\n    handles=[0.3, 0.3])\n\nReturn a new BezierPath with new locations for the Bézier control points in every Bézier path segment of the BezierPath in bezpath.\n\nangles are the two angles that the \"handles\" make with the line direciton.\n\nhandles are the lengths of the \"handles\". 0.3 is a typical value.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.setblend-Tuple{Cairo.CairoPattern}","page":"Function reference","title":"Luxor.setblend","text":"setblend(blend)\n\nStart using the named blend for filling graphics.\n\nThis aligns the original coordinates of the blend definition with the current axes.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.setblendextend-Tuple{Cairo.CairoPattern, Any}","page":"Function reference","title":"Luxor.setblendextend","text":"setblendextend(blend::Blend, mode)\n\nSpecify how color blend patterns are repeated/extended. Supply the blend and one of the following strings:\n\n\"repeat\":  the pattern is repeated\n\"reflect\": the pattern is reflected (repeated in reverse)\n\"pad\": outside the pattern, use the closest color\n\"none\": outside of the pattern, use transparent pixels\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.setcolor-Tuple{AbstractString}","page":"Function reference","title":"Luxor.setcolor","text":"setcolor(\"gold\")\nsetcolor(\"darkturquoise\")\n\nSet the current color to a named color. This use the definitions in Colors.jl to convert a string to RGBA eg setcolor(\"gold\") or \"green\", \"darkturquoise\", \"lavender\", etc. The list is at Colors.color_names.\n\nUse sethue() for changing colors without changing current opacity level.\n\nsethue() and setcolor() return the three or four values that were used:\n\njulia> setcolor(sethue(\"red\")..., .8)\n\n(1.0, 0.0, 0.0, 0.8)\n\njulia> sethue(setcolor(\"red\")[1:3]...)\n\n(1.0, 0.0, 0.0)\n\nYou can also do:\n\nusing Colors\nsethue(colorant\"red\")\n\nSee also setcolor.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.setcolor-Tuple{ColorTypes.Colorant}","page":"Function reference","title":"Luxor.setcolor","text":"setcolor(r, g, b)\nsetcolor(r, g, b, alpha)\nsetcolor(color)\nsetcolor(col::Colors.Colorant)\nsetcolor(sethue(\"red\")..., .2)\n\nSet the current color.\n\nExamples:\n\nsetcolor(convert(Colors.HSV, Colors.RGB(0.5, 1, 1)))\nsetcolor(.2, .3, .4, .5)\nsetcolor(convert(Colors.HSV, Colors.RGB(0.5, 1, 1)))\n\nfor i in 1:15:360\n   setcolor(convert(Colors.RGB, Colors.HSV(i, 1, 1)))\n   ...\nend\n\nSee also sethue.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.setcolor-Tuple{NTuple{4, Number}}","page":"Function reference","title":"Luxor.setcolor","text":"setcolor((r, g, b, a))\n\nSet the color to the tuple's values.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.setcolor-Tuple{Tuple{Number, Number, Number}}","page":"Function reference","title":"Luxor.setcolor","text":"setcolor((r, g, b))\n\nSet the color to the tuple's values.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.setdash","page":"Function reference","title":"Luxor.setdash","text":"setdash(dashes::Vector, offset=0.0)\n\nSet the dash pattern for lines to the values in dashes. The first number is the length of the inked portion, the second the space, and so on.\n\nThe offset specifies an offset into the pattern at which the stroke begins. So an offset of 10 means that the stroke starts at dashes[1] + 10 into the pattern.\n\nOr use setdash(\"dot\") etc.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.setdash-Tuple{AbstractString}","page":"Function reference","title":"Luxor.setdash","text":"setdash(\"dot\")\n\nSet the dash pattern of lines to one of: \"solid\", \"dotted\", \"dot\", \"dotdashed\", \"longdashed\", \"shortdashed\", \"dash\", \"dashed\", \"dotdotdashed\", \"dotdotdotdashed\".\n\nUse setdash(dashes::Vector) to specify the pattern numerically.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.setfont-Tuple{AbstractString, Any}","page":"Function reference","title":"Luxor.setfont","text":"setfont(family, fontsize)\n\nSelect a font and specify the size.\n\nExample:\n\nsetfont(\"Helvetica\", 24)\nsettext(\"Hello in Helvetica 24 using the Pro API\", Point(0, 10))\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.setgray-Tuple{Any}","page":"Function reference","title":"Luxor.setgray","text":"setgray(n)\nsetgrey(n)\n\nSet the color to a gray level of n, where n is between 0 and 1.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.sethue-Tuple{AbstractString}","page":"Function reference","title":"Luxor.sethue","text":"sethue(\"black\")\nsethue(0.3, 0.7, 0.9)\nsetcolor(sethue(\"red\")..., .2)\n\nSet the color without changing opacity.\n\nsethue() is like setcolor(), but we sometimes want to change the current color without changing alpha/opacity. Using sethue() rather than setcolor() doesn't change the current alpha opacity.\n\nSee also setcolor.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.sethue-Tuple{Any, Any, Any}","page":"Function reference","title":"Luxor.sethue","text":"sethue(0.3, 0.7, 0.9)\n\nSet the color's r, g, b values. Use setcolor(r, g, b, a) to set transparent colors.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.sethue-Tuple{ColorTypes.Colorant}","page":"Function reference","title":"Luxor.sethue","text":"sethue(col::Colors.Colorant)\n\nSet the color without changing the current alpha/opacity:\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.sethue-Tuple{NTuple{4, Number}}","page":"Function reference","title":"Luxor.sethue","text":"sethue((r, g, b, a))\n\nSet the color to the tuple's values.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.sethue-Tuple{Tuple{Number, Number, Number}}","page":"Function reference","title":"Luxor.sethue","text":"sethue((r, g, b))\n\nSet the color to the tuple's values.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.setline-Tuple{Any}","page":"Function reference","title":"Luxor.setline","text":"setline(n)\n\nSet the line width, in points.\n\nUse getline() to get the current value.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.setlinecap","page":"Function reference","title":"Luxor.setlinecap","text":"setlinecap(s)\n\nSet the line ends. s can be \"butt\" or :butt (the default), \"square\" or :square, or \"round\" or :round.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.setlinejoin","page":"Function reference","title":"Luxor.setlinejoin","text":"setlinejoin(\"miter\")\nsetlinejoin(\"round\")\nsetlinejoin(\"bevel\")\n\nSet the way line segments are joined when the path is stroked.\n\nThe default joining style is \"mitered\".\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.setmatrix-Tuple{Array}","page":"Function reference","title":"Luxor.setmatrix","text":"setmatrix(m::Array)\n\nChange the current matrix to 6-element matrix m.\n\nSee getmatrix() for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.setmesh-Tuple{Cairo.CairoPattern}","page":"Function reference","title":"Luxor.setmesh","text":"setmesh(mesh::Mesh)\n\nSelect a mesh, previously created with mesh(), for filling and stroking subsequent graphics.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.setmode-Tuple{AbstractString}","page":"Function reference","title":"Luxor.setmode","text":"setmode(mode::AbstractString)\n\nSet the compositing/blending mode. mode can be one of:\n\n\"clear\" Where the second object is drawn, the first is completely removed.\n\"source\" The second object is drawn as if nothing else were below.\n\"over\" The default mode: like two transparent slides overlapping.\n\"in\" The first object is removed completely, the second is only drawn where the first was.\n\"out\" The second object is drawn only where the first one wasn't.\n\"atop\" The first object is mostly intact, but mixes both objects in the overlapping area. The second object is not drawn elsewhere.\n\"dest\" Discard the second object completely.\n\"dest_over\" Like \"over\" but draw second object below the first\n\"dest_in\" Keep the first object whereever the second one overlaps.\n\"dest_out\" The second object is used to reduce the visibility of the first where they overlap.\n\"dest_atop\" Like \"over\" but draw second object below the first.\n\"xor\" XOR where the objects overlap\n\"add\" Add the overlapping areas together\n\"saturate\" Increase Saturation where objects overlap\n\"multiply\" Multiply where objects overlap\n\"screen\" Input colors are complemented and multiplied, the product is complemented again. The result is at least as light as the lighter of the input colors.\n\"overlay\" Multiplies or screens colors, depending on the lightness of the destination color.\n\"darken\" Selects the darker of the color values in each component.\n\"lighten\" Selects the lighter of the color values in each component.\n\nSee the Cairo documentation for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.setopacity-Tuple{Any}","page":"Function reference","title":"Luxor.setopacity","text":"setopacity(alpha)\n\nSet the current opacity to a value between 0 and 1. This modifies the alpha value of the current color.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.setstrokescale-Tuple{Bool}","page":"Function reference","title":"Luxor.setstrokescale","text":"setstrokescale(state::Bool)\n\nEnable/disable stroke scaling for the current drawing.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.setstrokescale-Tuple{}","page":"Function reference","title":"Luxor.setstrokescale","text":"setstrokescale()\n\nReturn the current stroke scaling setting.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.settext-Tuple{AbstractString, Point}","page":"Function reference","title":"Luxor.settext","text":"settext(text, pos;\n    halign = \"left\",\n    valign = \"bottom\",\n    angle  = 0, # degrees!\n    markup = false)\n\nsettext(text;\n    kwargs)\n\nDraw the text at pos (if omitted defaults to 0/0). If no font is specified, on macOS the default font is Times Roman.\n\nTo align the text, use halign, one of \"left\", \"center\", or \"right\", and valign, one of \"top\", \"center\", or \"bottom\".\n\nangle is the rotation - in counterclockwise degrees, rather than Luxor's default clockwise (+x-axis to +y-axis) radians.\n\nIf markup is true, then the string can contain some HTML-style markup. Supported tags include:\n\n<b>, <i>, <s>, <sub>, <sup>, <small>, <big>, <u>, <tt>, and <span>\n\nThe <span> tag can contains things like this:\n\n<span font='26' background='green' foreground='red'>unreadable text</span>\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.shiftbezierhandles-Tuple{BezierPathSegment}","page":"Function reference","title":"Luxor.shiftbezierhandles","text":"shiftbezierhandles(bps::BezierPathSegment;\n    angles=[0.1, -0.1],\n    handles=[1.1, 1.1])\n\nReturn a new BezierPathSegment that modifies the Bézier path in bps by moving the control handles. The values in angles increase the angle of the handles; the values in handles modifies the lengths: 1 preserves the length, 0.5 halves the length of the  handles, 2 doubles them.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.simplify","page":"Function reference","title":"Luxor.simplify","text":"Simplify a polygon:\n\nsimplify(pointlist::Array, detail=0.1)\n\ndetail is the maximum approximation error of simplified polygon.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.slope-Tuple{Any, Any}","page":"Function reference","title":"Luxor.slope","text":"slope(pointA::Point, pointB::Point)\n\nFind angle of a line starting at pointA and ending at pointB.\n\nReturn a value between 0 and 2pi. Value will be relative to the current axes.\n\nslope(O, Point(0, 100)) |> rad2deg # y is positive down the page\n90.0\n\nslope(Point(0, 100), O) |> rad2deg\n270.0\n\nThe slope isn't the same as the gradient. A vertical line going up has a slope of 3π/2.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.snapshot-Tuple{}","page":"Function reference","title":"Luxor.snapshot","text":"snapshot(;\n    fname = :png,\n    cb = missing,\n    scalefactor = 1.0,\n    addmarker = true)\n\nsnapshot(fname, cb, scalefactor)\n-> finished snapshot drawing, for display\n\nTake a snapshot and save to 'fname' name and suffix. This requires that the current drawing is a recording surface. You can continue drawing on the same recording surface.\n\nArguments\n\nfname the file name or symbol, see Drawing\n\ncb crop box::BoundingBox - what's inside is copied to snapshot\n\nscalefactor snapshot width/crop box width. Same for height.\n\naddmarker for more information about addmarker see help for Luxor._adjust_background_rects\n\n?Luxor._adjust_background_rects\n\nExamples\n\nsnapshot()\nsnapshot(fname = \"temp.png\")\nsnaphot(fname = :svg)\ncb = BoundingBox(Point(0, 0), Point(102.4, 96))\nsnapshot(cb = cb)\npngdrawing = snapshot(fname = \"temp.png\", cb = cb, scalefactor = 10)\n\nThe last example would return and also write a png drawing with 1024 x 960 pixels to storage.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.spiral-Tuple{Any, Any}","page":"Function reference","title":"Luxor.spiral","text":"spiral(a, b;\n    action = :none,\n    stepby = 0.01,\n    period = 4pi,\n    vertices = false,\n    log =false)\nspiral(a, b, action;\n    stepby = 0.01,\n    period = 4pi,\n    vertices = false,\n    log =false)\n\nMake a spiral, and add it to the current path. The two primary parameters a and b determine the start radius, and the tightness.\n\nFor linear spirals (log=false), b values are:\n\nlituus: -2\n\nhyperbolic spiral: -1\n\nArchimedes' spiral: 1\n\nFermat's spiral: 2\n\nFor logarithmic spirals (log=true):\n\ngolden spiral: b = ln(phi)/ (pi/2) (about 0.30)\n\nValues of b around 0.1 produce tighter, staircase-like spirals.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.splitbezier-Tuple{BezierPathSegment, Any}","page":"Function reference","title":"Luxor.splitbezier","text":"splitbezier(bps::BezierPathSegment, t)\n\nSplit the Bezier path segment at t, where t is between 0 and 1.\n\nUse Paul de Casteljaus' algorithm (the man who really introduced Bezier curves...).\n\nReturns a tuple of two BezierPathSegments, the 'lower' one (0 to t) followed by the 'higher' one (t to 1).\n\nExample\n\njulia> l\nbps = BezierPathSegment(ngon(O, 200, 4, vertices=true)...)\nl, h = splitbezier(bps::BezierPathSegment, 0.5)\n\njulia> h\n4-element BezierPathSegment:\n Point(1.2246467991473532e-14, 200.0)\n Point(-100.0, 100.00000000000001)\n Point(-100.0, 1.4210854715202004e-14)\n Point(-50.00000000000001, -49.99999999999999)\n\njulia> l.p2 == h.p1 true\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.splittext-Tuple{AbstractString}","page":"Function reference","title":"Luxor.splittext","text":"splittext(s)\n\nSplit the text in string s into an array, but keep all the separators attached to the preceding word.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.squircle-Tuple{Point, Real, Real}","page":"Function reference","title":"Luxor.squircle","text":"squircle(center::Point, hradius, vradius;\n    action=:none,\n    rt = 0.5, stepby = pi/40, vertices=false)\nsquircle(center::Point, hradius, vradius, action;\n    rt = 0.5, stepby = pi/40, vertices=false)\n\nMake a squircle or superellipse (basically a rectangle with rounded corners), and add it to the current path. Specify the center position, horizontal radius (distance from center to a side), and vertical radius (distance from center to top or bottom):\n\nThe root (rt) option defaults to 0.5, and gives an intermediate shape. Values less than 0.5 make the shape more rectangular. Values above make the shape more round. The horizontal and vertical radii can be different.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.star","page":"Function reference","title":"Luxor.star","text":"star(center, radius, npoints, ratio=0.5, orientation, action=:none;\n    vertices = false, reversepath=false)\nstar(center, radius, npoints, ratio=0.5, orientation=0.0;\n    action=:none, vertices = false, reversepath=false)\n\nMake a star centered at center with npoints sections oriented by orientation. ratio specifies the height of the smaller radius of the star relative to the larger.\n\nReturns the vertices of the star.\n\nUse vertices=true to only return the vertices of a star instead of making it.\n\nExamples\n\nstar(O, 120, 5, 0.5, 0.0, :fill,\n    vertices = false,\n    reversepath=false)\n\nstar(O, 220, 5, 0.5;\n    action=:stroke,\n    vertices = false,\n    reversepath=false)\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.storepath-Tuple{}","page":"Function reference","title":"Luxor.storepath","text":"storepath()\n\nObtain the current Cairo path and make a Luxor Path object, which is an array of PathElements.\n\nReturns the Path object.\n\nYou can draw stored paths using drawpath().\n\nSee also getpath(), getpathflat(), and textpath().\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.strokepath-Tuple{}","page":"Function reference","title":"Luxor.strokepath","text":"strokepath()\n\nStroke the current path with the current line width, line join, line cap, dash, and stroke scaling settings. The current path is then emptied.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.strokepreserve-Tuple{}","page":"Function reference","title":"Luxor.strokepreserve","text":"strokepreserve()\n\nStroke the current path with current line width, line join, line cap, dash, and stroke scaling settings, but then keep the path current.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.svgstring-Tuple{}","page":"Function reference","title":"Luxor.svgstring","text":"svgstring()\n\nReturn the current and recently completed SVG drawing as a string of SVG commands.\n\nReturns \"\" if there is no SVG information available.\n\nTo display the SVG string as a graphic, try the HTML() function in Base.\n\n...\nHTML(svgstring())\n\nIn a Pluto notebook, you can also display the SVG using:\n\n# using PlutoUI\n...\nPlutoUI.Show(MIME\"image/svg+xml\"(), svgstring())\n\n(This lets you right-click to save the SVG.)\n\nExample\n\nThis example examines the generated SVG code produced by drawing the Julia logo.\n\nDrawing(500, 500, :svg)\norigin()\njulialogo()\nfinish()\ns = svgstring()\neachmatch(r\"rgb.*?;\", s) |> collect\n    6-element Vector{RegexMatch}:\n    RegexMatch(\"rgb(100%,100%,100%);\")\n    RegexMatch(\"rgb(0%,0%,0%);\")\n    RegexMatch(\"rgb(79.6%,23.5%,20%);\")\n    RegexMatch(\"rgb(25.1%,38.8%,84.7%);\")\n    RegexMatch(\"rgb(58.4%,34.5%,69.8%);\")\n    RegexMatch(\"rgb(22%,59.6%,14.9%);\")\n\nHere's another example, post-processing the SVG file with the svgo optimizer.\n\n@drawsvg begin\n    background(\"midnightblue\")\n    fontface(\"JuliaMono-Regular\")\n    fontsize(20)\n    sethue(\"gold\")\n    text(\"JuliaMono: a monospaced font \", halign=:center)\n    text(\"with reasonable Unicode support\", O + (0, 22), halign=:center)\nend 500 150\nwrite(\"txt.svg\", svgstring())\n# minimize SVG\nrun(`svgo txt.svg -o txt-min.svg`)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.texalign-Tuple{Any, Any, Point, Point, Any}","page":"Function reference","title":"Luxor.texalign","text":"texalign(halign, valign, bottom_pt, top_pt, font_size)\n\nHelper function to align LaTeX text properly. Returns translate_x and translate_y which consists of the amount to be shifted depending on the type of alignment chosen and the bounding box of the text.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.text-Tuple{AbstractString, Point}","page":"Function reference","title":"Luxor.text","text":"text(str)\ntext(str, pos)\ntext(str, pos, angle = pi/2)\ntext(str, x, y)\ntext(str, pos, halign = :left)\ntext(str, valign = :baseline)\ntext(str, valign = :baseline, halign = :left)\ntext(str, pos, valign = :baseline, halign = :left)\ntext(latexstr, pos, valign = :baseline, halign = :left, rotationfixed = false, angle = 0)\n\nDraw the text in the string str at x/y or pt, placing the start of the string at the point. If you omit the point, it's placed at the current 0/0.\n\nangle specifies the rotation of the text relative to the current x-axis.\n\nHorizontal alignment halign can be :left, :center, (also :centre) or :right.  Vertical alignment valign can be :baseline, :top, :middle, or :bottom.\n\nThe default alignment is :left, :baseline.\n\nThis function uses Cairo's Toy text API.\n\nSee also textextents(), settext(), label().\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.text-Tuple{LaTeXStrings.LaTeXString, Point}","page":"Function reference","title":"Luxor.text","text":"text(lstr::LaTeXString, pt::Point;\n    valign=:baseline,\n    halign=:left,\n    rotationfixed = false,\n    angle=0,\n    paths=false,\n    kwargs...)\n\nDraws LaTeX string using MathTexEngine.jl. Hence, uses ModernCMU as font family. When rotationfixed = true, the text will rotate around its own axis, instead of rotating around pt.\n\nIf paths is true, text paths are added to the current path, rather than drawn.\n\nusing Luxor\nusing MathTeXEngine\nusing LaTeXStrings\n@draw begin\n    fontsize(70)\n    text(L\"e^{i\\pi} + 1 = 0\", halign=:center)\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.textbox","page":"Function reference","title":"Luxor.textbox","text":"textbox(s::T where T <: AbstractString, pos::Point=O;\n    leading = 12,\n    linefunc::Function = (linenumber, linetext, startpos, height) -> (),\n    alignment=:left)\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.textbox-2","page":"Function reference","title":"Luxor.textbox","text":"textbox(lines::Array, pos::Point=O;\n    leading = 12,\n    linefunc::Function = (linenumber, linetext, startpos, height) -> (),\n    alignment=:left)\n\nDraw the strings in the array lines vertically downwards. leading controls the spacing between each line (default 12), and alignment determines the horizontal alignment (default :left).\n\nOptionally, before each line, execute the function linefunc(linenumber, linetext, startpos, height).\n\nReturns the position of what would have been the next line.\n\nSee also textwrap(), which modifies the text so that the lines fit into a specified width.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.textcurve","page":"Function reference","title":"Luxor.textcurve","text":"textcurve(the_text, start_angle, start_radius, pos;\n      # optional keyword arguments:\n      spiral_ring_step = 0,    # step out or in by this amount\n      letter_spacing = 0,      # tracking/space between chars, tighter is (-), looser is (+)\n      spiral_in_out_shift = 0, # + values go outwards, - values spiral inwards\n      clockwise = true\n      )\n\nPlace a string of text on a curve. It can spiral in or out.\n\nstart_angle is relative to +ve x-axis, arc/circle is centered on pos with radius start_radius.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.textcurvecentered-Tuple{AbstractString, Any, Any, Point}","page":"Function reference","title":"Luxor.textcurvecentered","text":"textcurvecentered(the_text, the_angle, the_radius, center::Point;\n      clockwise = true,\n      letter_spacing = 0,\n      baselineshift = 0\n\nThis version of the textcurve() function is designed for shorter text strings that need positioning around a circle. (A cheesy effect much beloved of hipster brands and retronauts.)\n\nletter_spacing adjusts the tracking/space between chars, tighter is (-), looser is (+)). baselineshift moves the text up or down away from the baseline.\n\ntextcurvecentred (UK spelling) is a synonym.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.textextents-Tuple{AbstractString}","page":"Function reference","title":"Luxor.textextents","text":"textextents(str)\n\nReturn an array of six Float64s containing the measurements of the string str when set using the current font settings (Toy API):\n\n1 x_bearing\n\n2 y_bearing\n\n3 width\n\n4 height\n\n5 x_advance\n\n6 y_advance\n\nThe x and y bearings are the displacement from the reference point to the upper-left corner of the bounding box. It is often zero or a small positive value for x displacement, but can be negative x for characters like \"j\"; it's almost always a negative value for y displacement.\n\nThe width and height then describe the size of the bounding box. The advance takes you to the suggested reference point for the next letter. Note that bounding boxes for subsequent blocks of text can overlap if the bearing is negative, or the advance is smaller than the width would suggest.\n\nExample:\n\ntextextents(\"R\")\n\nreturns\n\n[1.18652; -9.68335; 8.04199; 9.68335; 9.74927; 0.0]\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.textfit","page":"Function reference","title":"Luxor.textfit","text":"textfit(str, bbox::BoundingBox, maxfontsize = 800;\n     horizontalmargin=12,\n     leading=100)\n\nFit the string str into the bounding box bbox by adjusting the font size and line breaks.\n\nInstead of using the current font size, the largest possible value will be calculated. You can specify a size limit in maxfontsize, such that the text will never be larger than this value, although it may have to be smaller.\n\nhorizontalmargin is applied to each side.\n\nOptionally, leading can be supplied, and this will be interpreted as a percentage of the final calculated font size. The default value is 110 (%).\n\nThe function returns a named tuple with information about the calculated values:\n\n(fontsize = 37.6, linecount = 5, finalpos = Point(-117.43, 92.60)\n\nnote: Note\nThis function is in need of improvement. It's quite difficult to find out the height of a line of text in a specific font. (Unless we import FreeType.) Suggestions for improvements welcome!\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Luxor.textlines-Tuple{AbstractString, Real}","page":"Function reference","title":"Luxor.textlines","text":"textlines(s::T where T <: AbstractString, width::Real;\n     rightgutter=5)\n\nSplit the text in s into lines up to width units wide (in the current font).\n\nReturns an array of strings. Use textwrap to draw an array of strings.\n\nTODO: A rightgutter optional keyword adds some padding to the right hand side of the column. This appears to be needed sometimes -— perhaps the algorithm needs improving to take account of the interaction of textextents and spaces?\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.textonpoly-Tuple{AbstractString, Any}","page":"Function reference","title":"Luxor.textonpoly","text":"textonpoly(str, pgon;\n        tracking = 0,\n        startoffset = 0.0,\n        baselineshift = 0.0,\n        closed = false)\n\nDraw the text in str along the route of the polygon in pgon.\n\nThe closed option determines whether the final edge of the polygon (joining the last point to the first) is included or not. Eg if you want to draw a string around all three sides of a triangle, you'd use closed=true:\n\ntextonpoly(\"mèdeis ageômetrètos eisitô mou tèn\nstegèn - let no one ignorant of geometry come under my roof\n\",\n    ngon(O, 100, 3, vertices=true),\n    closed=true)\n\nIf false, only two sides are considered.\n\nIncrease tracking from 0 to add space between the glyphs.\n\nThe startoffset value is a normalized percentage that specifies the start position. So, to start drawing the text halfway along the polygon, specify a start offset value of 0.5.\n\nPositive values for baselineshift move the characters upwards from the baseline.\n\nReturns a tuple with the number of characters drawn, and the final value of the index, between 0.0 and 1.0. If the returned index value is less than 1, this means that the text supplied ran out before the end of the polygon was reached.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.textoutlines-Tuple{AbstractString, Point}","page":"Function reference","title":"Luxor.textoutlines","text":"textoutlines(s::String, pos::Point=O;\n    action=:none,\n    halign=:left,\n    valign=:baseline,\n    startnewpath=true)\n\nConvert text to polygons and apply action.\n\nBy default this function discards any current path, unless you use startnewpath=false\n\nSee also textpath(). textpath() retains Bezier curves, whereas textoutlines() returns flattened curves.\n\nTODO Return something more useful than a Boolean.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.textpath-Tuple{AbstractString, Point}","page":"Function reference","title":"Luxor.textpath","text":"textpath(s::String, pos::Point;\n    action=:none,\n    halign=:left,\n    valign=:baseline,\n    startnewpath=true)\n\nConvert the text in string s to paths and apply the action.\n\nTODO Return something more useful than a Boolean.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.textpath-Tuple{AbstractString}","page":"Function reference","title":"Luxor.textpath","text":"textpath(t)\n\nConvert the text in string t to paths, adding them to the current path, for subsequent filling/stroking etc...\n\nYou can use pathtopoly() or getpath() or getpathflat() to convert the paths to polygons.\n\nSee also textoutlines(). textpath() retains Bezier curves, whereas textoutlines() returns flattened curves.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.textplace-Tuple{AbstractString, Point, Vector}","page":"Function reference","title":"Luxor.textplace","text":"textplace(txt::T where T <: AbstractString, pos::Point, params::Vector;\n    action = :fill,\n    startnewpath = false)\n\nA low-level function that places text characters one by one according to the parameters in params. First character uses the first tuple, second character uses the second, and so on.\n\nReturns the next text position.\n\nA tuple of parameters is:\n\n(face = \"TimesRoman\", size = 12, color=colorant\"black\", kern = 0, shift = 0, advance = true)\n\nwhere\n\nface is fontface \"string\"                   # sticky\nsize is fontsize # pts                      # sticky\ncolor is color                              # sticky\nkern amount (pixels) shifted to the right   # resets after each char\nshift = baseline shifted vertically         # resets after each char\nadvance - whether to advance                # resets after each char\n\nSome parameters are \"sticky\": once set, they apply for all subsequent characters until a new value is supplied. Others aren't sticky, and are reset for each character. So font face, size, and color parameters need only be specified once, whereas kern/shift/advance modifiers are reset for each character.\n\nExample\n\nDraw the Hogwarts Express Platform number 9 and 3/4:\n\ntxtpos = textplace(\"93—4!\", O - (200, 0), [\n    # format for 9:\n    (size=120, face=\"Bodoni-Poster\", color=colorant\"grey10\"),\n    # format for 3:\n    (size=60,  kern = 5, shift = 60,  advance=false,),\n    # format for -:\n    (          kern = 0, shift = 25,  advance=false,),\n    # format for 4:\n    (          kern = 5, shift = -20, advance=true),\n    # format for !:\n    (size=120, kern = 20,),\n    ])\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.texttrack-Tuple{AbstractString, Any, Any, Any}","page":"Function reference","title":"Luxor.texttrack","text":"texttrack(txt, pos, tracking;\n    action=:fill,\n    halign=:left,\n    valign=:baseline,\n    startnewpath=true)\ntexttrack(txt, pos, tracking, fontsize;\n    action=:fill,\n    halign=:left,\n    valign=:baseline,\n    startnewpath=true)\n\nPlace the text in txt at pos, left-justified, and letter space ('track') the text using the value in tracking.\n\nThe tracking units depend on the current font size. In a 12‑point font, 1 em equals 12 points. A point is about 0.35mm, 1em is about 4.2mm, and a 1000 units of tracking are about 4.2mm. So a tracking value of 1000 for a 12 point font places about 4mm between each character.\n\nA negative value tightens the letter spacing noticeably.\n\nThe text drawing action applied to each character defaults to textoutlines(... :fill).\n\nIf startnewpath is true, each character is acted on separately. To clip and track text, specify the clip action and avoid resetting the clipping path for each character.\n\n    newpath()\n    texttrack(t, O + (0, 80), 200, action=:clip, startnewpath=false)\n    ...\n    clipreset()\n\nTODO Is it possible to fix strings with combining characters such as \"̈\"?\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.textwrap-Tuple{AbstractString, Real, Point, Function}","page":"Function reference","title":"Luxor.textwrap","text":"textwrap(s::T where T<:AbstractString, width::Real, pos::Point;\n    rightgutter=5,\n    leading=0)\ntextwrap(s::T where T<:AbstractString, width::Real, pos::Point, linefunc::Function;\n    rightgutter=5,\n    leading=0)\n\nDraw the string in s by splitting it at whitespace characters into lines, so that each line is no longer than width units. The text starts at pos such that the first line of text is drawn entirely below a line drawn horizontally through that position. Each line is aligned on the left side, below pos.\n\nSee also textbox().\n\nOptionally, before each line, execute the function linefunc(linenumber, linetext, startpos, leading).\n\nIf you don't supply a value for leading, the font's built-in extents are used.\n\nText with no whitespace characters won't wrap. You can write a simple chunking function to split a string or array into chunks:\n\nchunk(x, n) = [x[i:min(i+n-1,length(x))] for i in 1:n:length(x)]\n\nFor example:\n\ntextwrap(the_text, 300, boxtopleft(BoundingBox()) + 20,\n    (ln, lt, sp, ht) -> begin\n        c = count(t -> occursin(r\"[[:punct:]]\", t), split(lt, \"\"))\n        @layer begin\n            fontface(\"Menlo\")\n            sethue(\"darkred\")\n            text(string(\"[\", c, \"]\"), sp + (310, 0))\n        end\n    end)\n\nputs a count of the number of punctuation characters in each line at the end of the line.\n\nReturns the position of what would have been the next line.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.tickline-Tuple{Any, Any}","page":"Function reference","title":"Luxor.tickline","text":"tickline(startpos, finishpos;\n    startnumber         = 0,\n    finishnumber        = 1,\n    major               = 1,\n    minor               = 0,\n    major_tick_function = nothing,\n    minor_tick_function = nothing,\n    rounding            = 2,\n    axis                = true, # draw the line?\n    log                 = false,\n    vertices            = false # just return the points\n    )\n\nDraw a line with ticks. major is the number of ticks required between the start and finish point. So 1 divides the line in half. minor is the number of ticks between each major tick.\n\nExamples\n\ntickline(Point(0, 0), Point(100, 0))\ntickline(Point(0, 0), Point(100, 0), major = 4)\nmajorticks, minorticks = tickline(Point(0, 0), Point(100, 0), axis=false)\n\nCustom ticks\n\nSupply functions to make custom ticks. Custom tick functions should have arguments as follows:\n\nfunction mtick(n, pos;\n        startnumber         = 0,\n        finishnumber        = 1,\n        nticks = 1)\n        ...\n\nand\n\nfunction mntick(n, pos;\n        startnumber        = 0,\n        finishnumber       = 1,\n        nticks             = 1,\n        majorticklocations = [])\n        ...\n\nFor example:\n\ntickline(O - (300, 0), Point(300, 0),\n    startnumber  = -10,\n    finishnumber = 10,\n    minor        = 0,\n    major        = 4,\n    axis         = false,\n    major_tick_function = (n, pos;\n        startnumber=30, finishnumber=40, nticks=10) -> begin\n        @layer begin\n            translate(pos)\n            ticklength = get_fontsize()\n            line(O, O + polar(ticklength, 3π/2), :stroke)\n            k = rescale(n, 0, nticks - 1, startnumber, finishnumber)\n            ticklength = get_fontsize() * 1.3\n            text(\"$(round(k, digits=2))\",\n                O + (0, ticklength),\n                halign=:center,\n                valign=:middle,\n                angle = -getrotation())\n        end\n    end)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.tidysvg-Tuple{Any}","page":"Function reference","title":"Luxor.tidysvg","text":"tidysvg(fname)\n\nRead the SVG image in fname and write it to a file fname-tidy.svg with modified glyph names.\n\nReturn the name of the modified file.\n\nSVG images use named defs for text, which cause errors problem when used in a notebook. See for example.\n\nA kludgy workround is to rename the elements...\n\nAs of Luxor 3.6 this is done elsewhere.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.transform-Tuple{Array}","page":"Function reference","title":"Luxor.transform","text":"transform(a::Array)\n\nModify the current matrix by multiplying it by matrix a.\n\nFor example, to skew the current state by 45 degrees in x and move by 20 in y direction:\n\ntransform([1, 0, tand(45), 1, 0, 20])\n\nSee getmatrix() for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.translate-Tuple{Real, Real}","page":"Function reference","title":"Luxor.translate","text":"translate(point)\ntranslate(x::Real, y::Real)\n\nTranslate the current workspace to x and y or to pt.\n\nValues are relative to the current location.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.translationmatrix-Tuple{Any, Any}","page":"Function reference","title":"Luxor.translationmatrix","text":"translationmatrix(x, y)\n\nReturn a 3x3 Julia matrix that will apply a translation in x and y.\n\nSee getmatrix() for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.trianglecenter-Tuple{Point, Point, Point}","page":"Function reference","title":"Luxor.trianglecenter","text":"trianglecenter(pt1::Point, pt2::Point, pt3::Point)\n\nReturn the centroid of the triangle defined by pt1, pt2, and pt3.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.trianglecircumcenter-Tuple{Point, Point, Point}","page":"Function reference","title":"Luxor.trianglecircumcenter","text":"trianglecircumcenter(pt1::Point, pt2::Point, pt3::Point)\n\nReturn the circumcenter of the triangle defined by pt1, pt2, and pt3. The circumcenter is the center of a circle that passes through the vertices of the triangle.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.triangleincenter-Tuple{Point, Point, Point}","page":"Function reference","title":"Luxor.triangleincenter","text":"triangleincenter(pt1::Point, pt2::Point, pt3::Point)\n\nReturn the incenter of the triangle defined by pt1, pt2, and pt3. The incenter is the center of a circle inscribed inside the triangle.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.triangleorthocenter-Tuple{Point, Point, Point}","page":"Function reference","title":"Luxor.triangleorthocenter","text":"triangleorthocenter(pt1::Point, pt2::Point, pt3::Point)\n\nReturn the orthocenter of the triangle defined by pt1, pt2, and pt3.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.trimbezier-Tuple{BezierPathSegment, Any, Any}","page":"Function reference","title":"Luxor.trimbezier","text":"trimbezier(bps::BezierPathSegment, lowpt, highpt)\n\nChop the ends of a BezierPathSegment at lowpt and highpt. lowpt and highpt should be between 0 and 1.\n\nReturns a trimmed BezierPathSegment.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.writelatexchar-Tuple{Any, Any}","page":"Function reference","title":"Luxor.writelatexchar","text":"writelatexchar(t::AbstractString)\n\nHelper function to handle extra chars that are not supported in MathTeXEngine.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.AnimatedGif","page":"Function reference","title":"Luxor.AnimatedGif","text":"Wraps the location of an animated gif so that it can be displayed\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Luxor.BezierPath","page":"Function reference","title":"Luxor.BezierPath","text":"BezierPath is an array of BezierPathSegments. segments is Vector{BezierPathSegment}.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Luxor.BezierPathSegment","page":"Function reference","title":"Luxor.BezierPathSegment","text":"BezierPathSegment is an array of four points:\n\np1  - start point cp1 - control point for start point cp2 - control point for finishpoint p2  - finish point\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Luxor.BoundingBox-Tuple{AbstractString}","page":"Function reference","title":"Luxor.BoundingBox","text":"BoundingBox(str::AbstractString)\n\nReturn a BoundingBox that just encloses a text string, given the current font selection. Uses the Toy text API (ie text() and textextents()).\n\nText is assumed to be placed at the origin (0/0).\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.BoundingBox-Tuple{BoxmapTile}","page":"Function reference","title":"Luxor.BoundingBox","text":"BoundingBox(tile::BoxmapTile)\n\nReturn a BoundingBox of a BoxmapTile (as created with boxmap()).\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.BoundingBox-Tuple{Path}","page":"Function reference","title":"Luxor.BoundingBox","text":"BoundingBox(path::Path)\n\nFind bounding box of a stored Path (made with storepath()).\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.BoundingBox-Tuple{Table, Any, Any}","page":"Function reference","title":"Luxor.BoundingBox","text":"BoundingBox(t::table, rownumber, columnnumber)\n\nReturn a BoundingBox that encloses cell at row rownumber, column colnumber of table t.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.BoundingBox-Tuple{Table, Any}","page":"Function reference","title":"Luxor.BoundingBox","text":"BoundingBox(t::table, cell)\n\nReturn a BoundingBox that encloses cell cell of table t.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.BoundingBox-Tuple{Table}","page":"Function reference","title":"Luxor.BoundingBox","text":"BoundingBox(t::table)\n\nReturn a BoundingBox that encloses the table t.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.BoundingBox-Tuple{Tiler, Any, Any}","page":"Function reference","title":"Luxor.BoundingBox","text":"BoundingBox(t::Tiler, r, c)\n\nReturn the Bounding Box enclosing the tile at row r column c.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.BoundingBox-Tuple{Tiler, Any}","page":"Function reference","title":"Luxor.BoundingBox","text":"BoundingBox(t::Tiler, n)\n\nReturn the Bounding Box enclosing tile n.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.BoundingBox-Tuple{Vector{Point}}","page":"Function reference","title":"Luxor.BoundingBox","text":"BoundingBox(pointlist::Array)\n\nReturn the BoundingBox of a polygon (array of points).\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.BoundingBox-Tuple{}","page":"Function reference","title":"Luxor.BoundingBox","text":"BoundingBox() with no arguments returns a BoundingBox that includes the current drawing.\n\nThe default BoundingBox(;centered=true) returns a BoundingBox the same size and position as the current drawing, and assumes the origin (0, 0) is at the center.\n\nIf the centered option is false, the function assumes that the origin is at the top left of the drawing. So this function doesn't really work if the current matrix has been modified (by translate(), scale(), rotate() etc.)\n\nAn instance of the BoundingBox type holds two Points, corner1 and corner2.\n\nBoundingBox(;centered = true)   # the bounding box of the Drawing\n\nBoundingBox(s::AbstractString)  # the bounding box of a text string at the origin\n\nBoundingBox(pt::Array)          # the bounding box of a polygon\n\nBoundingBox(circle(O, 100))     # the bounding box of a path added by circle()\n\nBoundingBox(path::Path)         # the bounding box of a Path\n\nYou can use BoundingBox() with the functions that add graphic shapes to the current path (eg box(), circle(), star(), ngon()). But note that eg BoundingBox(box(O, 100, 100)) adds a shape to the current path as well as returning a bounding box.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.Drawing","page":"Function reference","title":"Luxor.Drawing","text":"Create a new drawing, and optionally specify file type (PNG, PDF, SVG, EPS), file-based or in-memory, and dimensions.\n\nDrawing(width=600, height=600, file=\"luxor-drawing.png\")\n\nExtended help\n\nDrawing()\n\ncreates a drawing, defaulting to PNG format, default filename \"luxor-drawing.png\", default size 800 pixels square.\n\nYou can specify dimensions, and assume the default output filename:\n\nDrawing(400, 300)\n\ncreates a drawing 400 pixels wide by 300 pixels high, defaulting to PNG format, default filename \"luxor-drawing.png\".\n\nDrawing(400, 300, \"my-drawing.pdf\")\n\ncreates a PDF drawing in the file \"my-drawing.pdf\", 400 by 300 pixels.\n\nDrawing(1200, 800, \"my-drawing.svg\")\n\ncreates an SVG drawing in the file \"my-drawing.svg\", 1200 by 800 pixels.\n\nDrawing(width, height, surfacetype | filename)\n\ncreates a new drawing of the given surface type (e.g. :svg, :png), storing the picture only in memory if no filename is provided.\n\nDrawing(1200, 1200/Base.Mathconstants.golden, \"my-drawing.eps\")\n\ncreates an EPS drawing in the file \"my-drawing.eps\", 1200 wide by 741.8 pixels (= 1200 ÷ ϕ) high. Only for PNG files must the dimensions be integers.\n\nDrawing(\"A4\", \"my-drawing.pdf\")\n\ncreates a drawing in ISO A4 size (595 wide by 842 high) in the file \"my-drawing.pdf\". Other sizes available are: \"A0\", \"A1\", \"A2\", \"A3\", \"A4\", \"A5\", \"A6\", \"Letter\", \"Legal\", \"A\", \"B\", \"C\", \"D\", \"E\". Append \"landscape\" to get the landscape version.\n\nDrawing(\"A4landscape\")\n\ncreates the drawing A4 landscape size.\n\nPDF files default to a white background, but PNG defaults to transparent, unless you specify one using background().\n\nDrawing(width, height, :image)\n\ncreates the drawing in an image buffer in memory. You can obtain the data as a matrix with image_as_matrix().\n\nDrawing(width, height, :rec)\n\ncreates the drawing in a recording surface in memory. snapshot(fname, ...) to any file format and bounding box, or render as pixels with image_as_matrix().\n\nDrawing(width, height, strokescale=true)\n\ncreates the drawing and enables stroke scaling (strokes will be scaled according to the current transformation). (Stroke scaling is disabled by default.)\n\nDrawing(img, strokescale=true)\n\ncreates the drawing from an existing image buffer of type Matrix{Union{RGB24,ARGB32}}, e.g.:\n\nusing Luxor, Colors\nbuffer=zeros(ARGB32, 100, 100)\nd=Drawing(buffer)\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Luxor.GridHex","page":"Function reference","title":"Luxor.GridHex","text":"GridHex(startpoint, radius, width=1200.0, height=1200.0)\n\nDefine a hexagonal grid, to start at startpoint and proceed along the x-axis and then along the y-axis, radius is the radius of a circle that encloses each hexagon. The distance in x between the centers of successive hexagons is:\n\nfracsqrt(3) radius2\n\nTo get the next point from the grid, use nextgridpoint(g::Grid).\n\nWhen you run out of grid points, you'll wrap round and start again.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Luxor.GridRect","page":"Function reference","title":"Luxor.GridRect","text":"GridRect(startpoint, xspacing, yspacing, width, height)\n\nDefine a rectangular grid, to start at startpoint and proceed along the x-axis in steps of xspacing, then along the y-axis in steps of yspacing.\n\nGridRect(startpoint, xspacing=100.0, yspacing=100.0, width=1200.0, height=1200.0)\n\nFor a column, set the xspacing to 0:\n\ngrid = GridRect(O, 0, 40)\n\nTo get points from the grid, use nextgridpoint(g::Grid).\n\njulia> grid = GridRect(O, 0, 40);\njulia> nextgridpoint(grid)\nLuxor.Point(0.0, 0.0)\n\njulia> nextgridpoint(grid)\nLuxor.Point(0.0, 40.0)\n\nWhen you run out of grid points, you'll wrap round and start again.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Luxor.HexagonAxial","page":"Function reference","title":"Luxor.HexagonAxial","text":"HexagonAxial\n\nTwo axes\n\nq:: first index\n\nr:: second index\n\norigin::Point\n\nwidth:: of tile\n\nheight:: of tile\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Luxor.HexagonCubic","page":"Function reference","title":"Luxor.HexagonCubic","text":"HexagonCubic\n\nThree axes\n\nq:: first index\n\nr:: second index\n\ns:: third index\n\norigin::Point\n\nwidth:: of tile\n\nheight:: of tile\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Luxor.HexagonOffsetEvenR","page":"Function reference","title":"Luxor.HexagonOffsetEvenR","text":"HexagonOffsetEvenR\n\neven rows shifted right\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Luxor.HexagonOffsetOddR","page":"Function reference","title":"Luxor.HexagonOffsetOddR","text":"HexagonOffsetOddR\n\nodd rows shifted right\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Luxor.Movie","page":"Function reference","title":"Luxor.Movie","text":"The Movie and Scene types and the animate() function are designed to help you create the frames that can be used to make an animated GIF or movie.\n\n1 Provide width, height, title, and optionally a frame range to the Movie constructor:\n\ndemo = Movie(400, 400, \"test\", 1:500)\n\n2 Define one or more scenes and scene-drawing functions.\n\n3 Run the animate() function, calling those scenes.\n\nExample\n\nbang = Movie(400, 100, \"bang\")\n\nbackdrop(scene, framenumber) =  background(\"black\")\n\nfunction frame1(scene, framenumber)\n    background(\"white\")\n    sethue(\"black\")\n    eased_n = scene.easingfunction(framenumber, 0, 1, scene.framerange.stop)\n    circle(O, 40 * eased_n, :fill)\nend\n\nanimate(bang, [\n    Scene(bang, backdrop, 0:200),\n    Scene(bang, frame1, 0:200, easingfunction=easeinsine)],\n    creategif=true,\n    pathname=\"/tmp/animationtest.gif\")\n\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Luxor.Movie-Tuple{Any, Any, AbstractString}","page":"Function reference","title":"Luxor.Movie","text":"Movie(width, height, movietitle)\n\nDefine a movie, specifying the width, height, and a title. The title will be used to make the output file name. The range defaults to 1:250.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.Partition","page":"Function reference","title":"Luxor.Partition","text":"p = Partition(areawidth, areaheight, tilewidth, tileheight)\n\nA Partition is an iterator that, for each iteration, returns a tuple of:\n\nthe x/y point of the center of each tile in a set of tiles that divide up a rectangular space such as a page into rows and columns (relative to current 0/0)\nthe number of the tile\n\nareawidth and areaheight are the dimensions of the area to be tiled, tilewidth/tileheight are the dimensions of the tiles.\n\nTiler and Partition are similar:\n\nPartition lets you specify the width and height of a cell\nTiler lets you specify how many rows and columns of cells you want, and a margin\ntiles = Partition(1200, 1200, 30, 30) for (pos, n) in tiles\nthe point pos is the center of the tile\nend\n\nYou can access the calculated tile width and height like this:\n\ntiles = Partition(1200, 1200, 30, 30)\nfor (pos, n) in tiles\n    ellipse(pos.x, pos.y, tiles.tilewidth, tiles.tileheight, :fill)\nend\n\nIt's sometimes useful to know which row and column you're currently on:\n\ntiles.currentrow\ntiles.currentcol\n\nshould have that information for you.\n\nUnless the tilewidth and tileheight are exact multiples of the area width and height, you'll see a border at the right and bottom where the tiles won't fit.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Luxor.Path","page":"Function reference","title":"Luxor.Path","text":"A Path object contains, in the .path field, a vector of PathElements (PathCurve, PathMove, PathLine, PathClose) that describe a Cairo path. Use drawpath() to draw it.\n\nPath([PathMove(Point(2.0, 90.5625)),\n      PathCurve(Point(4.08203, 68.16015), Point(11.28, 45.28), Point(24.8828, 26.40234)),\n      PathLine(Point(2.0, 90.5625)),\n      PathClose()\n     ])\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Luxor.Path-Tuple{Vector{Point}}","page":"Function reference","title":"Luxor.Path","text":"Path(ptlist::Vector{Point}; close=false))\n\nCreate a Path from the points in ptlist.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.Point","page":"Function reference","title":"Luxor.Point","text":"The Point type holds two coordinates. It's immutable, you can't change the values of the x and y values directly.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Luxor.Scene","page":"Function reference","title":"Luxor.Scene","text":"The Scene type defines a function to be used to render a range of frames in a movie.\n\nthe movie created by Movie()\nthe framefunction is a function taking two arguments: the scene and the framenumber.\nthe framerange determines which frames are processed by the function. Defaults to the entire movie.\nthe optional easingfunction can be accessed by the framefunction to vary the transition speed\nthe optional opts which is a single argument of an abstract type which can be accessed within the framefunction\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Luxor.Scene-Tuple{Movie, Function}","page":"Function reference","title":"Luxor.Scene","text":"Scene(movie, function, range;\n    easingfunction=easinoutquad,\n    optarg=nothing)\n\nUse the Scene() constructor function to create a scene. Supply a movie, a function to generate the scene, and a range of frames. Optionally you can supply an easing function, and other information, in optarg, which can be accessed as scene.opts.\n\nExample\n\nfunction initial(scene, framenumber)\n    balls = scene.opts\n    ...\nend\n\nanimate(poolmovie, [\n    Scene(poolmovie, initial, optarg=balls,   1:20),\n    ...\n    ])\n\nTo use an easing function inside the frame-generating function, you can create a normalized value with, for example:\n\neased_n = scene.easingfunction(framenumber, 0, 1, scene.framerange.stop)\n\nOr, if the scene doesn't start at frame 1, calculate normalized easing function like this:\n\neased_n = scene.easingfunction(framenumber - scene.framerange.start,\n    0, 1, scene.framerange.stop - scene.framerange.start)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Luxor.Table","page":"Function reference","title":"Luxor.Table","text":"t = Table(nrows, ncols)\nt = Table(nrows, ncols, colwidth, rowheight)\nt = Table(rowheights, columnwidths)\n\nTables are centered at O, but you can supply a point after the specifications.\n\nt = Table(nrows, ncols, centerpoint)\nt = Table(nrows, ncols, colwidth, rowheight, centerpoint)\nt = Table(rowheights, columnwidths, centerpoint)\n\nExamples\n\nSimple tables\n\nt = Table(4, 3) # 4 rows and 3 cols, default is 100w, 50 h\nt = Table(4, 3, 80, 30)   # 4 rows of 30pts high, 3 cols of 80pts wide\nt = Table(4, 3, (80, 30)) # same\nt = Table((4, 3), (80, 30)) # same\n\nSpecify row heights and column widths instead of quantities:\n\nt = Table([60, 40, 100], 50) # 3 different height rows, 1 column 50 wide\nt = Table([60, 40, 100], [100, 60, 40]) # 3 rows, 3 columns\nt = Table(fill(30, (10)), [50, 50, 50]) # 10 rows 30 high, 3 columns 10 wide\nt = Table(50, [60, 60, 60]) # just 1 row (50 high), 3 columns 60 wide\nt = Table([50], [50]) # just 1 row, 1 column, both 50 units wide\nt = Table(50, 50, 10, 5) # 50 rows, 50 columns, 10 units wide, 5 units high\nt = Table([6, 11, 16, 21, 26, 31, 36, 41, 46], [6, 11, 16, 21, 26, 31, 36, 41, 46])\nt = Table(15:5:55, vcat(5:2:15, 15:-2:5))\n #  table has 108 cells, with:\n #  row heights: 15 20 25 30 35 40 45 50 55\n #  col widths:  5 7 9 11 13 15 15 13 11 9 7 5\nt = Table(vcat(5:10:60, 60:-10:5), vcat(5:10:60, 60:-10:5))\nt = Table(vcat(5:10:60, 60:-10:5), 50) # 1 column 50 units wide\nt = Table(vcat(5:10:60, 60:-10:5), 1:5:50)\n\nA Table is an iterator that, for each iteration, returns a tuple of:\n\nthe x/y point of the center of cells arranged in rows and columns (relative to current 0/0)\nthe number of the cell (left to right, then top to bottom)\n\nnrows/ncols are the number of rows and columns required.\n\nIt's sometimes useful to know which row and column you're currently on while iterating:\n\nt.currentrow\nt.currentcol\n\nand row heights and column widths are available in:\n\nt.rowheights\nt.colwidths\n\nbox(t::Table, r, c) can be used to fill table cells:\n\n@svg begin\n    for (pt, n) in (t = Table(8, 3, 30, 15))\n        randomhue()\n        box(t, t.currentrow, t.currentcol, :fill)\n        sethue(\"white\")\n        text(string(n), pt)\n    end\nend\n\nor without iteration, using cellnumber:\n\n@svg begin\n    t = Table(8, 3, 30, 15)\n    for n in eachindex(t)\n        randomhue()\n        box(t, n, :fill)\n        sethue(\"white\")\n        text(string(n), t[n])\n    end\nend\n\nTo use a Table to make grid points:\n\njulia> first.(collect(Table(10, 6)))\n60-element Array{Luxor.Point,1}:\n Luxor.Point(-10.0, -18.0)\n Luxor.Point(-6.0, -18.0)\n Luxor.Point(-2.0, -18.0)\n ⋮\n Luxor.Point(2.0, 18.0)\n Luxor.Point(6.0, 18.0)\n Luxor.Point(10.0, 18.0)\n\nwhich returns an array of points that are the center points of the cells in the table.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Luxor.Tiler","page":"Function reference","title":"Luxor.Tiler","text":"tiles = Tiler(areawidth, areaheight, nrows, ncols, margin=20)\n\nA Tiler is an iterator that, for each iteration, returns a tuple of:\n\nthe x/y point of the center of each tile in a set of tiles that divide up a rectangular space such as a page into rows and columns (relative to current 0/0)\nthe number of the tile\n\nareawidth and areaheight are the dimensions of the area to be tiled, nrows/ncols are the number of rows and columns required, and margin is applied to all four edges of the area before the function calculates the tile sizes required.\n\nTiler and Partition are similar:\n\nPartition lets you specify the width and height of a cell\nTiler lets you specify how many rows and columns of cells you want, and a margin:\n\ntiles = Tiler(1000, 800, 4, 5, margin=20)\nfor (pos, n) in tiles\n    # the point pos is the center of the tile\nend\n\nYou can access the calculated tile width and height like this:\n\ntiles = Tiler(1000, 800, 4, 5, margin=20)\nfor (pos, n) in tiles\n    ellipse(pos.x, pos.y, tiles.tilewidth, tiles.tileheight, :fill)\nend\n\nIt's sometimes useful to know which row and column you're currently on. tiles.currentrow and tiles.currentcol should have that information for you.\n\nTo use a Tiler to make grid points:\n\nfirst.(collect(Tiler(800, 800, 4, 4)))\n\nwhich returns an array of points that are the center points of the grid.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Luxor.Turtle","page":"Function reference","title":"Luxor.Turtle","text":"Turtle()\nTurtle(O)\nTurtle(0, 0)\nTurtle(O, pendown=true, orientation=0, pencolor=(1.0, 0.25, 0.25))\n\nCreate a Turtle. You can command a turtle to move and draw \"turtle graphics\".\n\nThe commands (unusually for Julia) start with a capital letter, and angles are specified in degrees.\n\nBasic commands are Forward(), Turn(), Pendown(), Penup(), Pencolor(), Penwidth(), Circle(), Orientation(), Rectangle(), and Reposition().\n\nOthers include Push(), Pop(), Message(), HueShift(), Randomize_saturation(), Reposition(), and Pen_opacity_random().\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Luxor.O","page":"Function reference","title":"Luxor.O","text":"O is a shortcut for the current origin, 0/0\n\n\n\n\n\n","category":"constant"},{"location":"reference/api/#Luxor.paper_sizes","page":"Function reference","title":"Luxor.paper_sizes","text":"paper_sizes\n\nThe paper_sizes Dictionary holds a few paper sizes, width is first, so default is Portrait:\n\n\"A0\"      => (2384, 3370),\n\"A1\"      => (1684, 2384),\n\"A2\"      => (1191, 1684),\n\"A3\"      => (842, 1191),\n\"A4\"      => (595, 842),\n\"A5\"      => (420, 595),\n\"A6\"      => (298, 420),\n\"A\"       => (612, 792),\n\"Letter\"  => (612, 792),\n\"Legal\"   => (612, 1008),\n\"Ledger\"  => (792, 1224),\n\"B\"       => (612, 1008),\n\"C\"       => (1584, 1224),\n\"D\"       => (2448, 1584),\n\"E\"       => (3168, 2448))\n\n\n\n\n\n","category":"constant"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"DocTestSetup = quote\n    using Luxor, Dates, Colors\nend","category":"page"},{"location":"#Introduction-to-Luxor","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"","category":"section"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"Luxor is a Julia package for drawing simple static vector graphics. It provides basic drawing functions and utilities for working with shapes, polygons, clipping masks, PNG and SVG images, turtle graphics, and simple animations.","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"(Image: \"luxor gallery\")","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"The focus of Luxor is on simplicity and ease of use: it should be easier to use than plain Cairo.jl, with shorter names, fewer underscores, default contexts, and simplified functions.","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"Luxor is thoroughly procedural and static: your code issues a sequence of simple graphics 'commands' until you've completed a drawing, then the results are saved into a PDF, PNG, SVG, or EPS file.","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"There are some Luxor-related videos on YouTube, and some Luxor-related blog posts at cormullion.github.io/.","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"Luxor isn't interactive: for interactive graphics, look at Pluto.jl, Makie, and Javis.","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"Please submit issues and pull requests on GitHub. Original version by cormullion, much improved with contributions from the Julia community.","category":"page"},{"location":"#Installation-and-basic-usage","page":"Introduction to Luxor","title":"Installation and basic usage","text":"","category":"section"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"Install the package using the package manager:","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"] add Luxor","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"To use Luxor, type:","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"using Luxor","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"To test:","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"julia> @svg juliacircles()","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"or","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"julia> @png juliacircles()","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"which should create a graphic file and possibly also display and/or open it, depending on your environment.","category":"page"},{"location":"#Documentation","page":"Introduction to Luxor","title":"Documentation","text":"","category":"section"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"This documentation was built using Documenter.jl.","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"using Dates # hide\nprintln(\"Documentation built $(Dates.now()) with Julia $(VERSION) on $(Sys.KERNEL)\") # hide","category":"page"},{"location":"reference/functionindex/#Index","page":"Alphabetical function list","title":"Index","text":"","category":"section"},{"location":"reference/functionindex/","page":"Alphabetical function list","title":"Alphabetical function list","text":"","category":"page"},{"location":"tutorial/helloworld/","page":"Hello World","title":"Hello World","text":"DocTestSetup = quote\n    using Luxor, Colors\n    end","category":"page"},{"location":"tutorial/helloworld/#Hello-World","page":"Hello World","title":"Hello World","text":"","category":"section"},{"location":"tutorial/helloworld/","page":"Hello World","title":"Hello World","text":"If you're familiar with the basics of Cairo, PostScript, Processing, or similar graphics applications, you can probably glance at these tutorials, then move on to the How To sections.","category":"page"},{"location":"tutorial/helloworld/#What-you-need","page":"Hello World","title":"What you need","text":"","category":"section"},{"location":"tutorial/helloworld/","page":"Hello World","title":"Hello World","text":"If you've already downloaded Julia, and have added the Luxor package successfully (using ] add Luxor):","category":"page"},{"location":"tutorial/helloworld/","page":"Hello World","title":"Hello World","text":"$ julia\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.9.0-beta2 (2022-12-29)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\n(@v1.9) pkg> add Luxor","category":"page"},{"location":"tutorial/helloworld/","page":"Hello World","title":"Hello World","text":"then you're ready to start.","category":"page"},{"location":"tutorial/helloworld/","page":"Hello World","title":"Hello World","text":"You can work in a Jupyter or Pluto notebook, or use the VSCode editor/development environment. It's also possible to work in a text editor (make sure you know how to run a file of Julia code), or, at a pinch, you could use the Julia REPL directly.","category":"page"},{"location":"tutorial/helloworld/","page":"Hello World","title":"Hello World","text":"Ready? Let's begin.","category":"page"},{"location":"tutorial/helloworld/#First-steps","page":"Hello World","title":"First steps","text":"","category":"section"},{"location":"tutorial/helloworld/","page":"Hello World","title":"Hello World","text":"We'll have to load just one package for this tutorial:","category":"page"},{"location":"tutorial/helloworld/","page":"Hello World","title":"Hello World","text":"using Luxor","category":"page"},{"location":"tutorial/helloworld/","page":"Hello World","title":"Hello World","text":"Here's an easy shortcut for making drawings in Luxor. It's a Julia macro, and it's a good way to test that your system's working. Evaluate this code:","category":"page"},{"location":"tutorial/helloworld/","page":"Hello World","title":"Hello World","text":"@png begin\n    text(\"Hello world\")\n    circle(Point(0, 0), 200, action = :stroke)\nend","category":"page"},{"location":"tutorial/helloworld/","page":"Hello World","title":"Hello World","text":"using Luxor\nDrawing(725, 600, \"../assets/figures/tutorial-hello-world.png\")\nbackground(\"white\")\norigin()\nsethue(\"black\")\ntext(\"Hello world\")\ncircle(Point(0, 0), 200, action = :stroke)\nfinish()","category":"page"},{"location":"tutorial/helloworld/","page":"Hello World","title":"Hello World","text":"What happened? Can you see this image somewhere?","category":"page"},{"location":"tutorial/helloworld/","page":"Hello World","title":"Hello World","text":"(Image: point example)","category":"page"},{"location":"tutorial/helloworld/","page":"Hello World","title":"Hello World","text":"If you're using VS-Code, the image should appear in the Plots window. If you're working in a Jupyter or Pluto notebook, the image should appear below or above the code. If you're using Julia in a terminal or text editor, the image should have opened up in some other application, or, at the very least, it should have been saved in your current working directory (as luxor-drawing-(time stamp).png). If nothing happened, or if something bad happened, we've got some set-up or installation issues probably unrelated to Luxor...","category":"page"},{"location":"tutorial/helloworld/","page":"Hello World","title":"Hello World","text":"note: Note\nIn this example we've used a macro, @png. This macro is an easy way to make a drawing, because it saves a lot of typing. (The macro expands to enclose your drawing commands with calls to the Drawing(), origin, finish, and preview functions.) There are also @svg and @pdf macros, which do a similar thing. ","category":"page"},{"location":"tutorial/helloworld/","page":"Hello World","title":"Hello World","text":"PNGs and SVGs are good because they show up in VS-Code, Jupyter, and Pluto. SVGs are usually higher quality too, but they're text-based so can become very large and difficult to load if the image is complex. PDF documents are always higher quality, and usually open up in a separate application.","category":"page"},{"location":"tutorial/helloworld/","page":"Hello World","title":"Hello World","text":"This example illustrates a few things about Luxor drawings:","category":"page"},{"location":"tutorial/helloworld/","page":"Hello World","title":"Hello World","text":"There are default values which you don't have to set if you don't want to (file names, colors, font sizes, and so on).\nPositions on the drawing are specified with x and y coordinates stored in the Point type, and you can sometimes omit positions altogether.\nthe origin (0, 0) is at the centre of the drawing\nby default, the text is placed at the origin, and by default it's left aligned\nThe circle wasn't filled, but stroked. We passed the :stroke symbol as an action to the circle function. Many drawing functions expect some action, such as :fill or :stroke, and sometimes :clip or :fillstroke. This works either as an argument (:fill) or as a keyword argument (action=:fill).\nDid the first drawing takes a few seconds to appear? The drawing engine takes a little time to warm up. Once it's running, drawings appear much faster.","category":"page"},{"location":"tutorial/helloworld/","page":"Hello World","title":"Hello World","text":"Once more, with more black, and some rulers:","category":"page"},{"location":"tutorial/helloworld/","page":"Hello World","title":"Hello World","text":"@png begin\n    text(\"Hello again, world!\", Point(0, 250))\n    circle(Point(0, 0), 200, action = :fill)\n    rulers()\nend","category":"page"},{"location":"tutorial/helloworld/","page":"Hello World","title":"Hello World","text":"using Luxor\nDrawing(725, 502, \"../assets/figures/tutorial-hello-world-2.png\")\nbackground(\"white\")\norigin()\nsethue(\"black\")\ntext(\"Hello again, world!\", Point(0, 250))\ncircle(Point(0, 0), 200, action = :fill)\nrulers()\nfinish()","category":"page"},{"location":"tutorial/helloworld/","page":"Hello World","title":"Hello World","text":"(Image: point example)","category":"page"},{"location":"tutorial/helloworld/","page":"Hello World","title":"Hello World","text":"The x-coordinates usually run from left to right, the y-coordinates from top to bottom. So here, Point(0, 250) is a point at the left/right center, but at the bottom of the drawing.","category":"page"},{"location":"tutorial/helloworld/","page":"Hello World","title":"Hello World","text":"The rulers() function draws CAD-style x and y rulers at the origin.","category":"page"}]
}
